1100+ Java

Interview Questions and Answers




MCQ Format




Online Format:




https://bit.ly/online-courses-tests





Q: What is the difference between JDK and JRE?


A: JDK is the development kit and JRE is the runtime environment.

B: JRE is the development kit and JDK is the runtime environment.

C: Both JDK and JRE are the same.


Correct Response: 1

Explanation: JDK (Java Development Kit) is a collection of tools and libraries used for developing Java applications, while JRE (Java Runtime Environment) is a software platform that provides the necessary runtime environment to run Java applications.





Q: What is Java Virtual Machine (JVM)?


A: A hardware machine that runs Java programs.

B: An abstract computing machine that runs Java bytecode.

C: A software platform that runs Java applications.


Correct Response: 2

Explanation: JVM is an abstract computing machine that executes Java bytecode. It is responsible for managing memory, executing instructions, and providing security.





Q: What are the different types of memory areas allocated by JVM?


A: Stack

B: Heap

C: Method Area

D: Program Counter


Correct Response: 1, 2

Explanation: JVM allocates memory to several areas such as Stack, Heap, Method Area, and Program Counter. Stack is used to store method invocations and local variables, while Heap is used to store objects and instance variables. Method Area stores class-level information, and Program Counter stores the current location of the instruction being executed.





Q: What is JIT compiler?


A: A compiler that compiles Java code into machine code.

B: A compiler that compiles Java code into bytecode.

C: A compiler that compiles bytecode into machine code during runtime.


Correct Response: 3

Explanation: JIT (Just-In-Time) compiler is a compiler that compiles bytecode into machine code during runtime. This allows for faster execution of Java code as the bytecode is compiled when it is needed, rather than ahead of time.





Q: How Java platform is different from other platforms?


A: Java platform is a software-based platform.

B: Java platform is a hardware-based platform.

C: Java platform is both software and hardware based.


Correct Response: 1

Explanation: Java platform is a software-based platform, meaning it runs on top of an operating system and hardware. This allows Java applications to run on any device with a Java Virtual Machine installed, making it highly portable.





Q: Why people say that Java is 'write once and run anywhere' language?


A: Java is platform-independent.

B: Java is platform-dependent.

C: Java is both platform-independent and platform-dependent.


Correct Response: 1

Explanation: Java is platform-independent, meaning the same Java code can run on different platforms without any modification. This is due to the fact that Java code is compiled into bytecode, which can run on any device with a Java Virtual Machine installed.





Q: How does ClassLoader work in Java?


A: ClassLoader loads classes from the file system when the application starts.

B: ClassLoader loads classes dynamically as they are needed by the application.

C: ClassLoader loads classes from the database when the application starts.


Correct Response: 2

Explanation: ClassLoader in Java works by loading classes dynamically as they are needed by the application. It is responsible for finding and loading class files from the file system, network, or other sources.





Q: Do you think ‘main’ used for main method is a keyword in Java?


A: Yes, 'main' is a keyword in Java.

B: No, 'main' is not a keyword in Java.

C: Sometimes, 'main' is a keyword in Java.


Correct Response: 2

Explanation: 'main' is not a keyword in Java, it is just a conventional name for the entry point of a Java application. The main method must be declared as public static void and must take an array of Strings as a parameter.





Q: Can we write main method as public void static instead of public static void?


A: Yes, we can write the main method as public void static.

B: No, we cannot write the main method as public void static.

C: It depends on the Java version.


Correct Response: 2

Explanation: The main method must be declared as public static void, and cannot be declared as public void static. This is because the main method must be a static method so that it can be called without creating an instance of the class, and it must return void as it does not return a value.





Q: In Java, if we do not specify any value for local variables, then what will be the default value of the local variables?


A: 0

B: nan

C: undefined


Correct Response: 2

Explanation: In Java, if we do not specify a value for a local variable, its default value is null. Local variables in Java must be initialized before they can be used.





Q: Let say, we run a java class without passing any arguments. What will be the value of String array of arguments in Main method?


A: An empty array

B: A null array

C: An array with one element


Correct Response: 1

Explanation: If a Java class is run without passing any arguments, the value of the String array of arguments in the Main method will be an empty array. The length of the array will be 0, but it will not be null.





Q: What is the difference between byte and char data types in Java?


A: byte is a signed 8-bit type and char is an unsigned 16-bit type.

B: byte is an unsigned 8-bit type and char is a signed 16-bit type.

C: byte is a signed 8-bit type and char is a signed 16-bit type.

D: byte is an unsigned 8-bit type and char is an unsigned 16-bit type.


Correct Response: 1

Explanation: In Java, byte is a signed 8-bit type that can hold values from -128 to 127, while char is an unsigned 16-bit type that can hold values from 0 to 65535.





Q: What is the purpose of the Java Development Kit (JDK)?


A: The JDK provides a complete set of tools for developing Java applications.

B: The JDK provides a runtime environment to run Java applications.

C: The JDK provides both a development environment and a runtime environment for Java applications.


Correct Response: 1

Explanation: The Java Development Kit (JDK) is a collection of tools and libraries used for developing Java applications. It includes the Java compiler, the Java Virtual Machine (JVM), and other tools needed to develop, debug, and run Java applications.





Q: What is the role of the JRE in the Java environment?


A: The JRE provides a runtime environment to run Java applications.

B: The JRE provides a development environment to develop Java applications.

C: The JRE provides both a runtime environment and a development environment for Java applications.


Correct Response: 1

Explanation: The Java Runtime Environment (JRE) is a software platform that provides the necessary runtime environment to run Java applications. It includes the Java Virtual Machine (JVM), the Java class libraries, and other files needed to run Java applications.





Q: Can you explain the difference between a stack and a heap in Java memory management?


A: A stack is used for method invocations and local variables, while a heap is used for objects and instance variables.

B: A stack is used for objects and instance variables, while a heap is used for method invocations and local variables.

C: Both the stack and heap are used for the same purpose.


Correct Response: 1

Explanation: In Java, the stack is used to store method invocations and local variables, while the heap is used to store objects and instance variables. The stack is used for temporary storage and has a limited size, while the heap is used for long-term storage and can grow or shrink as needed.





Q: What is the purpose of the JIT compiler in the JVM?


A: To compile bytecode into machine code during runtime.

B: To compile bytecode into machine code ahead of time.

C: To compile machine code into bytecode during runtime.


Correct Response: 1

Explanation: The purpose of the JIT (Just-In-Time) compiler in the JVM is to compile bytecode into machine code during runtime. This allows for faster execution of Java code as the bytecode is compiled when it is needed, rather than ahead of time.





Q: Can you explain the difference between platform independence and platform-specific code in Java?


A: Platform-independent code can run on any platform, while platform-specific code can only run on a specific platform.

B: Platform-independent code can only run on a specific platform, while platform-specific code can run on any platform.

C: Both platform-independent code and platform-specific code can only run on a specific platform.


Correct Response: 1

Explanation: Platform-independent code can run on any platform, while platform-specific code can only run on a specific platform. Java is a platform-independent language, meaning the same Java code can run on different platforms without any modification. This is due to the fact that Java code is compiled into bytecode, which can run on any device with a Java Virtual Machine installed.





Q: What is the significance of the public static void main(String[] args) method in Java?


A: The main method is the entry point of a Java application.

B: The main method is not important in a Java application.

C: The main method is used to initialize an object in a Java application.


Correct Response: 1

Explanation: The public static void main(String[] args) method in Java is the entry point of a Java application. It is used to specify the starting point of the application and must be declared as public static void so that it can be called without creating an instance of the class.





Q: Can you explain the process of class loading in Java and the responsibilities of the ClassLoader class?


A: ClassLoader is responsible for finding and loading class files dynamically as they are needed by the application.

B: ClassLoader is responsible for finding and loading class files ahead of time.

C: ClassLoader is not responsible for finding and loading class files.


Correct Response: 1

Explanation: Class loading in Java is the process of finding and loading class files into the JVM. The ClassLoader class is responsible for finding and loading class files dynamically as they are needed by the application. It is also responsible for maintaining a cache of classes that have been loaded, so that they do not need to be loaded again.





Q: What are the implications of not specifying a value for local variables in Java?


A: Local variables must be initialized before they can be used.

B: Local variables do not need to be initialized before they can be used.

C: Local variables are automatically initialized to 0.


Correct Response: 1

Explanation: In Java, local variables must be initialized before they can be used. If a value is not specified for a local variable, the code will not compile and an error will be generated.





Q: Can you explain the difference between a primitive data type and a reference data type in Java?


A: Primitive data types are stored directly on the stack, while reference data types are stored on the heap and accessed through references.

B: Primitive data types are stored on the heap, while reference data types are stored directly on the stack and accessed through references.

C: Both primitive data types and reference data types are stored on the stack.


Correct Response: 1

Explanation: In Java, primitive data types such as int, double, and boolean are stored directly on the stack, while reference data types such as objects and arrays are stored on the heap and accessed through references. Primitive data types hold their values directly, while reference data types hold references to their values.





Q: What is the difference between the byte and char data types in terms of memory size and value range?


A: byte is a signed 8-bit type and char is an unsigned 16-bit type.

B: byte is an unsigned 8-bit type and char is a signed 16-bit type.

C: byte is a signed 8-bit type and char is a signed 16-bit type.

D: byte is an unsigned 8-bit type and char is an unsigned 16-bit type.


Correct Response: 1

Explanation: In Java, byte is a signed 8-bit type that can hold values from -128 to 127, while char is an unsigned 16-bit type that can hold values from 0 to 65535.





Q: What are the main principles of Object Oriented Programming?


A: Encapsulation

B: Inheritance

C: Polymorphism

D: Abstraction


Correct Response: 1, 2, 3, 4

Explanation: The main principles of Object Oriented Programming are Encapsulation, Inheritance, Polymorphism, and Abstraction. Encapsulation refers to the idea of wrapping data and behavior within an object. Inheritance allows objects to inherit properties from a parent object. Polymorphism allows objects to take on multiple forms. Abstraction refers to the act of representing essential features without including the background details.





Q: What is the difference between Object Oriented Programming language and Object Based Programming language?


A: Object Oriented Programming languages support inheritance and polymorphism, while Object Based Programming languages do not.

B: Object Oriented Programming languages do not support inheritance and polymorphism, while Object Based Programming languages do.

C: Both Object Oriented Programming languages and Object Based Programming languages support inheritance and polymorphism.


Correct Response: 1

Explanation: Object Oriented Programming (OOP) languages, such as Java and C++, support inheritance and polymorphism, while Object Based Programming (OBP) languages, such as JavaScript and VBScript, do not. OOP languages are designed around the concept of objects and the relationships between them, while OBP languages are focused on procedures and functions.





Q: In Java what is the default value of an object reference defined as an instance variable in an Object?


A: 0

B: nan

C: undefined


Correct Response: 2

Explanation: In Java, the default value of an object reference defined as an instance variable in an Object is null. Object references must be initialized before they can be used, otherwise a NullPointerException will be thrown at runtime.





Q: Why do we need constructor in Java?


A: To initialize objects and set default values for instance variables.

B: To declare methods in a class.

C: To declare variables in a class.


Correct Response: 1

Explanation: Constructors in Java are used to initialize objects and set default values for instance variables. They are called when an object is created and allow the programmer to specify the initial state of the object. Constructors have the same name as the class and do not have a return type.





Q: Why do we need default constructor in Java classes?


A: To provide a default constructor in case the programmer does not provide one.

B: To initialize objects with specific values.

C: To initialize objects with random values.


Correct Response: 1

Explanation: In Java, a default constructor is automatically provided by the compiler in case the programmer does not provide one. The default constructor is a no-argument constructor that sets default values for the instance variables. This is useful in cases where an object does not need to be initialized with specific values.





Q: What is the value returned by Constructor in Java?


A: Constructors do not return any value.

B: Constructors return an int value.

C: Constructors return a double value.

D: Constructors return a boolean value.


Correct Response: 1

Explanation: In Java, constructors do not return any value. They are called when an object is created and are used to initialize the object and set default values for instance variables.





Q: Can we inherit a Constructor?


A: No, constructors cannot be inherited.

B: Yes, constructors can be inherited.

C: Constructors can only be inherited in some cases.


Correct Response: 1

Explanation: In Java, constructors cannot be inherited. Each class has its own constructor and the constructor of a subclass must call the constructor of its superclass explicitly.





Q: Why constructors cannot be final, static, or abstract in Java?


A: Constructors are not meant to be overridden or modified, so they cannot be declared final. Constructors are not methods, so they cannot be declared static. Constructors are not meant to be subclassed, so they cannot be declared abstract.

B: Constructors are meant to be overridden or modified, so they must be declared final. Constructors are methods, so they must be declared static. Constructors are meant to be subclassed, so they must be declared abstract.

C: Both Constructors are meant to be overridden or modified and Constructors are not methods.


Correct Response: 1

Explanation: In Java, constructors cannot be declared final, static, or abstract. Constructors are not meant to be overridden or modified, so they cannot be declared final. Constructors are not methods, so they cannot be declared static. Constructors are not meant to be subclassed, so they cannot be declared abstract.





Q: What is inheritance in Object Oriented Programming?


A: Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class.

B: Inheritance is a mechanism by which a new class cannot inherit the properties and behavior of an existing class.

C: Inheritance is a mechanism by which a new class can only inherit the properties of an existing class and not the behavior.


Correct Response: 1

Explanation: Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class. The new class is called a subclass and the existing class is called a superclass. Inheritance allows for code reuse and provides a way to create new classes that are built on existing classes.





Q: What is polymorphism in Object Oriented Programming?


A: Polymorphism is the ability of an object to take on multiple forms.

B: Polymorphism is the inability of an object to take on multiple forms.

C: Polymorphism is the ability of a class to take on multiple forms.


Correct Response: 1

Explanation: Polymorphism is the ability of an object to take on multiple forms. It allows objects of different classes to be treated as objects of a common class. Polymorphism is achieved through method overriding, where a subclass can provide a different implementation for a method that is already defined in its superclass.





Q: What is encapsulation in Object Oriented Programming?


A: Encapsulation is the process of wrapping data and behavior within an object.

B: Encapsulation is the process of unwrapping data and behavior from an object.

C: Encapsulation is the process of modifying data and behavior within an object.


Correct Response: 1

Explanation: Encapsulation is the process of wrapping data and behavior within an object. It refers to the idea of hiding the internal details of an object and exposing only the essential features to the outside world. Encapsulation helps to promote encapsulation of data and reduces the risk of data corruption.





Q: What is abstraction in Object Oriented Programming?


A: Abstraction is the act of representing essential features without including the background details.

B: Abstraction is the act of including all details, even the background details.

C: Abstraction is the act of modifying essential features.


Correct Response: 1

Explanation: Abstraction is the act of representing essential features without including the background details. It refers to the process of focusing on the essential characteristics of an object and ignoring the non-essential details. Abstraction helps to reduce complexity and improve maintainability by providing a clear and simplified view of an object.





Q: Can an object in Java have multiple classes?


A: No, an object in Java can only have one class.

B: Yes, an object in Java can have multiple classes.

C: An object in Java can have multiple classes, but only in some cases.


Correct Response: 1

Explanation: In Java, an object can only have one class. Each object is an instance of a class and has its own unique identity and state. An object can belong to only one class, but it can be treated as an object of a common class through inheritance or polymorphism.





Q: What is method overloading in Java?


A: Method overloading is the ability of a class to have multiple methods with the same name but different parameters.

B: Method overloading is the inability of a class to have multiple methods with the same name but different parameters.

C: Method overloading is the ability of a class to have only one method with the same name.


Correct Response: 1

Explanation: Method overloading is the ability of a class to have multiple methods with the same name but different parameters. Method overloading allows for methods with the same name to be used for different purposes, based on the number and type of parameters passed in. Method overloading is useful for creating more readable and maintainable code.





Q: What is method overriding in Java?


A: Method overriding is the ability of a subclass to provide a different implementation for a method that is already defined in its superclass.

B: Method overriding is the inability of a subclass to provide a different implementation for a method that is already defined in its superclass.

C: Method overriding is the ability of a subclass to provide the same implementation for a method that is already defined in its superclass.


Correct Response: 1

Explanation: nan





Q: Can a constructor be private in Java?


A: Yes, a constructor can be private in Java.

B: No, a constructor cannot be private in Java.

C: A constructor can only be private in some cases.


Correct Response: 1

Explanation: In Java, a constructor can be private. A private constructor is used to restrict the creation of objects of a class from outside the class. This is useful in cases where a class is only meant to be used as a utility class, for example. A private constructor cannot be called from outside the class, so objects can only be created within the class.





Q: What is a super keyword in Java and when is it used?


A: The super keyword is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass.

B: The super keyword is used to refer to the subclass of an object. It is used in cases where a superclass needs to access a method or variable that is defined in its subclass.

C: The super keyword is used to refer to an object of a class. It is used in cases where an object needs to access a method or variable that is defined in its class.


Correct Response: 1

Explanation: The super keyword in Java is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass. The super keyword is also used to call the constructor of the superclass from the subclass. This allows the subclass to inherit the properties and behavior of its superclass, while also providing a way to extend or modify the behavior of the superclass.





Q: What is the purpose of ‘this’ keyword in Java?


A: The 'this' keyword is used to refer to the current object or instance of a class. It is used to access instance variables and methods of the current object.

B: The 'this' keyword is used to refer to a different object or instance of a class. It is used to access instance variables and methods of a different object.

C: The 'this' keyword is used to refer to the superclass of a class. It is used to access instance variables and methods of the superclass.


Correct Response: 1

Explanation: The 'this' keyword in Java is used to refer to the current object or instance of a class. It is used to access instance variables and methods of the current object. The 'this' keyword is useful for disambiguating instance variables from local variables with the same name, and for calling one constructor from another.





Q: Explain the concept of Inheritance?


A: Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class. The new class is called a subclass and the existing class is called a superclass. Inheritance allows for code reuse and provides a way to create new classes that are built on existing classes.

B: Inheritance is a mechanism by which a new class cannot inherit the properties and behavior of an existing class.

C: Inheritance is a mechanism by which a new class can only inherit the properties of an existing class and not the behavior.


Correct Response: 1

Explanation: Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class. The new class is called a subclass and the existing class is called a superclass. Inheritance allows for code reuse and provides a way to create new classes that are built on existing classes. The subclass can access the methods and variables defined in the superclass and can also override or extend the behavior of the superclass.





Q: Which class in Java is superclass of every other class?


A: java.lang.Object

B: java.lang.String

C: java.lang.Integer

D: java.lang.Number


Correct Response: 1

Explanation: In Java, every class is a subclass of the java.lang.Object class. The Object class is the root of the class hierarchy and provides a set of methods that are inherited by all classes. The Object class provides basic methods such as toString(), equals(), and hashCode() that are commonly used by all classes.





Q: Why Java does not support multiple inheritance?


A: Java does not support multiple inheritance to avoid the ambiguity and complexity that can arise from a class inheriting behavior from multiple superclasses.

B: Java supports multiple inheritance to allow a class to inherit behavior from multiple superclasses.

C: Java supports multiple inheritance in some cases, but not in others.


Correct Response: 1

Explanation: Java does not support multiple inheritance to avoid the ambiguity and complexity that can arise from a class inheriting behavior from multiple superclasses. In cases where a class needs to inherit behavior from multiple sources, Java uses interface implementation or aggregation (composition) instead of inheritance. This helps to simplify the class hierarchy and reduce the risk of conflicts between the superclasses.





Q: In OOPS, what is meant by composition?


A: Composition is a mechanism by which one object contains another object as a part of its state. The contained object is called a component and the containing object is called a composite. Composition is used to represent a part-whole relationship between objects.

B: Composition is a mechanism by which one object does not contain another object as a part of its state.

C: Composition is a mechanism by which one object is contained by another object. The containing object is called a component and the contained object is called a composite.


Correct Response: 1

Explanation: Composition is a mechanism by which one object contains another object as a part of its state. The contained object is called a component and the containing object is called a composite. Composition is used to represent a part-whole relationship between objects. Composition is used to achieve code reuse and to model complex relationships between objects.





Q: How aggregation and composition are different concepts?


A: Aggregation and composition are different in that aggregation represents a weak relationship between objects, while composition represents a strong relationship between objects. In aggregation, the contained object can exist independently of the containing object, while in composition, the contained object cannot exist independently of the containing object.

B: Aggregation and composition are the same concept.

C: Aggregation represents a strong relationship between objects, while composition represents a weak relationship between objects. In aggregation, the contained object cannot exist independently of the containing object, while in composition, the contained object can exist independently of the containing object.


Correct Response: 1

Explanation: Aggregation and composition are different in that aggregation represents a weak relationship between objects, while composition represents a strong relationship between objects. In aggregation, the contained object can exist independently of the containing object, while in composition, the contained object cannot exist independently of the containing object. Aggregation is used to represent a has-a relationship between objects, while composition is used to represent a part-whole relationship between objects.





Q: Why there are no pointers in Java?


A: Pointers are not supported in Java to improve security and reduce the risk of memory-related errors, such as null pointer exceptions and buffer overflows.

B: Pointers are supported in Java but are not commonly used.

C: Pointers are supported in Java and are commonly used.


Correct Response: 1

Explanation: Pointers are not supported in Java to improve security and reduce the risk of memory-related errors, such as null pointer exceptions and buffer overflows. Java uses references instead of pointers to refer to objects, and the JVM automatically manages memory and garbage collection. This helps to make Java code more secure and easier to maintain, and reduces the risk of errors related to memory management.





Q: If there are no pointers in Java, then why do we get NullPointerException?


A: The NullPointerException is thrown when a reference to an object is null and an attempt is made to access a method or field of the object. This can occur because Java uses references to refer to objects, and a reference can be set to null, which means that it does not refer to any object.

B: The NullPointerException is not thrown in Java because there are no pointers in Java.

C: The NullPointerException is thrown in Java because there are pointers in Java.


Correct Response: 1

Explanation: The NullPointerException is thrown when a reference to an object is null and an attempt is made to access a method or field of the object. This can occur because Java uses references to refer to objects, and a reference can be set to null, which means that it does not refer to any object. The NullPointerException is a common error in Java programming and can be prevented by checking for null references before accessing methods or fields of objects.





Q: What is the purpose of ‘super’ keyword in Java?


A: The 'super' keyword is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass. The 'super' keyword is also used to call the constructor of the superclass from the subclass.

B: The 'super' keyword is used to refer to the subclass of an object. It is used in cases where a superclass needs to access a method or variable that is defined in its subclass.

C: The 'super' keyword is used to refer to an object of a class. It is used in cases where an object needs to access a method or variable that is defined in its class.


Correct Response: 1

Explanation: The 'super' keyword in Java is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass. The 'super' keyword is also used to call the constructor of the superclass from the subclass. This allows the subclass to inherit the properties and behavior of its superclass, while also providing a way to extend or modify the behavior of the superclass.





Q: Is it possible to use this() and super() both in same constructor?


A: No, it is not possible to use both this() and super() in the same constructor. A constructor can either call another constructor using the this() keyword or call the superclass constructor using the super() keyword, but not both.

B: Yes, it is possible to use both this() and super() in the same constructor.

C: It is possible to use both this() and super() in the same constructor in some cases, but not in others.


Correct Response: 1

Explanation: No, it is not possible to use both this() and super() in the same constructor. A constructor can either call another constructor using the this() keyword or call the superclass constructor using the super() keyword, but not both. This is because the this() and super() keywords are used to call different constructors and cannot be used in the same constructor.





Q: What is the meaning of object cloning in Java?


A: Object cloning in Java refers to the process of creating a new object that is an exact copy of an existing object. This can be done using the clone() method of the Object class or by implementing the Cloneable interface and overriding the clone() method. Object cloning is used to create a duplicate of an object, and can be useful in cases where a copy of an object is needed but the original object should not be modified.

B: Object cloning in Java refers to the process of destroying an existing object.

C: Object cloning in Java refers to the process of creating a new object that is not an exact copy of an existing object.


Correct Response: 1

Explanation: Object cloning in Java refers to the process of creating a new object that is an exact copy of an existing object. This can be done using the clone() method of the Object class or by implementing the Cloneable interface and overriding the clone() method. Object cloning is used to create a duplicate of an object, and can be useful in cases where a copy of an object is needed but the original object should not be modified.





Q: What is the difference between inheritance and polymorphism?


A: Inheritance and polymorphism are two distinct concepts in Object Oriented Programming. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Polymorphism is a mechanism by which an object can exhibit different behavior based on the context in which it is used. Inheritance provides a way to create a hierarchy of classes, while polymorphism provides a way to write code that can handle objects of different classes in a generic way.

B: Inheritance and polymorphism are the same concept.

C: Inheritance provides a way to handle objects of different classes in a generic way, while polymorphism provides a way to create a hierarchy of classes.


Correct Response: 1

Explanation: Inheritance and polymorphism are two distinct concepts in Object Oriented Programming. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Polymorphism is a mechanism by which an object can exhibit different behavior based on the context in which it is used. Inheritance provides a way to create a hierarchy of classes, while polymorphism provides a way to write code that can handle objects of different classes in a generic way.





Q: Can a class be extended by multiple classes in Java?


A: No, a class cannot be extended by multiple classes in Java. Java only supports single inheritance, meaning that a class can only have one direct superclass. This helps to simplify the class hierarchy and reduce the risk of conflicts between the superclasses.

B: Yes, a class can be extended by multiple classes in Java.

C: It is possible for a class to be extended by multiple classes in Java in some cases, but not in others.


Correct Response: 1

Explanation: No, a class cannot be extended by multiple classes in Java. Java only supports single inheritance, meaning that a class can only have one direct superclass. This helps to simplify the class hierarchy and reduce the risk of conflicts between the superclasses. To achieve code reuse and to model complex relationships between objects, Java uses interface implementation or composition (aggregation) instead of multiple inheritance.





Q: What is the difference between inheritance and composition in Java?


A: Inheritance and composition are two different mechanisms for creating relationships between classes in Java. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Composition is a mechanism by which an object can be composed of other objects, allowing for code reuse and flexible design. Inheritance provides a way to create a hierarchy of classes and is useful for modeling relationships between objects, while composition provides a way to model complex relationships between objects and is useful for achieving code reuse.

B: Inheritance and composition are the same concept.

C: Composition provides a way to create a hierarchy of classes, while inheritance provides a way to model complex relationships between objects.


Correct Response: 1

Explanation: Inheritance and composition are two different mechanisms for creating relationships between classes in Java. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Composition is a mechanism by which an object can be composed of other objects, allowing for code reuse and flexible design. Inheritance provides a way to create a hierarchy of classes and is useful for modeling relationships between objects, while composition provides a way to model complex relationships between objects and is useful for achieving code reuse.





Q: What is method overloading and method overriding in Java?


A: Method overloading and method overriding are two different concepts in Java. Method overloading is a technique where a class can have multiple methods with the same name, but different parameters. This allows the class to provide multiple implementations of a method that can be called based on the parameters passed to the method. Method overriding is a technique where a subclass can provide its own implementation of a method that is defined in its superclass. This allows the subclass to extend or modify the behavior of the superclass.

B: Method overloading and method overriding are the same concept.

C: Method overloading provides a way to extend or modify the behavior of a class, while method overriding provides a way to have multiple methods with the same name in a class.


Correct Response: 1

Explanation: Method overloading and method overriding are two different concepts in Java. Method overloading is a technique where a class can have multiple methods with the same name, but different parameters. This allows the class to provide multiple implementations of a method that can be called based on the parameters passed to the method. Method overriding is a technique where a subclass can provide its own implementation of a method that is defined in its superclass. This allows the subclass to extend or modify the behavior of the superclass.





Q: What is an abstract class in Java and when should it be used?


A: An abstract class in Java is a class that cannot be instantiated and is used as a base class for other classes. An abstract class is defined using the abstract keyword and provides a partial implementation of a class that can be extended by concrete subclasses. An abstract class is useful when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class. An abstract class should be used when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class.

B: An abstract class in Java is a class that can be instantiated.

C: An abstract class in Java is a class that is used as a base class for other classes and cannot be extended.


Correct Response: 1

Explanation: An abstract class in Java is a class that cannot be instantiated and is used as a base class for other classes. An abstract class is defined using the abstract keyword and provides a partial implementation of a class that can be extended by concrete subclasses. An abstract class is useful when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class. An abstract class should be used when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class.





Q: Can a class be extended by a class and implemented by an interface at the same time in Java?


A: Yes, a class can be extended by a class and implemented by an interface at the same time in Java. Java supports multiple inheritance of types through the use of interfaces. A class can extend a superclass and implement one or more interfaces, allowing the class to inherit behavior from both its superclass and the interfaces it implements.

B: No, a class cannot be extended by a class and implemented by an interface at the same time in Java.

C: It is possible for a class to be extended by a class and implemented by an interface at the same time in Java in some cases, but not in others.


Correct Response: 1

Explanation: Yes, a class can be extended by a class and implemented by an interface at the same time in Java. Java supports multiple inheritance of types through the use of interfaces. A class can extend a superclass and implement one or more interfaces, allowing the class to inherit behavior from both its superclass and the interfaces it implements.





Q: What is the purpose of the abstract keyword in Java?


A: The abstract keyword in Java is used to define an abstract class or an abstract method. An abstract class is a class that cannot be instantiated and is used as a base class for other classes. An abstract method is a method that does not have an implementation and must be overridden by concrete subclasses. The abstract keyword provides a way to define classes and methods that must be extended or overridden by concrete subclasses, allowing for abstraction and the implementation of common behavior in the superclass.

B: The abstract keyword in Java is used to define a method that cannot be overridden by subclasses.

C: The abstract keyword in Java is used to define a class that can be instantiated.


Correct Response: 1

Explanation: The abstract keyword in Java is used to define an abstract class or an abstract method. An abstract class is a class that cannot be instantiated and is used as a base class for other classes. An abstract method is a method that does not have an implementation and must be overridden by concrete subclasses. The abstract keyword provides a way to define classes and methods that must be extended or overridden by concrete subclasses, allowing for abstraction and the implementation of common behavior in the superclass.





Q: Can a subclass constructor call the constructor of its superclass in Java?


A: Yes, a subclass constructor can call the constructor of its superclass in Java using the super keyword. The super keyword is used to call the constructor of the superclass and must be the first statement in the subclass constructor. Calling the superclass constructor allows the subclass to initialize the state of the superclass and extend its behavior.

B: No, a subclass constructor cannot call the constructor of its superclass in Java.

C: A subclass constructor can call the constructor of its superclass in Java in some cases, but not in others.


Correct Response: 1

Explanation: Yes, a subclass constructor can call the constructor of its superclass in Java using the super keyword. The super keyword is used to call the constructor of the superclass and must be the first statement in the subclass constructor. Calling the superclass constructor allows the subclass to initialize the state of the superclass and extend its behavior.





Q: What is the difference between a constructor and a method in Java?


A: A constructor and a method are two different concepts in Java. A constructor is a special type of method that is used to initialize an object and is called when an object is created. A constructor has the same name as the class and does not have a return type. A method is a block of code that performs a specific task and can be called multiple times during the lifetime of an object. A method has a name and a return type.

B: A constructor and a method are the same concept.

C: A constructor is a special type of method that is used to initialize an object and is called only once during the lifetime of an object. A method is a block of code that performs a specific task and can be called multiple times during the lifetime of an object.


Correct Response: 1

Explanation: A constructor and a method are two different concepts in Java. A constructor is a special type of method that is used to initialize an object and is called when an object is created. A constructor has the same name as the class and does not have a return type. A method is a block of code that performs a specific task and can be called multiple times during the lifetime of an object. A method has a name and a return type.





Q: In Java, why do we use static variable?


A: To share a single copy of the variable among all instances of the class.

B: To create a separate copy of the variable for each instance of the class.

C: To store global variables.


Correct Response: 1

Explanation: Static variables in Java are used to share a single copy of the variable among all instances of the class. This means that the value of the static variable can be accessed and modified by any instance of the class.





Q: Why it is not a good practice to create static variables in Java?


A: Because they are not thread-safe.

B: Because they cannot be modified.

C: Because they do not follow object-oriented principles.


Correct Response: 1

Explanation: Creating static variables in Java can lead to race conditions and other concurrency issues because they are not thread-safe. This means that multiple threads can access and modify the same static variable at the same time, leading to unexpected results.





Q: What is the purpose of static method in Java?


A: To access and modify instance variables.

B: To access and modify class variables.

C: To access class variables and methods without creating an instance of the class.


Correct Response: 3

Explanation: Static methods in Java can be accessed without creating an instance of the class. This makes them useful for operations that do not require access to instance variables or methods.





Q: Why do we mark main method as static in Java?


A: Because the main method must be static to be called by the JVM.

B: Because the main method must be static to access static variables.

C: Because the main method must be static to access instance variables.


Correct Response: 1

Explanation: The main method in Java must be marked as static because it is called by the JVM, which does not have access to instance variables or methods.





Q: In what scenario do we use a static block?


A: To initialize instance variables.

B: To initialize class variables.

C: To execute some code before the main method is called.


Correct Response: 2

Explanation: Static blocks in Java are used to initialize class variables. They are executed before the main method is called and are useful for initializing variables that need to be set up before the class is used.





Q: What happens when static modifier is not mentioned in the signature of main method?


A: The main method can still be executed.

B: The main method cannot be executed.

C: The main method can be executed but with limited functionality.


Correct Response: 2

Explanation: The main method must be marked as static in order to be executed by the JVM. If the static modifier is not mentioned, the JVM will not be able to find and execute the main method.





Q: What is the difference between static method and instance method in Java?


A: Static methods can access both static and instance variables, while instance methods can only access instance variables.

B: Instance methods can access both static and instance variables, while static methods can only access static variables.

C: Static methods can only access static variables, while instance methods can only access instance variables.


Correct Response: 1

Explanation: Static methods can access both static and instance variables, while instance methods can only access instance variables. This means that static methods can be accessed without creating an instance of the class, while instance methods must be called on an instance of the class.





Q: What is the difference between a static and non-static variable in Java?


A: Static variables are shared among all instances of a class, while non-static variables are separate for each instance.

B: Non-static variables are shared among all instances of a class, while static variables are separate for each instance.

C: Both static and non-static variables are the same.


Correct Response: 1

Explanation: Static variables in Java are shared among all instances of a class, while non-static variables are separate for each instance. This means that the value of a static variable can be accessed and modified by any instance of the class, while the value of a non-static variable is specific to a particular instance.





Q: Can a static method be overridden in Java?


A: Yes.

B: No.

C: It depends on the implementation.


Correct Response: 2

Explanation: Static methods in Java cannot be overridden because they are associated with the class, not with a particular instance. Overriding occurs when a subclass provides a new implementation for a method defined in its superclass. Since static methods are not associated with instances, they cannot be overridden.





Q: What is the lifecycle of a static variable in Java?


A: The lifecycle of a static variable begins when the class is loaded and ends when the class is unloaded.

B: The lifecycle of a static variable begins when the program is executed and ends when the program terminates.

C: The lifecycle of a static variable is determined by the programmer.


Correct Response: 1

Explanation: The lifecycle of a static variable in Java begins when the class is loaded and ends when the class is unloaded. This means that the value of a static variable persists for the lifetime of the class and is shared among all instances of the class.





Q: Can a static method be synchronized in Java?


A: Yes.

B: No.

C: It depends on the implementation.


Correct Response: 1

Explanation: Static methods in Java can be synchronized, just like instance methods. Synchronization is used to control access to a shared resource by multiple threads and ensure that only one thread can access the resource at a time.





Q: Can we access a non-static variable inside a static method in Java?


A: Yes, by creating an instance of the class.

B: No, it is not possible.

C: Yes, by using the this keyword.


Correct Response: 1

Explanation: Non-static variables can be accessed inside a static method in Java by creating an instance of the class and accessing the non-static variable through the instance.





Q: Can a static method access a non-static variable in Java?


A: Yes, by creating an instance of the class.

B: No, it is not possible.

C: Yes, by using the this keyword.


Correct Response: 1

Explanation: Static methods in Java can access non-static variables by creating an instance of the class and accessing the non-static variable through the instance.





Q: What is the difference between static and final keywords in Java?


A: Static is used to define class-level variables, while final is used to define constant variables.

B: Final is used to define class-level variables, while static is used to define constant variables.

C: Both static and final are used to define constant variables.


Correct Response: 1

Explanation: The static keyword in Java is used to define class-level variables, while the final keyword is used to define constant variables. This means that the value of a final variable cannot be changed after it is initialized, while the value of a static variable can be changed.





Q: Can a static class be inner class in Java?


A: Yes.

B: No.

C: It depends on the implementation.


Correct Response: 1

Explanation: In Java, a static class can be an inner class. An inner class is a class defined within another class, and a static inner class is a class that is declared with the static modifier.





Q: What is the other name of Method Overloading?


A: Compile-time polymorphism.

B: Run-time polymorphism.

C: Dynamic polymorphism.


Correct Response: 1

Explanation: Method overloading is also known as compile-time polymorphism. This is because the method to be called is determined at compile-time based on the arguments passed to the method.





Q: How will you implement method overloading in Java?


A: By defining multiple methods with the same name but different parameters.

B: By defining a single method with different implementations for different parameters.

C: By defining a single method with different return types for different parameters.


Correct Response: 1

Explanation: Method overloading in Java is implemented by defining multiple methods with the same name but different parameters. This allows for multiple methods with the same name to be called with different arguments, and the correct method to be called is determined based on the arguments passed.





Q: What kinds of argument variations are allowed in Method Overloading?


A: Number of arguments.

B: Data type of arguments.

C: Order of arguments.

D: All of the above.


Correct Response: 4

Explanation: In Java, method overloading can be achieved by varying the number of arguments, the data type of the arguments, or the order of the arguments. This allows for multiple methods with the same name to be called with different arguments, and the correct method to be called is determined based on the arguments passed.





Q: Why it is not possible to do method overloading by changing return type of method in java?


A: Because it can lead to ambiguity and confusion.

B: Because the return type is not considered in method overloading.

C: Because it is not supported by the Java language.


Correct Response: 1

Explanation: It is not possible to do method overloading by changing the return type of a method in Java because it can lead to ambiguity and confusion. The Java language considers only the method name and the number, types, and order of the parameters when determining which method to call.





Q: Is it allowed to overload main() method in Java?


A: Yes.

B: No.

C: It depends on the implementation.


Correct Response: 1

Explanation: It is allowed to overload the main() method in Java. This means that multiple methods with the same name (main) can be defined, each with different parameters. The JVM will call the main method with the signature specified in the java command-line argument.





Q: How do we implement method overriding in Java?


A: By defining a method in a subclass with the same name and parameters as a method in the superclass.

B: By defining a method in a subclass with a different name and parameters as a method in the superclass.

C: By defining a method in a subclass with the same name and different parameters as a method in the superclass.


Correct Response: 1

Explanation: Method overriding in Java is implemented by defining a method in a subclass with the same name and parameters as a method in the superclass. This allows the subclass to provide its own implementation for the method and override the behavior of the superclass method.





Q: Are we allowed to override a static method in Java?


A: No.

B: Yes.

C: It depends on the implementation.


Correct Response: 1

Explanation: Java does not allow overriding of static methods. Static methods are associated with the class and not with instances of the class, and therefore cannot be overridden by subclasses.





Q: Why Java does not allow overriding a static method?


A: Because static methods are associated with the class and not with instances of the class.

B: Because static methods cannot be polymorphic.

C: Because static methods cannot be accessed from an instance of the class.


Correct Response: 1

Explanation: Java does not allow overriding of static methods because static methods are associated with the class and not with instances of the class. Overriding occurs when a subclass provides a new implementation for a method defined in its superclass. Since static methods are not associated with instances, they cannot be overridden.





Q: Is it allowed to override an overloaded method?


A: No.

B: Yes.

C: It depends on the implementation.


Correct Response: 2

Explanation: In Java, it is allowed to override an overloaded method. Overloading occurs when multiple methods with the same name are defined, each with different parameters. Overriding occurs when a subclass provides a new implementation for a method defined in its superclass.





Q: What is the difference between method overloading and method overriding in Java?


A: Method overloading allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass.

B: Method overloading allows a subclass to provide a new implementation for a method defined in its superclass, while method overloading allows multiple methods with the same name but different parameters.

C: Both method overloading and method overriding are the same.


Correct Response: 1

Explanation: Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass. Overloading occurs at compile-time, while overriding occurs at runtime.





Q: Does Java allow virtual functions?


A: No.

B: Yes.

C: It depends on the implementation.


Correct Response: 2

Explanation: Java does allow virtual functions, although it does not use the term "virtual function." In Java, virtual functions are implemented as instance methods that can be overridden by subclasses. This allows the subclass to provide its own implementation for the method and override the behavior of the superclass method.





Q: What is meant by covariant return type in Java?


A: The ability to override a method in a subclass and change the return type to a subclass of the original return type.

B: The ability to overload a method in a subclass and change the return type to a subclass of the original return type.

C: The ability to overload a method in a subclass and change the return type to a superclass of the original return type.


Correct Response: 1

Explanation: In Java, a covariant return type is the ability to override a method in a subclass and change the return type to a subclass of the original return type. This allows for a more specific return type to be used in the subclass, while still maintaining compatibility with the superclass method.





Q: What is the main difference between method overloading and method overriding?


A: Method overloading allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass.

B: Method overloading allows a subclass to provide a new implementation for a method defined in its superclass, while method overloading allows multiple methods with the same name but different parameters.

C: Both method overloading and method overriding are the same.


Correct Response: 1

Explanation: Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass. Overloading occurs at compile-time, while overriding occurs at runtime.





Q: What is the purpose of method overloading in Java?


A: To allow multiple methods with the same name but different parameters.

B: To allow a subclass to provide a new implementation for a method defined in its superclass.

C: To allow a method to be called with different arguments.

D: All of the above.


Correct Response: 1

Explanation: The purpose of method overloading in Java is to allow multiple methods with the same name but different parameters. This allows for a single method name to be used with multiple sets of parameters, making the code more readable and maintainable.





Q: Can you override a final method in Java?


A: No.

B: Yes.

C: It depends on the implementation.


Correct Response: 1

Explanation: Java does not allow the overriding of final methods. A method declared with the final keyword cannot be overridden by any subclasses.





Q: Can you change the access level of an overridden method in Java?


A: No.

B: Yes.

C: It depends on the implementation.


Correct Response: 2

Explanation: In Java, it is allowed to change the access level of an overridden method. However, the access level cannot be made more restrictive than the access level of the overridden method in the superclass.





Q: What happens if a subclass does not provide an implementation for an abstract method inherited from its superclass?


A: The subclass must be declared abstract.

B: The subclass must provide an implementation for the abstract method.

C: The subclass can provide an implementation for the abstract method or be declared abstract itself.


Correct Response: 2

Explanation: In Java, if a subclass does not provide an implementation for an abstract method inherited from its superclass, the subclass must provide an implementation for the abstract method or be declared abstract itself. This allows the abstract method to be defined in the superclass, but implemented in the subclass.





Q: Can you call the overridden method from the subclass in Java?


A: Yes.

B: No.

C: It depends on the implementation.


Correct Response: 1

Explanation: In Java, it is possible to call the overridden method from the subclass. The subclass can use the super keyword to call the overridden method from the superclass. This allows the subclass to call the superclass implementation if it needs to use it, or it can choose to provide its own implementation.





Q: What is the relationship between method overloading and inheritance in Java?


A: Method overloading allows multiple methods with the same name but different parameters, while inheritance allows a subclass to inherit the properties and methods of its superclass.

B: Method overloading allows a subclass to inherit the properties and methods of its superclass, while inheritance allows multiple methods with the same name but different parameters.

C: Both method overloading and inheritance are the same.


Correct Response: 1

Explanation: Method overloading in Java allows multiple methods with the same name but different parameters, while inheritance allows a subclass to inherit the properties and methods of its superclass. They are distinct concepts and are not directly related.





Q: What is Runtime Polymorphism?


A: Polymorphism that occurs at compile-time.

B: Polymorphism that occurs at runtime.

C: Polymorphism that occurs both at compile-time and runtime.


Correct Response: 2

Explanation: Runtime Polymorphism, also known as dynamic polymorphism, is a form of polymorphism in which the correct method to be called is determined at runtime based on the type of the object being referenced. This is achieved through method overriding in Java.





Q: Is it possible to achieve Runtime Polymorphism by data members in Java?


A: No.

B: Yes.

C: It depends on the implementation.


Correct Response: 1

Explanation: It is not possible to achieve runtime polymorphism by data members in Java. Polymorphism is a concept that applies to methods and objects, not data members. Data members are simply variables associated with an object, and do not participate in polymorphism.





Q: Explain the difference between static and dynamic binding?


A: Static binding occurs at compile-time and dynamic binding occurs at runtime.

B: Static binding occurs at runtime and dynamic binding occurs at compile-time.

C: Both static binding and dynamic binding occur at compile-time.

D: Both static binding and dynamic binding occur at runtime.


Correct Response: 1

Explanation: Static binding, also known as early binding, occurs at compile-time when the type of an object is determined. Dynamic binding, also known as late binding, occurs at runtime when the type of an object is determined based on the actual object being referenced. In Java, static binding is used for methods declared as final or static, while dynamic binding is used for overridden methods.





Q: What is Polymorphism in Java?


A: The ability of an object to take on multiple forms.

B: The ability of a method to be called with multiple arguments.

C: The ability of a class to inherit properties and methods from multiple superclasses.


Correct Response: 1

Explanation: Polymorphism in Java is the ability of an object to take on multiple forms. This is achieved through method overloading and method overriding, which allow objects to have multiple behaviors depending on the context in which they are used.





Q: What is Compile-time Polymorphism in Java?


A: Polymorphism that occurs at compile-time.

B: Polymorphism that occurs at runtime.

C: Polymorphism that occurs both at compile-time and runtime.


Correct Response: 1

Explanation: Compile-time Polymorphism, also known as static polymorphism, is a form of polymorphism in which the type of an object is determined at compile-time. This is achieved through method overloading in Java.





Q: How is polymorphism achieved in Java?


A: By allowing an object to take on multiple forms through method overloading and method overriding.

B: By allowing a method to be called with multiple arguments.

C: By allowing a class to inherit properties and methods from multiple superclasses.


Correct Response: 1

Explanation: Polymorphism in Java is achieved by allowing an object to take on multiple forms through method overloading and method overriding. This allows objects to have multiple behaviors depending on the context in which they are used.





Q: Can you give an example of polymorphism in Java?


A: An example of polymorphism in Java would be a class hierarchy in which a subclass provides its own implementation for a method defined in its superclass.

B: An example of polymorphism in Java would be a method that can be called with multiple arguments.

C: An example of polymorphism in Java would be a class that can inherit properties and methods from multiple superclasses.


Correct Response: 1

Explanation: An example of polymorphism in Java would be a class hierarchy in which a subclass provides its own implementation for a method defined in its superclass. This allows the subclass to override the behavior of the superclass method, providing a new implementation that is specific to the subclass. This is achieved through method overriding in Java.





Q: What is method overloading in Java and how does it relate to polymorphism?


A: Method overloading in Java allows multiple methods with the same name but different parameters. It is a form of compile-time polymorphism that allows objects to have multiple behaviors based on the context in which they are used.

B: Method overloading in Java allows a subclass to provide a new implementation for a method defined in its superclass. It is a form of runtime polymorphism that allows objects to have multiple behaviors based on the context in which they are used.

C: Method overloading in Java allows a method to be called with multiple arguments. It is not related to polymorphism.


Correct Response: 1

Explanation: Method overloading in Java allows multiple methods with the same name but different parameters. It is a form of compile-time polymorphism that allows objects to have multiple behaviors based on the context in which they are used. Method overloading is a way to achieve polymorphism in Java by providing multiple implementations for a single method name, allowing the correct implementation to be selected based on the arguments passed to the method.





Q: What is method overriding in Java and how does it relate to polymorphism?


A: Method overriding in Java allows a subclass to provide a new implementation for a method defined in its superclass. It is a form of runtime polymorphism that allows objects to have multiple behaviors based on the context in which they are used.

B: Method overriding in Java allows multiple methods with the same name but different parameters. It is a form of compile-time polymorphism that allows objects to have multiple behaviors based on the context in which they are used.

C: Method overriding in Java allows a method to be called with multiple arguments. It is not related to polymorphism.


Correct Response: 1

Explanation: Method overriding in Java allows a subclass to provide a new implementation for a method defined in its superclass. It is a form of runtime polymorphism that allows objects to have multiple behaviors based on the context in which they are used. The type of the object being referenced, not the type of the reference, determines the method that will be called at runtime.





Q: Can you explain the concept of dynamic method dispatch in Java?


A: Dynamic method dispatch in Java refers to the process of determining the method to be called at runtime based on the type of the object being referenced. This is achieved through method overriding in Java and allows objects to have multiple behaviors based on the context in which they are used.

B: Dynamic method dispatch in Java refers to the process of determining the method to be called at compile-time based on the type of the reference. This is achieved through method overloading in Java and allows objects to have multiple behaviors based on the context in which they are used.

C: Dynamic method dispatch in Java is not related to polymorphism.


Correct Response: 1

Explanation: Dynamic method dispatch in Java refers to the process of determining the method to be called at runtime based on the type of the object being referenced. This is achieved through method overriding in Java and allows objects to have multiple behaviors based on the context in which they are used. The type of the object being referenced, not the type of the reference, determines the method that will be called at runtime.





Q: What is the difference between method overloading and method overriding in Java?


A: Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding in Java allows a subclass to provide a new implementation for a method defined in its superclass.

B: Method overloading in Java allows a subclass to provide a new implementation for a method defined in its superclass, while method overriding in Java allows multiple methods with the same name but different parameters.

C: Method overloading and method overriding are the same.


Correct Response: 1

Explanation: Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding in Java allows a subclass to provide a new implementation for a method defined in its superclass. Method overloading is a form of compile-time polymorphism, while method overriding is a form of runtime polymorphism.





Q: How does polymorphism help in achieving code reusability in Java?


A: Polymorphism in Java allows objects to have multiple behaviors based on the context in which they are used. This in turn helps to achieve code reusability by allowing developers to write code that can be used in multiple situations, rather than writing separate code for each situation.

B: Polymorphism in Java does not help in achieving code reusability.

C: Polymorphism in Java makes code harder to maintain and less reusable.


Correct Response: 1

Explanation: Polymorphism in Java allows objects to have multiple behaviors based on the context in which they are used. This in turn helps to achieve code reusability by allowing developers to write code that can be used in multiple situations, rather than writing separate code for each situation. By using polymorphism, developers can write code that can be reused in multiple contexts, which can make their code more efficient and maintainable.





Q: Can you explain the concept of virtual method invocation in Java?


A: Virtual method invocation in Java refers to the process of calling a method on an object based on the type of the object being referenced, rather than the type of the reference. This is achieved through method overriding in Java and allows objects to have multiple behaviors based on the context in which they are used.

B: Virtual method invocation in Java refers to the process of calling a method on an object based on the type of the reference, rather than the type of the object being referenced. This is achieved through method overloading in Java and allows objects to have multiple behaviors based on the context in which they are used.

C: Virtual method invocation in Java is not related to polymorphism.


Correct Response: 1

Explanation: Virtual method invocation in Java refers to the process of calling a method on an object based on the type of the object being referenced, rather than the type of the reference. This is achieved through method overriding in Java and allows objects to have multiple behaviors based on the context in which they are used. The type of the object being referenced, not the type of the reference, determines the method that will be called at runtime.





Q: What is the significance of the "final" keyword in relation to polymorphism in Java?


A: The "final" keyword in Java is used to indicate that a method or class cannot be overridden or subclassed. This can be used to prevent polymorphism from being used to change the behavior of a method or class.

B: The "final" keyword in Java is used to indicate that a method or class can be overridden or subclassed. This can be used to encourage polymorphism and allow the behavior of a method or class to be changed.

C: The "final" keyword in Java has no significance in relation to polymorphism.


Correct Response: 1

Explanation: The "final" keyword in Java is used to indicate that a method or class cannot be overridden or subclassed. This can be used to prevent polymorphism from being used to change the behavior of a method or class. By declaring a method or class as final, developers can ensure that its behavior cannot be changed through polymorphism, which can be useful for maintaining the stability and integrity of their code.





Q: Can you provide an example of polymorphism using abstract classes and interfaces in Java?


A: An example of polymorphism using abstract classes and interfaces in Java is to create an abstract class for a shape, with subclasses for specific shapes such as circles and rectangles. The abstract class defines methods for calculating the area and perimeter of a shape, which can then be overridden in the subclasses to provide specific implementations for each shape. The subclasses can then be used interchangeably in a program, with the correct implementation of the methods being called based on the type of the object being referenced.

B: An example of polymorphism using abstract classes and interfaces in Java is to create a class for each shape, with subclasses for specific shapes such as circles and rectangles. The classes define methods for calculating the area and perimeter of a shape, which can then be overridden in the subclasses to provide specific implementations for each shape. The subclasses cannot be used interchangeably in a program, as the type of the reference determines the method that will be called.

C: An example of polymorphism using abstract classes and interfaces in Java is to create a single class for all shapes, with methods for calculating the area and perimeter of a shape. The methods cannot be overridden, as the behavior of the class is fixed.


Correct Response: 1

Explanation: An example of polymorphism using abstract classes and interfaces in Java is to create an abstract class for a shape, with subclasses for specific shapes such as circles and rectangles. The abstract class defines methods for calculating the area and perimeter of a shape, which can then be overridden in the subclasses to provide specific implementations for each shape. The subclasses can then be used interchangeably in a program, with the correct implementation of the methods being called based on the type of the object being referenced. This allows for a more flexible and dynamic design, as new shapes can be added in the future without affecting the existing code.





Q: What are the benefits of using polymorphism in Java?


A: The benefits of using polymorphism in Java include increased code reusability, improved code maintainability, and the ability to create more flexible and dynamic designs. Polymorphism allows objects to have multiple behaviors based on the context in which they are used, which can make code more efficient and easier to maintain.

B: The benefits of using polymorphism in Java include decreased code reusability, reduced code maintainability, and the inability to create flexible and dynamic designs. Polymorphism makes code more complex and harder to maintain.

C: There are no benefits of using polymorphism in Java.


Correct Response: 1

Explanation: The benefits of using polymorphism in Java include increased code reusability, improved code maintainability, and the ability to create more flexible and dynamic designs. Polymorphism allows objects to have multiple behaviors based on the context in which they are used, which can make code more efficient and easier to maintain. By using polymorphism, developers can write code that can be reused in multiple contexts, which can make their code more efficient and maintainable.





Q: How does polymorphism allow for the implementation of dynamic and flexible designs in Java?


A: Polymorphism in Java allows for the implementation of dynamic and flexible designs by allowing objects to have multiple behaviors based on the context in which they are used. This is achieved through method overloading and method overriding, which allow objects to have multiple behaviors based on the type of the object being referenced. Polymorphism allows developers to write code that can be reused in multiple contexts, which can make their code more efficient and maintainable.

B: Polymorphism in Java makes it difficult to implement dynamic and flexible designs, as objects are limited to a single behavior. This makes code more complex and harder to maintain.

C: Polymorphism has no effect on the implementation of dynamic and flexible designs in Java.


Correct Response: 1

Explanation: Polymorphism in Java allows for the implementation of dynamic and flexible designs by allowing objects to have multiple behaviors based on the context in which they are used. This is achieved through method overloading and method overriding, which allow objects to have multiple behaviors based on the type of the object being referenced. Polymorphism allows developers to write code that can be reused in multiple contexts, which can make their code more efficient and maintainable. By using polymorphism, developers can create more flexible and dynamic designs that can change and adapt to changing requirements.





Q: Can you explain the role of polymorphism in Java's type system?


A: The role of polymorphism in Java's type system is to allow objects to have multiple behaviors based on the context in which they are used. Polymorphism is achieved through method overloading and method overriding, which allow objects to have multiple behaviors based on the type of the object being referenced. This allows Java's type system to be more flexible and dynamic, allowing objects to have different behaviors in different situations.

B: The role of polymorphism in Java's type system is to limit objects to a single behavior. This makes Java's type system more rigid and less flexible, making it more difficult to create dynamic and flexible designs.

C: The role of polymorphism in Java's type system is not related to the flexibility or dynamic nature of Java's type system.


Correct Response: 1

Explanation: The role of polymorphism in Java's type system is to allow objects to have multiple behaviors based on the context in which they are used. Polymorphism is achieved through method overloading and method overriding, which allow objects to have multiple behaviors based on the type of the object being referenced. This allows Java's type system to be more flexible and dynamic, allowing objects to have different behaviors in different situations. By using polymorphism, Java's type system can be made more flexible and adaptable, allowing developers to create more dynamic and flexible designs.





Q: What is the relationship between polymorphism and inheritance in Java?


A: The relationship between polymorphism and inheritance in Java is that polymorphism is often achieved through inheritance. Polymorphism allows objects to have multiple behaviors based on the context in which they are used, while inheritance allows objects to inherit the properties and behaviors of a parent class. By using inheritance to create subclasses, polymorphism can be achieved by allowing objects to have different behaviors based on the type of the object being referenced.

B: The relationship between polymorphism and inheritance in Java is that polymorphism and inheritance are completely independent concepts in Java and have no direct relationship.

C: The relationship between polymorphism and inheritance in Java is that inheritance is a form of polymorphism, as objects can inherit the properties and behaviors of a parent class.


Correct Response: 1

Explanation: The relationship between polymorphism and inheritance in Java is that polymorphism is often achieved through inheritance. Polymorphism allows objects to have multiple behaviors based on the context in which they are used, while inheritance allows objects to inherit the properties and behaviors of a parent class. By using inheritance to create subclasses, polymorphism can be achieved by allowing objects to have different behaviors based on the type of the object being referenced. This allows for a more flexible and dynamic design, as new behaviors can be added to objects by creating new subclasses.





Q: What is Abstraction in Object Oriented programming?


A: The process of hiding implementation details and showing only the essential features of an object.

B: The process of exposing implementation details and showing all the features of an object.

C: The process of creating objects.


Correct Response: 1

Explanation: Abstraction is a fundamental concept in object-oriented programming and is the process of hiding implementation details and showing only the essential features of an object. This allows for a clear and concise representation of the object and helps to reduce complexity.





Q: How is Abstraction different from Encapsulation?


A: Abstraction focuses on hiding implementation details, while encapsulation focuses on hiding data.

B: Abstraction focuses on exposing implementation details, while encapsulation focuses on hiding data.

C: Both Abstraction and Encapsulation are the same.


Correct Response: 1

Explanation: Abstraction focuses on hiding implementation details and showing only the essential features of an object, while encapsulation focuses on hiding data within an object by binding data and functions together within a single unit, or object.





Q: What is an abstract class in Java?


A: A class that cannot be instantiated and is meant to be subclassed.

B: A class that can be instantiated and is meant to be subclassed.

C: A class that can be instantiated and is not meant to be subclassed.


Correct Response: 1

Explanation: An abstract class in Java is a class that cannot be instantiated and is meant to be subclassed. Abstract classes provide a base for subclasses to build upon and can contain both abstract and concrete methods.





Q: Is it allowed to mark a method abstract method without marking the class abstract?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, it is not allowed to mark a method abstract without marking the class abstract. An abstract method must be declared within an abstract class, as it is meant to be overridden by subclasses.





Q: Is it allowed to mark a method abstract as well as final?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, it is not allowed to mark a method as both abstract and final. An abstract method must be overridden by subclasses, while a final method cannot be overridden. These two concepts are mutually exclusive.





Q: Can we instantiate an abstract class in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, we cannot instantiate an abstract class in Java. An abstract class is meant to be subclassed and cannot be instantiated directly.





Q: What is an interface in Java?


A: A blueprint for a class that outlines methods but does not provide implementation.

B: A blueprint for a class that provides implementation for all methods.

C: A class with only static methods.


Correct Response: 1

Explanation: An interface in Java is a blueprint for a class that outlines methods but does not provide implementation. Interfaces allow for the creation of objects that have a common set of methods but can have different implementations.





Q: Is it allowed to mark an interface method as static?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, it is not allowed to mark an interface method as static. All methods in an interface are automatically public and abstract, and cannot be marked as static.





Q: Why an Interface cannot be marked as final in Java?


A: An interface is meant to be implemented, not extended.

B: Interfaces cannot be marked as final because they are abstract.

C: Interfaces cannot be marked as final because they are meant to be overridden.


Correct Response: 1

Explanation: An interface in Java is meant to be implemented, not extended. Marking an interface as final would prevent it from being implemented and goes against the purpose of an interface.





Q: What is a marker interface?


A: An interface that has no methods but is used to indicate a certain property of a class.

B: An interface that has methods and is used to indicate a certain property of a class.

C: A class that has no methods and is used to indicate a certain property of an object.


Correct Response: 1

Explanation: A marker interface in Java is an interface that has no methods but is used to indicate a certain property of a class. For example, java.io.Serializable is a marker interface that indicates that a class is serializable.





Q: What can we use instead of Marker interface?


A: Annotation

B: Abstract class

C: Interface


Correct Response: 1

Explanation: We can use annotations instead of marker interfaces to indicate a certain property of a class. Annotations provide a more flexible and powerful mechanism for adding metadata to a class.





Q: How Annotations are better than Marker Interfaces?


A: Annotations provide a more flexible and powerful mechanism for adding metadata to a class.

B: Marker interfaces are more flexible and powerful than annotations.

C: Both are the same.


Correct Response: 1

Explanation: Annotations provide a more flexible and powerful mechanism for adding metadata to a class, as they allow for the addition of more complex information, such as parameter values, to a class. Marker interfaces are limited to indicating a certain property of a class but do not provide any additional information.





Q: What is the difference between abstract class and interface in Java?


A: An abstract class can have both abstract and concrete methods, while an interface can only have abstract methods.

B: An abstract class can only have abstract methods, while an interface can have both abstract and concrete methods.

C: Both abstract class and interface are the same.


Correct Response: 1

Explanation: An abstract class in Java can have both abstract and concrete methods, while an interface can only have abstract methods. An abstract class is meant to be subclassed and provides a base for subclasses to build upon, while an interface is meant to be implemented and provides a blueprint for a class.





Q: Does Java allow us to use private and protected modifiers for variables in interfaces?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, Java does not allow us to use private and protected modifiers for variables in interfaces. All variables in an interface are automatically public, static, and final.





Q: How can we cast to an object reference to an interface reference?


A: By using a typecast operator and the interface name.

B: By using a typecast operator and the object class name.

C: By using a typecast operator and the abstract class name.


Correct Response: 1

Explanation: We can cast an object reference to an interface reference by using a typecast operator and the interface name. This allows the object reference to be used as a reference to the interface, and access to the methods declared in the interface.





Q: What is the purpose of using abstraction in Java?


A: To reduce complexity and increase maintainability of code.

B: To increase complexity and decrease maintainability of code.

C: To create objects.


Correct Response: 1

Explanation: The purpose of using abstraction in Java is to reduce complexity and increase maintainability of code. Abstraction allows for the hiding of implementation details and the showing of only the essential features of an object, making the code easier to understand and maintain.





Q: Can an abstract class have a constructor in Java?


A: Yes

B: No

C: It depends


Correct Response: 1

Explanation: Yes, an abstract class in Java can have a constructor. A constructor in an abstract class is used to initialize objects of the abstract class or its subclasses.





Q: Can we extend more than one abstract class in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, we cannot extend more than one abstract class in Java. Java only allows for single inheritance, meaning a class can only extend one other class.





Q: Can an interface have a constructor in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, an interface in Java cannot have a constructor. Interfaces do not provide implementation for methods and cannot be instantiated, so they do not need a constructor.





Q: Can we extend multiple interfaces in Java?


A: Yes

B: No

C: It depends


Correct Response: 1

Explanation: Yes, we can extend multiple interfaces in Java. Java allows for multiple inheritance through interfaces, meaning a class can implement multiple interfaces.





Q: What is the difference between abstract method and concrete method in Java?


A: An abstract method has no body, while a concrete method has a body.

B: A concrete method has no body, while an abstract method has a body.

C: Both abstract methods and concrete methods have a body.


Correct Response: 1

Explanation: An abstract method in Java has no body and must be overridden by a subclass, while a concrete method has a body and can be directly invoked.





Q: Can we define an abstract method with a body in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, we cannot define an abstract method with a body in Java. An abstract method must be declared without a body, as it is meant to be overridden by a subclass.





Q: How does abstraction help in achieving loose coupling in Java?


A: By hiding implementation details and exposing only the essential features of an object, abstraction promotes loose coupling, as objects can interact with each other without having to know about each other's implementation details.

B: By exposing implementation details and hiding only the essential features of an object, abstraction promotes tight coupling, as objects must know about each other's implementation details in order to interact.

C: Abstraction does not promote either loose or tight coupling.


Correct Response: 1

Explanation: By hiding implementation details and exposing only the essential features of an object, abstraction promotes loose coupling, as objects can interact with each other without having to know about each other's implementation details. This allows for greater flexibility and maintainability of code.





Q: Can we declare an interface method as private in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, we cannot declare an interface method as private in Java. All methods in an interface are automatically public and abstract, and cannot be marked as private.





Q: Can we declare variables in an interface in Java?


A: Yes

B: No

C: It depends


Correct Response: 1

Explanation: Yes, we can declare variables in an interface in Java. Variables declared in an interface are automatically public, static, and final.





Q: What is the use of default methods in interfaces in Java?


A: Default methods provide a default implementation for a method in an interface, allowing the method to be used by implementing classes without having to provide their own implementation.

B: Default methods do not provide any functionality.

C: Default methods provide a way to extend an interface with additional methods.


Correct Response: 1

Explanation: Default methods provide a default implementation for a method in an interface, allowing the method to be used by implementing classes without having to provide their own implementation. This allows for greater compatibility and maintainability of code, as new methods can be added to an interface without breaking existing implementations.





Q: How does abstraction help in reducing complexity in Java?


A: By hiding implementation details and exposing only the essential features of an object, abstraction reduces complexity, as objects can interact with each other without having to know about each other's implementation details.

B: By exposing implementation details and hiding only the essential features of an object, abstraction increases complexity, as objects must know about each other's implementation details in order to interact.

C: Abstraction does not affect complexity.


Correct Response: 1

Explanation: By hiding implementation details and exposing only the essential features of an object, abstraction reduces complexity, as objects can interact with each other without having to know about each other's implementation details. This makes the code easier to understand and maintain.





Q: How can you change the value of a final variable in Java?


A: You cannot change the value of a final variable in Java once it has been assigned.

B: By re-assigning the value to the final variable.

C: By using a setter method.


Correct Response: 1

Explanation: You cannot change the value of a final variable in Java once it has been assigned. A final variable is a constant that cannot be changed after it has been assigned a value.





Q: Can a class be marked final in Java?


A: Yes

B: No

C: It depends


Correct Response: 1

Explanation: Yes, a class in Java can be marked final. A final class cannot be subclassed, meaning it cannot be used as the base for other classes to extend from.





Q: How can we create a final method in Java?


A: By using the final keyword before the method signature.

B: By using the static keyword before the method signature.

C: By using the abstract keyword before the method signature.


Correct Response: 1

Explanation: We can create a final method in Java by using the final keyword before the method signature. A final method cannot be overridden by subclasses, meaning it cannot be changed by subclasses.





Q: How can we prohibit inheritance in Java?


A: By marking the class final.

B: By marking the method final.

C: By using the private keyword before the class signature.


Correct Response: 1

Explanation: We can prohibit inheritance in Java by marking the class final. A final class cannot be subclassed, meaning it cannot be used as the base for other classes to extend from.





Q: Why Integer class in final in Java?


A: The Integer class is final in Java to ensure that the value of an Integer object cannot be changed after it has been assigned.

B: The Integer class is final in Java to prevent subclasses from being created.

C: The Integer class is final in Java to improve performance.


Correct Response: 1

Explanation: The Integer class is final in Java to ensure that the value of an Integer object cannot be changed after it has been assigned. Making the class final provides a guarantee that the value will not change, allowing for better reliability and security of the code.





Q: What is a blank final variable in Java?


A: A blank final variable is a final variable that has not been assigned a value.

B: A blank final variable is a variable that has been assigned a value but is not final.

C: A blank final variable is a final variable that has been assigned a value but can be changed.


Correct Response: 1

Explanation: A blank final variable is a final variable that has not been assigned a value. It must be assigned a value before the constructor for the object that contains the variable is complete.





Q: How can we initialize a blank final variable?


A: By assigning a value to the variable before the end of the constructor for the object that contains the variable.

B: By using a setter method.

C: By using a constructor.


Correct Response: 1

Explanation: We can initialize a blank final variable by assigning a value to the variable before the end of the constructor for the object that contains the variable. The value must be assigned before the constructor is complete in order for the final variable to have a value.





Q: Is it allowed to declare main method as final?


A: Yes

B: No

C: It depends


Correct Response: 1

Explanation: Yes, it is allowed to declare the main method as final in Java. However, declaring the main method as final will not change its behavior, as the main method is not meant to be overridden.





Q: What is the difference between a final variable and a constant in Java?


A: A final variable is a variable that cannot be changed after it has been assigned a value, while a constant is a variable that has a value that cannot be changed.

B: A constant is a variable that cannot be changed after it has been assigned a value, while a final variable is a variable that has a value that can be changed.

C: There is no difference between a final variable and a constant in Java.


Correct Response: 1

Explanation: A final variable is a variable that cannot be changed after it has been assigned a value, while a constant is a variable that has a value that cannot be changed. Constants in Java are typically declared using the final keyword and all uppercase letters to indicate that their value should not change.





Q: Can a final method be overridden in a subclass?


A: No

B: Yes

C: It depends


Correct Response: 1

Explanation: No, a final method cannot be overridden in a subclass. A final method is meant to be a fixed implementation that cannot be changed by subclasses.





Q: How does marking a class as final affect polymorphism in Java?


A: Marking a class as final prevents polymorphism, as a final class cannot be used as the base class for other classes to extend from.

B: Marking a class as final does not affect polymorphism.

C: Marking a class as final promotes polymorphism, as a final class can be used as the base class for other classes to extend from.


Correct Response: 1

Explanation: Marking a class as final prevents polymorphism, as a final class cannot be used as the base class for other classes to extend from. This means that a final class cannot be used in place of its base class in polymorphic situations.





Q: What is the purpose of a final blank variable in Java?


A: A final blank variable is a variable that has not been assigned a value and must be assigned a value before the end of the constructor for the object that contains the variable.

B: A final blank variable is a variable that can be assigned a value after it has been created.

C: A final blank variable is a variable that can be changed after it has been assigned a value.


Correct Response: 1

Explanation: A final blank variable is a variable that has not been assigned a value and must be assigned a value before the end of the constructor for the object that contains the variable. The purpose of a final blank variable is to ensure that the variable has a value and cannot be changed after it has been assigned.





Q: Can a final class be extended in Java?


A: No

B: Yes

C: It depends


Correct Response: 1

Explanation: No, a final class cannot be extended in Java. A final class is meant to be a fixed implementation that cannot be changed by subclasses.





Q: What is the difference between declaring a method as final and declaring a class as final?


A: Declaring a method as final prevents the method from being overridden in subclasses, while declaring a class as final prevents the class from being used as the base class for other classes to extend from.

B: Declaring a method as final allows the method to be overridden in subclasses, while declaring a class as final promotes polymorphism.

C: There is no difference between declaring a method as final and declaring a class as final.


Correct Response: 1

Explanation: Declaring a method as final prevents the method from being overridden in subclasses, while declaring a class as final prevents the class from being used as the base class for other classes to extend from. This means that a final method is a fixed implementation that cannot be changed by subclasses, while a final class is a fixed implementation that cannot be used as the base for other classes.





Q: What is the purpose of package in Java?


A: The purpose of a package in Java is to provide a way to organize classes and interfaces in a logical manner.

B: The purpose of a package in Java is to provide a way to manage memory usage.

C: The purpose of a package in Java is to provide a way to interact with the operating system.


Correct Response: 1

Explanation: The purpose of a package in Java is to provide a way to organize classes and interfaces in a logical manner. Packages provide a way to group related classes and interfaces together and ensure that their names do not conflict with classes and interfaces in other packages.





Q: What is java.lang package?


A: The java.lang package is a package in Java that contains classes and interfaces that are essential to the Java programming language.

B: The java.lang package is a package in Java that contains classes and interfaces that are not essential to the Java programming language.

C: The java.lang package is a package in Java that contains classes and interfaces for managing memory usage.


Correct Response: 1

Explanation: The java.lang package is a package in Java that contains classes and interfaces that are essential to the Java programming language. This package includes classes for basic data types, such as String and Integer, as well as classes for fundamental operations, such as System and Math.





Q: Which is the most important class in Java?


A: The most important class in Java is the Object class.

B: The most important class in Java is the String class.

C: The most important class in Java is the System class.


Correct Response: 1

Explanation: The most important class in Java is the Object class. The Object class is the root of the class hierarchy in Java and provides basic methods for all objects, such as equals and toString.





Q: Is it mandatory to import java.lang package every time?


A: No, it is not mandatory to import java.lang package every time as it is automatically imported by the compiler.

B: Yes, it is mandatory to import java.lang package every time.

C: It depends on the compiler.


Correct Response: 1

Explanation: No, it is not mandatory to import java.lang package every time as it is automatically imported by the compiler. This means that classes and interfaces in the java.lang package can be used without explicitly importing them.





Q: Can you import same package or class twice in your class?


A: No, you cannot import the same package or class twice in your class.

B: Yes, you can import the same package or class twice in your class.

C: It depends


Correct Response: 1

Explanation: No, you cannot import the same package or class twice in your class. Importing the same package or class multiple times in a single class will result in a compile-time error.





Q: What is a static import in Java?


A: A static import in Java is a way to import the members of a class, including fields and methods, as if they were part of the class that uses them.

B: A static import in Java is a way to import the members of a class, excluding fields and methods, as if they were part of the class that uses them.

C: A static import in Java is a way to import the members of a class, including fields and methods, as if they were part of the class that does not use them.


Correct Response: 1

Explanation: A static import in Java is a way to import the members of a class, including fields and methods, as if they were part of the class that uses them. This allows you to use the members of the imported class without having to qualify them with the class name.





Q: What is the difference between import static com.test.Fooclass and import com.test.Fooclass?


A: The difference between import static com.test.Fooclass and import com.test.Fooclass is that the first imports only the static members of the Fooclass, while the second imports the entire class, including both static and non-static members.

B: The difference between import static com.test.Fooclass and import com.test.Fooclass is that the first imports the entire Fooclass, while the second imports only the static members of the Fooclass.

C: There is no difference between import static com.test.Fooclass and import com.test.Fooclass.


Correct Response: 1

Explanation: The difference between import static com.test.Fooclass and import com.test.Fooclass is that the first imports only the static members of the Fooclass, while the second imports the entire class, including both static and non-static members.





Q: Can you access the classes and interfaces of a package directly without importing them?


A: No, you cannot access the classes and interfaces of a package directly without importing them.

B: Yes, you can access the classes and interfaces of a package directly without importing them.

C: It depends


Correct Response: 1

Explanation: No, you cannot access the classes and interfaces of a package directly without importing them. To use a class or interface from a package in your code, you must import it using the import statement.





Q: Can a class belong to multiple packages in Java?


A: No, a class cannot belong to multiple packages in Java.

B: Yes, a class can belong to multiple packages in Java.

C: It depends


Correct Response: 1

Explanation: No, a class cannot belong to multiple packages in Java. A class can only belong to one package, and it must be specified in the package statement at the beginning of the class.





Q: What is the syntax to import a package in Java?


A: The syntax to import a package in Java is import packageName;

B: The syntax to import a package in Java is include packageName;

C: The syntax to import a package in Java is using packageName;


Correct Response: 1

Explanation: The syntax to import a package in Java is import packageName;. For example, to import the java.util package, you would write import java.util; at the beginning of your code.





Q: Can you use a package name with a dot (.) in it?


A: No, you cannot use a package name with a dot (.) in it.

B: Yes, you can use a package name with a dot (.) in it.

C: It depends


Correct Response: 2

Explanation: Yes, you can use a package name with a dot (.) in it. Package names are often used to represent a hierarchical structure, and dots are used to separate the levels of the hierarchy.





Q: Can you import a package inside another package in Java?


A: Yes, you can import a package inside another package in Java.

B: No, you cannot import a package inside another package in Java.

C: It depends


Correct Response: 1

Explanation: Yes, you can import a package inside another package in Java. Importing a package inside another package allows you to use classes and interfaces from the imported package within the current package.





Q: What is the relationship between classpath and package in Java?


A: The relationship between classpath and package in Java is that the classpath is used to determine the location of class files, while the package is used to organize related classes and interfaces into a logical structure.

B: The relationship between classpath and package in Java is that the classpath is used to determine the location of package files, while the package is used to organize related classes and interfaces into a logical structure.

C: There is no relationship between classpath and package in Java.


Correct Response: 1

Explanation: The relationship between classpath and package in Java is that the classpath is used to determine the location of class files, while the package is used to organize related classes and interfaces into a logical structure. The classpath is a list of directories that the Java runtime environment searches for class files, while the package is a way to group related classes and interfaces together and ensure that their names do not conflict with classes and interfaces in other packages.





Q: How do you access a class or interface within a package in Java?


A: To access a class or interface within a package in Java, you must use the fully-qualified name of the class or interface, including the package name.

B: To access a class or interface within a package in Java, you must use the name of the class or interface without the package name.

C: To access a class or interface within a package in Java, you must use the name of the class or interface without the package name and import the package.


Correct Response: 1

Explanation: To access a class or interface within a package in Java, you must use the fully-qualified name of the class or interface, including the package name. For example, to access the java.util.ArrayList class, you would write java.util.ArrayList in your code.





Q: Can you define a class with the same name as a class in a different package in Java?


A: Yes, you can define a class with the same name as a class in a different package in Java.

B: No, you cannot define a class with the same name as a class in a different package in Java.

C: It depends


Correct Response: 1

Explanation: Yes, you can define a class with the same name as a class in a different package in Java. However, to avoid naming conflicts, it is recommended to use unique names for classes and to use packages to organize related classes into a logical structure.





Q: What happens if two packages contain classes with the same name in Java?


A: If two packages contain classes with the same name in Java, a compile-time error occurs.

B: If two packages contain classes with the same name in Java, the class from the first package is used.

C: If two packages contain classes with the same name in Java, the class from the second package is used.


Correct Response: 1

Explanation: If two packages contain classes with the same name in Java, a compile-time error occurs. To avoid naming conflicts, it is recommended to use unique names for classes and to use packages to organize related classes into a logical structure.





Q: Can you import a sub-package in Java?


A: Yes, you can import a sub-package in Java.

B: No, you cannot import a sub-package in Java.

C: It depends


Correct Response: 1

Explanation: Yes, you can import a sub-package in Java. To import a sub-package, you use the import statement with the fully-qualified name of the sub-package, including the parent package and all intermediate sub-packages.





Q: What is the difference between a sub-package and a regular package in Java?


A: The difference between a sub-package and a regular package in Java is that a sub-package is a package that is contained within another package, while a regular package is a package that is not contained within another package.

B: The difference between a sub-package and a regular package in Java is that a sub-package is a package that contains another package, while a regular package is a package that does not contain another package.

C: There is no difference between a sub-package and a regular package in Java.


Correct Response: 1

Explanation: The difference between a sub-package and a regular package in Java is that a sub-package is a package that is contained within another package, while a regular package is a package that is not contained within another package. Sub-packages provide a way to organize related packages into a hierarchical structure, while regular packages provide a way to organize related classes and interfaces into a logical structure.





Q: How do you access a class within a sub-package in Java?


A: To access a class within a sub-package in Java, you must use the fully-qualified name of the class, including the package and all sub-package names.

B: To access a class within a sub-package in Java, you must use the name of the class without the package or sub-package names.

C: To access a class within a sub-package in Java, you must use the name of the class without the sub-package name and import the package.


Correct Response: 1

Explanation: To access a class within a sub-package in Java, you must use the fully-qualified name of the class, including the package and all sub-package names. For example, to access the com.example.subpackage.MyClass class, you would write com.example.subpackage.MyClass in your code.





Q: Can you import a class from a package in a different project in Java?


A: Yes, you can import a class from a package in a different project in Java.

B: No, you cannot import a class from a package in a different project in Java.

C: It depends


Correct Response: 1

Explanation: Yes, you can import a class from a package in a different project in Java. To import a class from a different project, you must ensure that the class and the project containing the class are available on your classpath.





Q: What is the advantage of using packages in Java?


A: The advantage of using packages in Java is that they provide a way to organize related classes and interfaces into a logical structure, reduce naming conflicts, and ensure that the fully-qualified name of a class is unique.

B: The advantage of using packages in Java is that they provide a way to organize related classes and interfaces into a hierarchical structure, reduce naming conflicts, and ensure that the name of a class is unique.

C: The advantage of using packages in Java is that they provide a way to organize related classes and interfaces into a flat structure, reduce naming conflicts, and ensure that the name of a class is unique.


Correct Response: 1

Explanation: The advantage of using packages in Java is that they provide a way to organize related classes and interfaces into a logical structure, reduce naming conflicts, and ensure that the fully-qualified name of a class is unique. Packages also provide a way to encapsulate classes and interfaces and control access to them.





Q: Can you use wildcard imports in Java?


A: Yes, you can use wildcard imports in Java.

B: No, you cannot use wildcard imports in Java.

C: It depends


Correct Response: 1

Explanation: Yes, you can use wildcard imports in Java. Wildcard imports allow you to import all classes and interfaces from a package, using the syntax import packageName.*;. Wildcard imports can be convenient, but they can also increase the risk of naming conflicts and make it harder to determine where a class or interface is defined.





Q: What is Locale in Java?


A: A Locale in Java is a geographic or cultural region that is used to customize the behavior of the Java platform for a specific user or group of users.

B: A Locale in Java is a geographic or cultural region that is used to customize the behavior of the operating system for a specific user or group of users.

C: A Locale in Java is a geographic or cultural region that is used to customize the behavior of the application for a specific user or group of users.


Correct Response: 1

Explanation: A Locale in Java is a geographic or cultural region that is used to customize the behavior of the Java platform for a specific user or group of users. A Locale can be used to specify the language, region, character set, date format, and other settings for a user or group of users.





Q: How will you use a specific Locale in Java?


A: To use a specific Locale in Java, you can create a Locale object with the desired language and region, and then pass the Locale object to the appropriate methods that support localization.

B: To use a specific Locale in Java, you can set the default Locale for the Java runtime environment using the Locale.setDefault method.

C: To use a specific Locale in Java, you can set the default Locale for the operating system.


Correct Response: 1

Explanation: To use a specific Locale in Java, you can create a Locale object with the desired language and region, and then pass the Locale object to the appropriate methods that support localization. For example, you can use a Locale to format dates, times, numbers, and currency values in a way that is appropriate for a specific user or group of users.





Q: What is the purpose of Internationalization in Java?


A: The purpose of Internationalization in Java is to design and develop software applications that can be adapted to meet the language and cultural requirements of users in different countries and regions.

B: The purpose of Internationalization in Java is to design and develop software applications that can be adapted to meet the language and cultural requirements of users in a specific country or region.

C: The purpose of Internationalization in Java is to design and develop software applications that cannot be adapted to meet the language and cultural requirements of users in different countries and regions.


Correct Response: 1

Explanation: The purpose of Internationalization in Java is to design and develop software applications that can be adapted to meet the language and cultural requirements of users in different countries and regions. Internationalization is often abbreviated as "i18n" because there are 18 letters between the first and last letters of the word "Internationalization".





Q: What is the difference between Localization and Internationalization?


A: Localization is the process of making software adaptable to specific languages, regions, and cultural conventions, while Internationalization is the process of designing software that can be adapted to different languages and regions.

B: Localization is the process of making software adaptable to specific languages and regions, while Internationalization is the process of designing software that can be adapted to different cultural conventions.

C: Internationalization is the process of making software adaptable to specific languages, regions, and cultural conventions, while Localization is the process of designing software that can be adapted to different languages and regions.


Correct Response: 1

Explanation: Localization (L10n) is the process of making software adaptable to specific languages, regions, and cultural conventions, while Internationalization (I18n) is the process of designing software that can be adapted to different languages and regions.





Q: How do you switch between different Locales in Java?


A: By using the setLocale() method of the Locale class.

B: By using the switchLocale() method of the Locale class.

C: By using the changeLocale() method of the Locale class.


Correct Response: 1

Explanation: You can switch between different Locales in Java by using the setLocale() method of the Locale class. This method allows you to set the default Locale for your application.





Q: What is the significance of ResourceBundle class in Java Internationalization?


A: The ResourceBundle class is used to manage the localizable resources of an application.

B: The ResourceBundle class is used to manage the resources of an application.

C: The ResourceBundle class is used to manage the resources of an operating system.


Correct Response: 1

Explanation: The ResourceBundle class is used to manage the localizable resources of an application, such as strings, images, and other resources that need to be adapted to different Locales. It allows you to manage these resources in a flexible and efficient manner.





Q: How do you specify the default Locale in Java?


A: By using the setDefault() method of the Locale class.

B: By using the switchDefault() method of the Locale class.

C: By using the changeDefault() method of the Locale class.


Correct Response: 1

Explanation: You can specify the default Locale in Java by using the setDefault() method of the Locale class. This method allows you to set the default Locale for your application, which will be used if no Locale is specified.





Q: Can you provide an example of how to use a specific Locale in Java?


A: Locale locale = new Locale("fr", "FR");

B: Locale locale = new Locale("en", "US");

C: Locale locale = new Locale("es", "ES");


Correct Response: 1, 2, 3

Explanation: Any of the options 1, 2, or 3 can be used as an example of how to use a specific Locale in Java. The first argument is the language code, and the second argument is the country code. For example, the Locale new Locale("fr", "FR") represents French as used in France, new Locale("en", "US") represents English as used in the United States, and new Locale("es", "ES") represents Spanish as used in Spain.





Q: How does the Locale class determine the default locale for a Java application?


A: The Locale class determines the default locale by using the system properties.

B: The Locale class determines the default locale by using the user preferences.

C: The Locale class determines the default locale by using the operating system settings.


Correct Response: 1

Explanation: The Locale class determines the default locale for a Java application by using the system properties. The default Locale can be set using the user.language and user.country system properties, which specify the language and country codes, respectively. If these properties are not set, the Locale class will use the default Locale of the JVM.





Q: Can you explain how to use the NumberFormat and DateFormat classes for formatting numbers and dates for a specific Locale in Java?


A: NumberFormat numberFormat = NumberFormat.getInstance(locale); and DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale);

B: NumberFormat numberFormat = NumberFormat.getNumberInstance(locale); and DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, locale);

C: NumberFormat numberFormat = NumberFormat.getCurrencyInstance(locale); and DateFormat dateFormat = DateFormat.getTimeInstance(DateFormat.SHORT, locale);


Correct Response: 1, 2

Explanation: You can use the NumberFormat and DateFormat classes for formatting numbers and dates for a specific Locale in Java by using the getInstance() or getNumberInstance() methods for NumberFormat, and the getDateInstance(), getDateTimeInstance(), or getTimeInstance() methods for DateFormat, passing in the Locale as an argument. For example, NumberFormat numberFormat = NumberFormat.getInstance(locale) and DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale) can be used to format numbers and dates in a short format for the specified Locale.





Q: What are the benefits of Internationalization in Java?


A: Allows the same code to be used in different countries and regions.

B: Increases the market reach of the software.

C: Improves user experience by adapting to local customs and conventions.

D: Reduces the cost of maintenance and development.


Correct Response: 1, 2, 3

Explanation: Internationalization in Java provides several benefits, including allowing the same code to be used in different countries and regions, increasing the market reach of the software, and improving user experience by adapting to local customs and conventions. Additionally, it can reduce the cost of maintenance and development by making it easier to support multiple languages and regions.





Q: How does Java handle different character encodings for different Locales?


A: Java handles different character encodings for different Locales by using the Unicode character set.

B: Java handles different character encodings for different Locales by using the ASCII character set.

C: Java handles different character encodings for different Locales by using a different character set for each Locale.


Correct Response: 1

Explanation: Java handles different character encodings for different Locales by using the Unicode character set. Unicode is a standardized character encoding that supports a wide range of characters and scripts from different languages and regions. This makes it possible to display and handle text in different languages and scripts correctly in Java.





Q: Can you explain how to create a custom resource bundle for a specific Locale in Java?


A: By creating a properties file with the localizable resources and the Locale suffix in the file name, and loading the resources using the ResourceBundle class.

B: By creating a class with the localizable resources and the Locale suffix in the class name, and loading the resources using the ResourceBundle class.

C: By creating a database table with the localizable resources and the Locale suffix in the table name, and loading the resources using the ResourceBundle class.


Correct Response: 1, 2

Explanation: You can create a custom resource bundle for a specific Locale in Java by creating a properties file or a class with the localizable resources and the Locale suffix in the file or class name. For example, if you want to create a resource bundle for French as used in France, you could create a properties file named MessageBundle_fr_FR.properties or a class named MessageBundle_fr_FR. You can then load the resources using the ResourceBundle class.





Q: What are the limitations of the ResourceBundle class in Java?


A: Does not support multiple bundles for the same Locale.

B: Does not support complex data types such as images and audio.

C: Does not support hierarchical relationships between resources.

D: Does not support dynamic reloading of resources.


Correct Response: 1, 2, 3

Explanation: The ResourceBundle class in Java has several limitations, including not supporting multiple bundles for the same Locale, not supporting complex data types such as images and audio, and not supporting hierarchical relationships between resources. Additionally, it does not support dynamic reloading of resources, meaning that changes to the resources will not be reflected until the application is restarted.





Q: How does the ResourceBundle class work with the Properties file in Java?


A: The ResourceBundle class loads the properties from the Properties file, and provides access to the localizable resources as key-value pairs.

B: The ResourceBundle class creates the Properties file, and provides access to the localizable resources as key-value pairs.

C: The ResourceBundle class stores the localizable resources as key-value pairs, and provides access to the properties in the Properties file.


Correct Response: 1

Explanation: The ResourceBundle class in Java works with the Properties file by loading the properties from the Properties file, and providing access to the localizable resources as key-value pairs. The Properties file contains the localizable resources as key-value pairs, and the ResourceBundle class provides methods for accessing these resources based on a specified Locale.





Q: Can you provide an example of how to use the ResourceBundle class in Java to load messages for different Locales?


A: ResourceBundle bundle = ResourceBundle.getBundle("Messages", locale);

B: ResourceBundle bundle = ResourceBundle.loadBundle("Messages", locale);

C: ResourceBundle bundle = ResourceBundle.createBundle("Messages", locale);


Correct Response: 1

Explanation: You can use the ResourceBundle class in Java to load messages for different Locales by using the getBundle() method. For example, ResourceBundle bundle = ResourceBundle.getBundle("Messages", locale) can be used to load the messages for the specified Locale. The first argument to the method is the base name of the bundle, which is used to locate the properties file or class containing the localizable resources, and the second argument is the Locale for which to load the resources.





Q: How does the Locale class interact with the TimeZone class in Java?


A: The Locale class does not interact with the TimeZone class in Java.

B: The Locale class provides information about the cultural conventions and formatting rules for a specific region, while the TimeZone class provides information about the time zone for a specific region.

C: The Locale class provides information about the time zone for a specific region, while the TimeZone class provides information about the cultural conventions and formatting rules for a specific region.


Correct Response: 2

Explanation: The Locale class in Java provides information about the cultural conventions and formatting rules for a specific region, such as the date and time format, currency format, and number format. The TimeZone class in Java provides information about the time zone for a specific region, such as the offset from UTC and the support for daylight saving time. The two classes can be used together to format dates and times in a way that is appropriate for a specific Locale and time zone.





Q: What is the role of the MessageFormat class in Java Internationalization?


A: The MessageFormat class provides a way to format messages with placeholders for dynamic data, such as numbers and dates.

B: The MessageFormat class provides a way to format messages without placeholders for dynamic data.

C: The MessageFormat class provides a way to format messages with placeholders for static data, such as strings and images.


Correct Response: 1

Explanation: The MessageFormat class in Java provides a way to format messages with placeholders for dynamic data, such as numbers and dates. It allows you to create messages with placeholders, such as "There are {0} apples.", and then format the message with actual data, such as "There are 5 apples.". The MessageFormat class provides a flexible and efficient way to format messages in a way that is appropriate for a specific Locale.





Q: How does the DecimalFormat class work in Java Internationalization?


A: The DecimalFormat class provides a way to format numbers, such as currency and percentages, in a way that is appropriate for a specific Locale.

B: The DecimalFormat class provides a way to parse numbers, such as currency and percentages, in a way that is appropriate for a specific Locale.

C: The DecimalFormat class provides a way to format and parse numbers, such as currency and percentages, in a way that is appropriate for a specific Locale.


Correct Response: 3

Explanation: The DecimalFormat class in Java provides a way to format and parse numbers, such as currency and percentages, in a way that is appropriate for a specific Locale. It allows you to format numbers with appropriate grouping separators, decimal separators, and currency symbols, and to parse numbers that are formatted in a way that is appropriate for a specific Locale.





Q: What is the serialization?


A: Serialization is the process of converting an object's state to a stream of bytes.

B: Serialization is the process of converting a stream of bytes to an object's state.

C: Serialization is the process of converting an object's state to a stream of data.


Correct Response: 1

Explanation: Serialization is the process of converting an object's state to a stream of bytes. This allows the object to be stored or transmitted over a network, and then restored to its original state later using deserialization.





Q: What is the purpose of serialization?


A: The purpose of serialization is to store or transmit an object's state over a network.

B: The purpose of serialization is to store an object's state in a database.

C: The purpose of serialization is to store an object's state in a file system.


Correct Response: 1, 3

Explanation: The purpose of serialization is to store or transmit an object's state over a network or in a file system. Serialization allows you to save an object's state to a file or transmit it over a network, and then restore it to its original state later using deserialization.





Q: What is Deserialization?


A: Deserialization is the process of converting a stream of bytes to an object's state.

B: Deserialization is the process of converting an object's state to a stream of bytes.

C: Deserialization is the process of converting a stream of data to an object's state.


Correct Response: 1

Explanation: Deserialization is the process of converting a stream of bytes to an object's state. This allows you to restore an object that was previously serialized to its original state.





Q: What is Serialization and Deserialization conceptually?


A: Serialization and Deserialization are the processes of converting an object's state to and from a stream of bytes, respectively.

B: Serialization and Deserialization are the processes of converting an object's state to and from a stream of data, respectively.

C: Serialization and Deserialization are the processes of converting a stream of bytes to and from an object's state, respectively.


Correct Response: 1

Explanation: Serialization and Deserialization are the processes of converting an object's state to and from a stream of bytes, respectively. Serialization converts an object's state to a stream of bytes, and deserialization converts a stream of bytes to an object's state.





Q: Why do we mark a data member transient?


A: We mark a data member transient to indicate that its value should not be serialized.

B: We mark a data member transient to indicate that its value should be serialized.

C: We mark a data member transient to indicate that its value should be encrypted during serialization.


Correct Response: 1

Explanation: We mark a data member transient to indicate that its value should not be serialized. This means that the value of the data member will not be included in the stream of bytes generated during serialization, and will not be restored during deserialization. This can be useful if the data member is not relevant or if it can be recreated dynamically.





Q: Is it allowed to mark a method as transient?


A: No, it is not allowed to mark a method as transient in Java.

B: Yes, it is allowed to mark a method as transient in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: No, it is not allowed to mark a method as transient in Java. Transient is a keyword that is used to indicate that a field should not be serialized, and it can only be used with fields.





Q: How does marking a field as transient make it possible to serialize an object?


A: Marking a field as transient makes it possible to serialize an object by indicating that the value of the field should not be included in the stream of bytes generated during serialization.

B: Marking a field as transient makes it possible to serialize an object by indicating that the value of the field should be included in the stream of bytes generated during serialization.

C: Marking a field as transient does not make it possible to serialize an object.


Correct Response: 1

Explanation: Marking a field as transient makes it possible to serialize an object by indicating that the value of the field should not be included in the stream of bytes generated during serialization. This allows you to exclude fields that are not relevant or that can be recreated dynamically, while still serializing the rest of the object.





Q: What is Externalizable interface in Java?


A: The Externalizable interface in Java is a subinterface of the Serializable interface, and provides a way to customize the serialization and deserialization process.

B: The Externalizable interface in Java is a superinterface of the Serializable interface, and provides a way to customize the serialization and deserialization process.

C: The Externalizable interface in Java is a standalone interface, and provides a way to customize the serialization and deserialization process.


Correct Response: 1

Explanation: The Externalizable interface in Java is a subinterface of the Serializable interface, and provides a way to customize the serialization and deserialization process. It provides two methods, writeExternal() and readExternal(), that allow you to write and read the object's state to and from a stream of bytes, respectively.





Q: Can objects of all classes be serialized in Java?


A: No, not all objects of all classes can be serialized in Java.

B: Yes, all objects of all classes can be serialized in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: No, not all objects of all classes can be serialized in Java. In order to be serialized, an object must implement the Serializable interface. The Serializable interface is a marker interface that does not have any methods, but it indicates that an object can be serialized.





Q: What happens to the object's state when it is serialized?


A: When an object is serialized, its state is converted to a stream of bytes.

B: When an object is serialized, its state is destroyed.

C: When an object is serialized, its state is stored in a database.


Correct Response: 1

Explanation: When an object is serialized, its state is converted to a stream of bytes. This stream of bytes can then be stored in a file or transmitted over a network, and later restored to its original state using deserialization.





Q: What is the role of the serialVersionUID in serialization?


A: The role of the serialVersionUID in serialization is to ensure compatibility between different versions of a class.

B: The role of the serialVersionUID in serialization is to ensure compatibility between different versions of a serialized object.

C: The role of the serialVersionUID in serialization is to ensure compatibility between different versions of the Java virtual machine.


Correct Response: 1

Explanation: The role of the serialVersionUID in serialization is to ensure compatibility between different versions of a class. The serialVersionUID is a unique identifier that is associated with a class, and it is used by the Java serialization mechanism to ensure that the class and its serialized data are compatible. If the class is modified in a way that is not compatible with its serialized data, the serialVersionUID can be used to detect this and prevent deserialization errors.





Q: Can the state of an object be restored to its previous state after deserialization?


A: Yes, the state of an object can be restored to its previous state after deserialization.

B: No, the state of an object cannot be restored to its previous state after deserialization.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, the state of an object can be restored to its previous state after deserialization. Deserialization is the process of converting a stream of bytes to an object's state, and it allows you to restore an object that was previously serialized to its original state.





Q: How does serialization affect the private fields of an object?


A: Serialization affects the private fields of an object by including their values in the stream of bytes generated during serialization.

B: Serialization affects the private fields of an object by excluding their values from the stream of bytes generated during serialization.

C: Serialization does not affect the private fields of an object.


Correct Response: 1

Explanation: Serialization affects the private fields of an object by including their values in the stream of bytes generated during serialization. The private fields of an object are part of its state, and their values are included in the stream of bytes generated during serialization. This allows the object to be restored to its original state later using deserialization.





Q: Can an object's final fields be serialized?


A: Yes, an object's final fields can be serialized.

B: No, an object's final fields cannot be serialized.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, an object's final fields can be serialized. The final keyword in Java is used to indicate that a field cannot be modified after it is initialized, but it does not prevent the field from being serialized. The values of final fields are included in the stream of bytes generated during serialization, and are restored during deserialization.





Q: What happens to the static fields of an object during serialization?


A: The static fields of an object are not included in the stream of bytes generated during serialization.

B: The static fields of an object are included in the stream of bytes generated during serialization.

C: The static fields of an object are destroyed during serialization.


Correct Response: 1

Explanation: The static fields of an object are not included in the stream of bytes generated during serialization. The static fields of a class are shared by all instances of the class, and they do not form part of the state of an individual object. As a result, they are not included in the stream of bytes generated during serialization.





Q: What is object graph in the context of serialization?


A: An object graph in the context of serialization is a directed acyclic graph of objects that are reachable from a root object.

B: An object graph in the context of serialization is a tree of objects that are reachable from a root object.

C: An object graph in the context of serialization is a cycle of objects that are reachable from a root object.


Correct Response: 1

Explanation: An object graph in the context of serialization is a directed acyclic graph of objects that are reachable from a root object. The root object is the object that is being serialized, and the objects in the graph are the objects that are referenced by the root object or by other objects in the graph. During serialization, the entire object graph is serialized to a stream of bytes.





Q: Can you serialize an object that refers to another object?


A: Yes, you can serialize an object that refers to another object.

B: No, you cannot serialize an object that refers to another object.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, you can serialize an object that refers to another object. When you serialize an object that refers to another object, the referenced object is also serialized. This allows you to preserve the relationships between objects in the object graph, and to restore the entire object graph to its original state during deserialization.





Q: What is Reflection in Java?


A: Reflection in Java is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime.

B: Reflection in Java is a feature of the Java programming language that allows you to inspect, modify, and destroy objects at runtime.

C: Reflection in Java is a feature of the Java programming language that allows you to inspect, create, and destroy objects at runtime.


Correct Response: 1

Explanation: Reflection in Java is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime. Reflection provides a way to examine and manipulate the properties and behavior of an object, and it is used to perform tasks that are not possible with regular Java code, such as accessing private fields and methods, creating objects dynamically, and so on.





Q: What are the uses of Reflection in Java?


A: Accessing private fields and methods

B: Creating objects dynamically

C: Checking if a class is an instance of a particular class or interface

D: All of the above


Correct Response: 4

Explanation: All of the above. Reflection can be used for a wide range of purposes, including accessing private fields and methods, creating objects dynamically, checking if a class is an instance of a particular class or interface, and so on. It provides a powerful way to interact with objects and classes at runtime, and is used in many different contexts, from unit testing to dynamic class loading and more.





Q: How can we access private method of a class from outside the class?


A: We can access private methods of a class from outside the class by using the Reflection API in Java.

B: We cannot access private methods of a class from outside the class.

C: It depends on the implementation.


Correct Response: 1

Explanation: We can access private methods of a class from outside the class by using the Reflection API in Java. The Reflection API provides a way to access and manipulate the properties and behavior of an object, including its private fields and methods. With Reflection, you can call private methods and access private fields, even if they are not accessible from outside the class.





Q: How can we create an Object dynamically at Runtime in Java?


A: We can create an object dynamically at runtime in Java by using the Reflection API.

B: We cannot create an object dynamically at runtime in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: We can create an object dynamically at runtime in Java by using the Reflection API. The Reflection API provides a way to create objects dynamically at runtime by using the Class.forName() method and the newInstance() method. With these methods, you can create objects of a class that is not known until runtime, and you can create instances of classes that are not available at compile time.





Q: Can we change the value of a final field using reflection in Java?


A: No, we cannot change the value of a final field using reflection in Java.

B: Yes, we can change the value of a final field using reflection in Java.

C: It depends on the implementation.


Correct Response: 2

Explanation: Yes, we can change the value of a final field using reflection in Java. Reflection provides a way to access and manipulate the properties and behavior of an object, including its final fields. With Reflection, you can change the value of a final field by using the Field.set() method. However, it is generally considered to be a bad practice, as final fields are meant to be constant and unchanging.





Q: What is the difference between Class.forName() and ClassLoader.loadClass() in Java reflection?


A: The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() loads a class using the system class loader, while ClassLoader.loadClass() loads a class using a specified class loader.

B: The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() loads a class using a specified class loader, while ClassLoader.loadClass() loads a class using the system class loader.

C: The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() only loads a class if it has not already been loaded, while ClassLoader.loadClass() always loads a class, even if it has already been loaded.


Correct Response: 2

Explanation: The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() loads a class using the system class loader, while ClassLoader.loadClass() loads a class using a specified class loader. Class.forName() is a convenient method that automatically uses the system class loader to load a class, while ClassLoader.loadClass() allows you to specify a different class loader to use.





Q: How can we obtain the class object of an array in Java?


A: We can obtain the class object of an array in Java by using the getClass() method on an array instance.

B: We cannot obtain the class object of an array in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: We can obtain the class object of an array in Java by using the getClass() method on an array instance. The getClass() method returns the Class object that represents the type of an object, including arrays. For example, you can create an array of integers, and use the getClass() method to obtain the class object of the array. This class object can then be used with the Reflection API to inspect and manipulate the properties and behavior of the array.





Q: What is the purpose of the java.lang.reflect package?


A: The purpose of the java.lang.reflect package in Java is to provide classes and interfaces for the Java Reflection API.

B: The purpose of the java.lang.reflect package in Java is to provide classes and interfaces for the Java Collection API.

C: The purpose of the java.lang.reflect package in Java is to provide classes and interfaces for the Java I/O API.


Correct Response: 1

Explanation: The purpose of the java.lang.reflect package in Java is to provide classes and interfaces for the Java Reflection API. The Reflection API allows you to inspect, modify, and create objects and classes at runtime, and the java.lang.reflect package provides the core classes and interfaces that are used to perform these tasks.





Q: Can we invoke a method with parameters using reflection in Java?


A: Yes, we can invoke a method with parameters using reflection in Java.

B: No, we cannot invoke a method with parameters using reflection in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, we can invoke a method with parameters using reflection in Java. The Reflection API provides the Method class, which allows you to invoke a method on an object, including methods with parameters. You can use the Method.invoke() method to invoke a method on an object, passing in the object instance and an array of parameters.





Q: What is the use of the java.lang.reflect.Proxy class in Java?


A: The use of the java.lang.reflect.Proxy class in Java is to create dynamic proxies, which are objects that can be used to intercept method invocations on other objects.

B: The use of the java.lang.reflect.Proxy class in Java is to create static proxies, which are objects that cannot be used to intercept method invocations on other objects.

C: The use of the java.lang.reflect.Proxy class in Java is to create simple proxies, which are objects that have a simple implementation of the methods of another object.


Correct Response: 1

Explanation: The use of the java.lang.reflect.Proxy class in Java is to create dynamic proxies, which are objects that can be used to intercept method invocations on other objects. Dynamic proxies are useful for tasks such as dynamic method dispatch, dynamic class loading, and so on. The java.lang.reflect.Proxy class provides methods for creating dynamic proxies, and for registering invocation handlers objects that handle method invocations on the proxies.





Q: How can we determine if a given class is an inner class or not using reflection in Java?


A: We can determine if a given class is an inner class or not using reflection in Java by checking if the class name contains a "$" symbol.

B: We cannot determine if a given class is an inner class or not using reflection in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: We can determine if a given class is an inner class or not using reflection in Java by checking if the class name contains a "$" symbol. Inner classes in Java have names that contain a "$" symbol, followed by a number that indicates the order in which the inner class was declared. For example, if you have a class named Outer and an inner class named Outer$Inner, you can use reflection to determine that Outer$Inner is an inner class by checking if its name contains a "$" symbol.





Q: What is the difference between reflection and introspection in Java?


A: The difference between reflection and introspection in Java is that reflection is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime, while introspection is a feature of the Java programming language that allows you to inspect the state and behavior of objects at runtime.

B: The difference between reflection and introspection in Java is that reflection is a feature of the Java programming language that allows you to inspect, modify, and create objects at compile time, while introspection is a feature of the Java programming language that allows you to inspect the state and behavior of objects at runtime.

C: The difference between reflection and introspection in Java is that reflection is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime, while introspection is a feature of the Java programming language that allows you to inspect the state and behavior of objects at compile time.


Correct Response: 1

Explanation: The difference between reflection and introspection in Java is that reflection is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime, while introspection is a feature of the Java programming language that allows you to inspect the state and behavior of objects at runtime. Reflection provides a way to interact with objects and classes at runtime, while introspection provides a way to inspect the state and behavior of objects without modifying or changing them.





Q: Can you define a class with the same name as a class in a different package in Java?


A: Yes, you can define a class with the same name as a class in a different package in Java, as long as the classes are in different packages.

B: No, you cannot define a class with the same name as a class in a different package in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, you can define a class with the same name as a class in a different package in Java, as long as the classes are in different packages. Classes in different packages have different fully-qualified names, which include the package name, so you can have classes with the same name as long as they are in different packages. For example, you can have a class named ExampleClass in the com.example.package1 package, and another class named ExampleClass in the com.example.package2 package.





Q: What happens if two packages contain classes with the same name in Java?


A: If two packages contain classes with the same name in Java, you will need to use the fully-qualified name of the class, including the package name, to distinguish between the two classes.

B: If two packages contain classes with the same name in Java, the classes will overwrite each other and only one of the classes will be accessible.

C: If two packages contain classes with the same name in Java, the classes will not be accessible.


Correct Response: 1

Explanation: If two packages contain classes with the same name in Java, you will need to use the fully-qualified name of the class, including the package name, to distinguish between the two classes. Classes in different packages have different fully-qualified names, which include the package name, so you can have classes with the same name as long as they are in different packages. For example, you can have a class named ExampleClass in the com.example.package1 package, and another class named ExampleClass in the com.example.package2 package, and you can distinguish between the two classes by using their fully-qualified names.





Q: Can you import a sub-package in Java?


A: Yes, you can import a sub-package in Java by using the import statement and specifying the fully-qualified name of the sub-package.

B: No, you cannot import a sub-package in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, you can import a sub-package in Java by using the import statement and specifying the fully-qualified name of the sub-package. For example, if you have a sub-package named com.example.subpackage within the com.example package, you can import the com.example.subpackage sub-package by using the following import statement: import com.example.subpackage.*;.





Q: What is the difference between a sub-package and a regular package in Java?


A: The difference between a sub-package and a regular package in Java is that a sub-package is a package that is contained within another package, while a regular package is a standalone package that is not contained within another package.

B: There is no difference between a sub-package and a regular package in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: The difference between a sub-package and a regular package in Java is that a sub-package is a package that is contained within another package, while a regular package is a standalone package that is not contained within another package. For example, if you have a package named com.example and a sub-package named com.example.subpackage, the com.example.subpackage sub-package is contained within the com.example package.





Q: How do you access a class within a sub-package in Java?


A: You can access a class within a sub-package in Java by using the fully-qualified name of the class, including the sub-package name.

B: You cannot access a class within a sub-package in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: You can access a class within a sub-package in Java by using the fully-qualified name of the class, including the sub-package name. For example, if you have a sub-package named com.example.subpackage and a class named ExampleClass within that sub-package, you can access the ExampleClass class by using its fully-qualified name com.example.subpackage.ExampleClass.





Q: Can you import a class from a package in a different project in Java?


A: Yes, you can import a class from a package in a different project in Java by adding the required project to the classpath and using the import statement to import the class.

B: No, you cannot import a class from a package in a different project in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, you can import a class from a package in a different project in Java by adding the required project to the classpath and using the import statement to import the class. To import a class from a package in a different project, you will need to add the required project to the classpath of your current project, either by including it in your build system or by specifying it on the command line when you run your application. Once the required project is on the classpath, you can use the import statement to import the class as you would for a class in the same project.





Q: What is the advantage of using packages in Java?


A: One of the advantages of using packages in Java is that they provide a way to organize your code into related groups and prevent naming collisions between classes.

B: Packages have no advantage in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: One of the advantages of using packages in Java is that they provide a way to organize your code into related groups and prevent naming collisions between classes. By organizing your code into packages, you can keep your code organized and easy to understand, and you can prevent naming collisions between classes by using different package names for different groups of classes. This makes it easier to maintain and develop your code over time.





Q: Can you use wildcard imports in Java?


A: Yes, you can use wildcard imports in Java by using the import statement with a wildcard character (*) to import all classes from a package.

B: No, you cannot use wildcard imports in Java.

C: It depends on the implementation.


Correct Response: 1

Explanation: Yes, you can use wildcard imports in Java by using the import statement with a wildcard character (*) to import all classes from a package. For example, if you have a package named com.example, you can use the following import statement to import all classes from the com.example package: import com.example.*;. Wildcard imports can be convenient in some situations, but they can also make your code harder to understand and maintain, as it may not be clear which classes are being imported from which packages. It is generally recommended to use specific imports rather than wildcard imports where possible.





Q: What is Garbage Collection in Java?


A: Garbage Collection in Java is a process that automatically frees up memory that is no longer being used by the application.

B: Garbage Collection in Java is a process that manually frees up memory that is no longer being used by the application.

C: Garbage Collection in Java is a process that frees up memory that is not being used by the application.


Correct Response: 1

Explanation: Garbage Collection in Java is a process that automatically frees up memory that is no longer being used by the application. The Java Virtual Machine (JVM) performs garbage collection to reclaim memory that is no longer being used by the application, and to prevent the application from running out of memory.





Q: Why Java provides Garbage Collector?


A: Java provides a Garbage Collector to automatically free up memory that is no longer being used by the application, in order to prevent the application from running out of memory.

B: Java provides a Garbage Collector to manually free up memory that is no longer being used by the application.

C: Java provides a Garbage Collector to free up memory that is not being used by the application.


Correct Response: 1

Explanation: Java provides a Garbage Collector to automatically free up memory that is no longer being used by the application, in order to prevent the application from running out of memory. By automatically freeing up memory that is no longer being used, the Garbage Collector helps to ensure that the application has enough memory to continue running, and helps to prevent memory leaks and other memory-related problems.





Q: What is the purpose of gc() in Java?


A: The purpose of the gc() method in Java is to explicitly request that the Garbage Collector run and reclaim memory that is no longer being used by the application.

B: The purpose of the gc() method in Java is to explicitly request that the Garbage Collector manually reclaim memory that is no longer being used by the application.

C: The purpose of the gc() method in Java is to explicitly request that the Garbage Collector free up memory that is not being used by the application.


Correct Response: 1

Explanation: The purpose of the gc() method in Java is to explicitly request that the Garbage Collector run and reclaim memory that is no longer being used by the application. The gc() method can be used to explicitly request that the Garbage Collector run, although it is not guaranteed that the Garbage Collector will actually run in response to a call to gc(). The Garbage Collector runs automatically, so you do not typically need to call gc() in your code.





Q: How does Garbage Collection work in Java?


A: Garbage Collection in Java works by periodically examining the memory used by the application, identifying objects that are no longer being used, and freeing up the memory occupied by those objects.

B: Garbage Collection in Java works by manually examining the memory used by the application, identifying objects that are no longer being used, and freeing up the memory occupied by those objects.

C: Garbage Collection in Java works by freeing up memory that is not being used by the application.


Correct Response: 1

Explanation: Garbage Collection in Java works by periodically examining the memory used by the application, identifying objects that are no longer being used, and freeing up the memory occupied by those objects. The Java Virtual Machine (JVM) performs garbage collection to reclaim memory that is no longer being used by the application, and to prevent the application from running out of memory. The JVM identifies objects that are no longer being used by the application by tracing the object references, and freeing up the memory occupied by those objects that are no longer reachable.





Q: When does an object become eligible for Garbage Collection in Java?


A: An object in Java becomes eligible for Garbage Collection when there are no more references to the object.

B: An object in Java becomes eligible for Garbage Collection when it is no longer in use by the application.

C: An object in Java becomes eligible for Garbage Collection when the application terminates.


Correct Response: 1

Explanation: An object in Java becomes eligible for Garbage Collection when there are no more references to the object. The JVM identifies objects that are no longer being used by the application by tracing the object references, and freeing up the memory occupied by those objects that are no longer reachable. When an object has no more references to it, it is considered to be unreachable, and is eligible for Garbage Collection.





Q: Why do we use finalize() method in Java?


A: The finalize() method in Java is used as a way to perform clean-up actions just before an object is garbage collected.

B: The finalize() method in Java is used as a way to prevent an object from being garbage collected.

C: The finalize() method in Java is used as a way to manually free up memory that is no longer being used by the application.


Correct Response: 1

Explanation: The finalize() method in Java is used as a way to perform clean-up actions just before an object is garbage collected. The finalize() method is called just before an object is garbage collected, and can be used to perform any necessary clean-up actions, such as releasing resources that are being held by the object. However, the use of the finalize() method is generally discouraged, as it is not guaranteed to be called by the JVM, and it can add overhead to the Garbage Collection process. It is generally better to use other methods, such as try-with-resources statements or explicit cleanup methods, to manage resources and perform clean-up actions in your code.





Q: What are the different types of References in Java?


A: The different types of References in Java are Strong References, Soft References, Weak References, and Phantom References.

B: The different types of References in Java are Strong References, Soft References, and Phantom References.

C: The different types of References in Java are Strong References, Soft References, and Weak References.

D: The different types of References in Java are Strong References and Soft References.


Correct Response: 1

Explanation: The different types of References in Java are Strong References, Soft References, Weak References, and Phantom References. Strong References are the normal references that are used in Java, and the objects that are referenced by strong references are not eligible for Garbage Collection. Soft References are references that are used to refer to objects that are still in use, but are not critical to the functioning of the application. Soft referenced objects are eligible for Garbage Collection when the JVM needs to reclaim memory. Weak References are references that are used to refer to objects that are weakly reachable, meaning that the objects are eligible for Garbage Collection as soon as there are no other strong or soft references to the objects. Phantom References are references that are used to track the lifecycle of an object, and are used in conjunction with the ReferenceQueue class.





Q: How can we reference an unreferenced object again?


A: You can reference an unreferenced object again by creating a new reference to the object.

B: You can reference an unreferenced object again by using the finalize() method.

C: You cannot reference an unreferenced object again.


Correct Response: 1

Explanation: You can reference an unreferenced object again by creating a new reference to the object. Once an object has been garbage collected, it cannot be referenced again. However, you can create a new object with the same state as the original object, and reference the new object.





Q: What kind of process is the Garbage collector thread?


A: The Garbage collector thread is a background process that runs in the Java Virtual Machine (JVM).

B: The Garbage collector thread is a foreground process that runs in the Java Virtual Machine (JVM).

C: The Garbage collector thread is a background process that runs outside of the Java Virtual Machine (JVM).


Correct Response: 1

Explanation: The Garbage collector thread is a background process that runs in the Java Virtual Machine (JVM). The Garbage collector thread is responsible for performing garbage collection, which involves freeing up memory that is no longer being used by the application. The Garbage collector thread runs in the background, and typically does not interrupt the normal functioning of the application.





Q: How can we invoke an external process in Java?


A: You can invoke an external process in Java using the Runtime.exec() method.

B: You can invoke an external process in Java using the System.exec() method.

C: You can invoke an external process in Java using the Process.exec() method.


Correct Response: 1

Explanation: You can invoke an external process in Java using the Runtime.exec() method. The Runtime.exec() method is part of the java.lang.Runtime class, and it can be used to start an external process and interact with it from within a Java program. The Runtime.exec() method takes a command line as an argument, and returns a Process object that can be used to manage the process and retrieve its output.





Q: What are the uses of the Runtime class?


A: The Runtime class in Java is used to interact with the runtime environment of the Java Virtual Machine (JVM).

B: The Runtime class in Java is used to interact with the operating system.

C: The Runtime class in Java is used to interact with the file system.


Correct Response: 1

Explanation: The Runtime class in Java is used to interact with the runtime environment of the Java Virtual Machine (JVM). The Runtime class provides methods that allow you to interact with the JVM, such as starting external processes, allocating memory, and interacting with the garbage collector. The Runtime class is a singleton class, and there is only one instance of the Runtime class in the JVM.





Q: What is the role of the JVM in Garbage Collection in Java?


A: The JVM is responsible for performing Garbage Collection in Java.

B: The JVM is not responsible for performing Garbage Collection in Java.

C: The JVM is responsible for allocating memory for objects in Java, but not for performing Garbage Collection.


Correct Response: 1

Explanation: The JVM is responsible for performing Garbage Collection in Java. The JVM performs Garbage Collection to reclaim memory that is no longer being used by the application, and to prevent the application from running out of memory. The JVM identifies objects that are no longer being used by the application by tracing the object references, and freeing up the memory occupied by those objects that are no longer reachable.





Q: Can we force Garbage Collection in Java? If yes, then how?


A: Yes, we can force Garbage Collection in Java by calling the System.gc() method or the Runtime.gc() method.

B: No, we cannot force Garbage Collection in Java.

C: Yes, we can force Garbage Collection in Java by calling the gc() method.


Correct Response: 1

Explanation: Yes, we can force Garbage Collection in Java by calling the System.gc() method or the Runtime.gc() method. Calling these methods makes a request to the JVM to perform Garbage Collection, but it is not guaranteed that the JVM will actually perform Garbage Collection. The System.gc() method and the Runtime.gc() method are equivalent, and either one can be used to request Garbage Collection.





Q: What are the advantages of using Garbage Collection in Java?


A: The advantages of using Garbage Collection in Java include automatic memory management, improved application performance, and reduced risk of memory leaks.

B: The advantages of using Garbage Collection in Java include automatic memory management and reduced risk of memory leaks.

C: The advantages of using Garbage Collection in Java include improved application performance and reduced risk of memory leaks.

D: The advantages of using Garbage Collection in Java include improved application performance.


Correct Response: 1

Explanation: The advantages of using Garbage Collection in Java include automatic memory management, improved application performance, and reduced risk of memory leaks. Garbage Collection frees up memory that is no longer being used by the application, which can help to improve application performance. Additionally, by automatically freeing up memory, Garbage Collection reduces the risk of memory leaks, which can cause the application to run out of memory and crash.





Q: What is the difference between the System.gc() method and the Runtime.gc() method?


A: There is no difference between the System.gc() method and the Runtime.gc() method. They are equivalent.

B: The System.gc() method is a static method that can be called without creating an instance of the System class, while the Runtime.gc() method is an instance method that requires an instance of the Runtime class.

C: The System.gc() method is faster than the Runtime.gc() method.


Correct Response: 1

Explanation: There is no difference between the System.gc() method and the Runtime.gc() method. They are equivalent. Both methods make a request to the JVM to perform Garbage Collection, but it is not guaranteed that the JVM will actually perform Garbage Collection. The System.gc() method is a static method that can be called without creating an instance of the System class, while the Runtime.gc() method is an instance method that requires an instance of the Runtime class to be created.





Q: What is the purpose of the Runtime class?


A: The purpose of the Runtime class in Java is to interact with the runtime environment of the JVM.

B: The purpose of the Runtime class in Java is to interact with the operating system.

C: The purpose of the Runtime class in Java is to interact with the file system.


Correct Response: 1

Explanation: The purpose of the Runtime class in Java is to interact with the runtime environment of the JVM. The Runtime class provides methods that allow you to interact with the JVM, such as starting external processes, allocating memory, and interacting with the garbage collector. The Runtime class is a singleton class, and there is only one instance of the Runtime class in the JVM.





Q: What is the relationship between the finalize() method and Garbage Collection in Java?


A: The finalize() method in Java is called by the JVM just before an object is garbage collected.

B: The finalize() method in Java is not related to Garbage Collection.

C: The finalize() method in Java is called by the JVM after an object has been garbage collected.


Correct Response: 1

Explanation: The finalize() method in Java is called by the JVM just before an object is garbage collected. The finalize() method is a protected method that is declared in the java.lang.Object class, and it can be overridden by subclasses to provide a hook for freeing up resources that are associated with an object just before it is garbage collected. However, the use of the finalize() method is discouraged because it is not guaranteed to be called, and because it can add significant overhead to the Garbage Collection process.





Q: What is the impact of Garbage Collection on the performance of a Java application?


A: The impact of Garbage Collection on the performance of a Java application can vary depending on the size of the heap, the rate of object allocation and deallocation, and the Garbage Collection algorithm used.

B: Garbage Collection has no impact on the performance of a Java application.

C: Garbage Collection always improves the performance of a Java application.

D: Garbage Collection always decreases the performance of a Java application.


Correct Response: 1

Explanation: The impact of Garbage Collection on the performance of a Java application can vary depending on the size of the heap, the rate of object allocation and deallocation, and the Garbage Collection algorithm used. In general, Garbage Collection can help to improve the performance of a Java application by freeing up memory that is no longer being used, and by preventing the application from running out of memory. However, Garbage Collection can also introduce pauses and slowdowns in the application if the heap is large and the Garbage Collection process takes a long time to complete.





Q: What are the different algorithms used for Garbage Collection in Java?


A: The different algorithms used for Garbage Collection in Java include the Mark-Sweep algorithm, the Mark-Compact algorithm, the Copy algorithm, and the Generational algorithm.

B: The different algorithms used for Garbage Collection in Java include the Mark-Sweep algorithm and the Mark-Compact algorithm.

C: The different algorithms used for Garbage Collection in Java include the Copy algorithm and the Generational algorithm.


Correct Response: 1

Explanation: The different algorithms used for Garbage Collection in Java include the Mark-Sweep algorithm, the Mark-Compact algorithm, the Copy algorithm, and the Generational algorithm. Each algorithm has its own strengths and weaknesses, and the JVM can choose the best algorithm to use based on the heap size, the rate of object allocation and deallocation, and other factors. The Generational algorithm is a type of algorithm that is designed to improve the performance of Garbage Collection by focusing on the youngest objects in the heap first.





Q: What are the different ways to handle OutOfMemoryError in Java?


A: The different ways to handle OutOfMemoryError in Java include increasing the size of the heap, reducing the number of objects being created, using a memory-efficient data structure, and implementing a custom memory manager.

B: The different ways to handle OutOfMemoryError in Java include increasing the size of the heap and reducing the number of objects being created.

C: The different ways to handle OutOfMemoryError in Java include using a memory-efficient data structure and implementing a custom memory manager.


Correct Response: 1

Explanation: The different ways to handle OutOfMemoryError in Java include increasing the size of the heap, reducing the number of objects being created, using a memory-efficient data structure, and implementing a custom memory manager. The most common way to handle OutOfMemoryError is to increase the size of the heap, either by increasing the maximum heap size, or by allocating more memory to the JVM. Another approach is to reduce the number of objects being created by the application, either by reusing objects, or by using a more memory-efficient data structure. In some cases, it may be necessary to implement a custom memory manager to manage the allocation and deallocation of memory in the application.





Q: What is a Nested class?


A: A class declared inside another class.

B: A class declared outside of all classes.

C: A class declared inside a method.


Correct Response: 1

Explanation: A Nested class is a class declared inside another class. It has access to all members (including private members) of the enclosing class and can be declared as static or non-static.





Q: How many types of Nested classes are in Java?


A: 2

B: 3

C: 4

D: 5


Correct Response: 2

Explanation: There are two types of Nested classes in Java: static nested class and inner class.





Q: Why do we use Nested Classes?


A: To improve code readability.

B: To provide more encapsulation.

C: To reduce namespace pollution.

D: All of the above.


Correct Response: 4

Explanation: Nested classes are used for all of the above reasons. They can improve code readability, provide more encapsulation, and reduce namespace pollution by organizing code into smaller, related units.





Q: What is the difference between a Nested class and an Inner class in Java?


A: There is no difference, both terms refer to the same thing.

B: A Nested class is static while an Inner class is non-static.

C: An Inner class has access to the enclosing class's instance variables while a Nested class does not.


Correct Response: 2

Explanation: The main difference between a Nested class and an Inner class is that a Nested class is static while an Inner class is non-static. An Inner class has access to the enclosing class's instance variables while a Nested class does not.





Q: What is a Nested interface?


A: An interface declared inside another interface.

B: An interface declared inside a class.

C: An interface declared outside of all classes and interfaces.


Correct Response: 1

Explanation: A Nested interface is an interface declared inside another interface. It is similar to a Nested class and can be declared as static or non-static.





Q: How can we access the non-final local variable, inside a Local Inner class?


A: By marking the local variable as final.

B: By using the this keyword.

C: By using an instance of the local inner class.


Correct Response: 1

Explanation: In order to access a non-final local variable inside a Local Inner class, the local variable must be marked as final. This is because local variables are stored on the stack, which is not accessible from within an inner class.





Q: Can an Interface be defined in a Class?


A: Yes, an interface can be defined in a class.

B: No, an interface cannot be defined in a class.

C: Only in Java 8 and later versions.


Correct Response: 1

Explanation: Yes, an interface can be defined inside a class, and is known as a Nested Interface.





Q: Do we have to explicitly mark a Nested Interface public static?


A: Yes, a Nested Interface must be marked as public static.

B: No, a Nested Interface does not have to be marked as public static.

C: Only in Java 8 and later versions.


Correct Response: 2

Explanation: No, a Nested Interface does not have to be marked as public static. By default, a Nested Interface is static and has the same access as the top-level interface.





Q: Why do we use Static Nested interface in Java?


A: To improve code readability.

B: To provide more encapsulation.

C: To reduce namespace pollution.

D: All of the above.


Correct Response: 4

Explanation: We use Static Nested Interfaces in Java for all of the above reasons. They can improve code readability, provide more encapsulation, and reduce namespace pollution by organizing code into smaller, related units.





Q: Can a Nested class be declared private in Java?


A: Yes, a Nested class can be declared private.

B: No, a Nested class cannot be declared private.

C: Only in Java 8 and later versions.


Correct Response: 1

Explanation: Yes, a Nested class can be declared private, and it can only be accessed within the enclosing class. This provides additional encapsulation and security.





Q: What are the restrictions for a Member Inner class in Java?


A: Cannot have static methods.

B: Cannot have static variables.

C: Cannot access non-final local variables of the enclosing class.

D: Cannot have a constructor.


Correct Response: 1, 2, 3

Explanation: A Member Inner class in Java cannot have static methods, static variables, or access non-final local variables of the enclosing class. However, it can have a constructor.





Q: Can a Nested class be abstract in Java?


A: Yes, a Nested class can be abstract.

B: No, a Nested class cannot be abstract.

C: Only in Java 8 and later versions.


Correct Response: 1

Explanation: Yes, a Nested class can be abstract, just like any other class. An abstract Nested class cannot be instantiated and must be subclassed in order to be used.





Q: What is the purpose of Anonymous Inner class in Java?


A: To provide a way to extend a class or implement an interface without naming the class.

B: To provide a way to name a class without extending it or implementing an interface.

C: To provide a way to extend multiple classes or interfaces.


Correct Response: 1

Explanation: The purpose of an Anonymous Inner class in Java is to provide a way to extend a class or implement an interface without naming the class. Anonymous Inner classes are often used as a one-time use implementation, such as in event listeners or when creating a small, throwaway class.





Q: Can a Nested class be static and non-static both at the same time in Java?


A: No, a Nested class cannot be static and non-static both at the same time.

B: Yes, a Nested class can be static and non-static both at the same time.

C: Only in Java 8 and later versions.


Correct Response: 1

Explanation: No, a Nested class cannot be static and non-static both at the same time. A Nested class must be either static or non-static, but not both.





Q: How does the access of a Local Inner class change, if it is declared inside a static method?


A: The access remains the same, it can still access non-final local variables of the enclosing class.

B: The access is limited, it cannot access non-final local variables of the enclosing class.

C: The access is increased, it can access private members of the enclosing class.


Correct Response: 2

Explanation: If a Local Inner class is declared inside a static method, its access is limited and it cannot access non-final local variables of the enclosing class. This is because local variables are stored on the stack, which is not accessible from within a static method.





Q: What is the difference between a Member Inner class and a Local Inner class in Java?


A: A Member Inner class can access non-final local variables of the enclosing class, while a Local Inner class cannot.

B: A Member Inner class cannot access non-final local variables of the enclosing class, while a Local Inner class can.

C: There is no difference, both terms refer to the same thing.


Correct Response: 1

Explanation: The main difference between a Member Inner class and a Local Inner class is that a Member Inner class can access non-final local variables of the enclosing class, while a Local Inner class cannot. A Local Inner class is declared inside a method and can only access final local variables of the enclosing class.





Q: Can a Nested class be used as a top-level class in Java?


A: Yes, a Nested class can be used as a top-level class.

B: No, a Nested class cannot be used as a top-level class.

C: Only in Java 8 and later versions.


Correct Response: 2

Explanation: No, a Nested class cannot be used as a top-level class in Java. A Nested class must be declared inside another class, and cannot exist on its own.





Q: What is the meaning of Immutable in the context of String class in Java?


A: The value of a String object cannot be changed once it is created.

B: The value of a String object can be changed once it is created.

C: The value of a String object can only be changed by creating a new object.


Correct Response: 1

Explanation: In the context of the String class in Java, Immutable means that the value of a String object cannot be changed once it is created.





Q: Why is a String object considered immutable in Java?


A: To increase the security of String objects.

B: To increase the performance of String operations.

C: To make it easier to share String objects between different parts of an application.

D: All of the above.


Correct Response: 4

Explanation: A String object is considered immutable in Java for all of the above reasons. Immutable Strings increase the security of String objects, improve the performance of String operations, and make it easier to share String objects between different parts of an application.





Q: How many objects does the following code create?<br>String s1 = "hello";<br>String s2 = "hello";


A: 2 objects

B: 1 object

C: 3 objects

D: 4 objects


Correct Response: 2

Explanation: The following code creates 2 objects, s1 and s2.





Q: How many ways are there in Java to create a String object?


A: 1 way

B: 2 ways

C: 3 ways

D: 4 ways


Correct Response: 2

Explanation: There are 2 ways to create a String object in Java: using a string literal or using the new operator to create a String object from an array of characters.





Q: How many objects does the following code create?<br>String s1 = new String("hello");<br>String s2 = new String("hello");


A: 2 objects

B: 1 object

C: 3 objects

D: 4 objects


Correct Response: 1

Explanation: The following code creates 2 objects, s1 and s2.





Q: What is String interning?


A: A process where the JVM maintains a pool of strings, and reuses the existing string objects from the pool.

B: A process where the JVM creates a new string object for each string literal.

C: A process where the JVM converts all string literals to uppercase.


Correct Response: 1

Explanation: String interning is a process where the JVM maintains a pool of strings, and reuses the existing string objects from the pool instead of creating a new object for each string literal. This helps to conserve memory and improve performance.





Q: Why does Java use the String literal concept?


A: To make it easier to create and manipulate string objects.

B: To conserve memory and improve performance.

C: To make it easier to share string objects between different parts of an application.

D: All of the above.


Correct Response: 4

Explanation: Java uses the String literal concept for all of the above reasons. String literals make it easier to create and manipulate string objects, conserve memory and improve performance, and make it easier to share string objects between different parts of an application.





Q: What is the basic difference between a String and StringBuffer object?


A: A String object is immutable, while a StringBuffer object is mutable.

B: A StringBuffer object is immutable, while a String object is mutable.

C: There is no difference, both are the same.


Correct Response: 1

Explanation: The basic difference between a String and StringBuffer object is that a String object is immutable, while a StringBuffer object is mutable. This means that the contents of a String object cannot be changed, while the contents of a StringBuffer object can be changed.





Q: How will you create an immutable class in Java?


A: By declaring all variables as final and private.

B: By declaring all variables as public and non-final.

C: By declaring all variables as protected and non-final.

D: By declaring all variables as private and non-final.


Correct Response: 1

Explanation: To create an immutable class in Java, you must declare all variables as final and private. This ensures that the contents of the class cannot be changed once it is created.





Q: What is the use of the toString() method in Java?


A: To return a string representation of an object.

B: To convert an object to a string.

C: To return the memory address of an object.


Correct Response: 1

Explanation: The toString() method in Java is used to return a string representation of an object. This method is commonly overridden in custom classes to provide a meaningful string representation of the object for debugging or logging purposes.





Q: Arrange the three classes String, StringBuffer and StringBuilder in the order of efficiency for String processing operations?


A: StringBuilder, StringBuffer, String

B: String, StringBuffer, StringBuilder

C: String, StringBuilder, StringBuffer

D: StringBuffer, String, StringBuilder


Correct Response: 3

Explanation: The order of efficiency for String processing operations is String, StringBuilder, StringBuffer. String is the most efficient for simple string operations, but is immutable. StringBuilder and StringBuffer are less efficient than String, but are mutable and can be more efficient for complex string operations.





Q: What is the difference between the == and equals() method when comparing Strings in Java?


A: The == operator compares the memory addresses of two strings, while the equals() method compares the contents of two strings.

B: The equals() method compares the memory addresses of two strings, while the == operator compares the contents of two strings.

C: Both the == operator and the equals() method compare the memory addresses of two strings.

D: Both the == operator and the equals() method compare the contents of two strings.


Correct Response: 1

Explanation: The == operator compares the memory addresses of two strings, while the equals() method compares the contents of two strings. This means that the == operator will return true if two strings have the same memory address, while the equals() method will return true if two strings have the same contents.





Q: What is the difference between a String and a StringBuilder in Java?


A: A String is immutable, while a StringBuilder is mutable.

B: A StringBuilder is immutable, while a String is mutable.

C: There is no difference, both are the same.


Correct Response: 1

Explanation: The main difference between a String and a StringBuilder in Java is that a String is immutable, while a StringBuilder is mutable. This means that the contents of a String object cannot be changed, while the contents of a StringBuilder object can be changed.





Q: How can you concatenate two Strings in Java?


A: By using the + operator.

B: By using the concat() method.

C: By using the append() method.

D: By using the add() method.


Correct Response: 1

Explanation: You can concatenate two Strings in Java by using the + operator. For example, String s = "Hello" + "World"; will create a new string s with the contents "HelloWorld".





Q: What is the difference between the length() and capacity() method in Java for a String class?


A: The length() method returns the number of characters in a string, while the capacity() method returns the amount of memory allocated for the string.

B: The capacity() method returns the number of characters in a string, while the length() method returns the amount of memory allocated for the string.

C: Both the length() method and the capacity() method return the number of characters in a string.

D: Both the length() method and the capacity() method return the amount of memory allocated for the string.


Correct Response: 1

Explanation: The length() method returns the number of characters in a string, while the capacity() method does not exist in the String class, as Strings do not have a concept of capacity.





Q: What is the use of the trim() method in Java for the String class?


A: To remove leading and trailing whitespace from a string.

B: To add leading and trailing whitespace to a string.

C: To replace all whitespace in a string with a different character.


Correct Response: 1

Explanation: The trim() method in Java for the String class is used to remove leading and trailing whitespace from a string. For example, String s = " Hello World ".trim(); will create a new string s with the contents "Hello World".





Q: How can you split a String in Java?


A: By using the split() method.

B: By using the substring() method.

C: By using the replace() method.

D: By using the trim() method.


Correct Response: 1

Explanation: You can split a String in Java by using the split() method. For example, String s = "Hello,World"; String[] words = s.split(","); will create an array words with two elements, "Hello" and "World".





Q: What is the difference between substring() and subSequence() in Java for the String class?


A: The substring() method returns a new string that is a portion of the original string, while the subSequence() method returns a portion of the original string as a CharSequence.

B: The subSequence() method returns a new string that is a portion of the original string, while the substring() method returns a portion of the original string as a CharSequence.

C: Both the substring() method and the subSequence() method return a new string that is a portion of the original string.

D: Both the substring() method and the subSequence() method return a portion of the original string as a CharSequence.


Correct Response: 4

Explanation: The substring() method returns a new string that is a portion of the original string, while the subSequence() method returns a portion of the original string as a CharSequence.





Q: What is the use of the charAt() method in Java for the String class?


A: To return the character at a specified position in a string.

B: To replace the character at a specified position in a string.

C: To find the position of a specified character in a string.


Correct Response: 1

Explanation: The charAt() method in Java for the String class is used to return the character at a specified position in a string. For example, String s = "Hello"; char c = s.charAt(1); will assign the value 'e' to the variable c.





Q: What is the use of the compareTo() method in Java for the String class?


A: To compare two strings lexicographically and return an integer value indicating their relative order.

B: To concatenate two strings.

C: To replace all occurrences of a specified character in a string.


Correct Response: 1

Explanation: The compareTo() method in Java for the String class is used to compare two strings lexicographically and return an integer value indicating their relative order. For example, String s1 = "Hello"; String s2 = "World"; int result = s1.compareTo(s2); will assign a negative value to the variable result because "Hello" comes before "World" in lexicographic order.





Q: How can you convert a String to an int in Java?


A: By using the parseInt() method of the Integer class.

B: By using the valueOf() method of the Integer class.

C: By using the toInt() method of the String class.

D: By using the intValue() method of the String class.


Correct Response: 1

Explanation: You can convert a String to an int in Java by using the parseInt() method of the Integer class. For example, String s = "123"; int i = Integer.parseInt(s); will assign the value 123 to the variable i.





Q: What is Exception Handling in Java?


A: A mechanism for handling errors and exceptional conditions in a program.

B: A mechanism for ignoring errors and exceptional conditions in a program.

C: A mechanism for debugging errors and exceptional conditions in a program.


Correct Response: 1

Explanation: Exception handling in Java is a mechanism for handling errors and exceptional conditions in a program. It allows the program to continue executing even in the event of an error or exception, rather than crashing or terminating.





Q: In Java, what are the differences between a Checked and Unchecked Exception?


A: Checked exceptions are required to be handled by the calling code, while unchecked exceptions are not.

B: Unchecked exceptions are required to be handled by the calling code, while checked exceptions are not.

C: Both checked and unchecked exceptions are required to be handled by the calling code.

D: Neither checked nor unchecked exceptions are required to be handled by the calling code.


Correct Response: 1

Explanation: In Java, checked exceptions are required to be handled by the calling code, while unchecked exceptions are not. Checked exceptions are typically used to indicate expected errors or exceptional conditions, while unchecked exceptions are typically used to indicate unexpected or internal errors.





Q: What is the base class for Error and Exception classes in Java?


A: Throwable

B: Exception

C: Error


Correct Response: 1

Explanation: The base class for Error and Exception classes in Java is Throwable. Error and Exception classes are both subclasses of Throwable and are used to represent different types of errors and exceptional conditions in a program.





Q: What is a finally block in Java?


A: A block of code that is guaranteed to be executed after a try-catch block, regardless of whether an exception was thrown or caught.

B: A block of code that is executed before a try-catch block.

C: A block of code that is executed only if an exception was thrown.


Correct Response: 1

Explanation: A finally block in Java is a block of code that is guaranteed to be executed after a try-catch block, regardless of whether an exception was thrown or caught. The finally block can be used to clean up resources or perform other tasks that should always be executed, regardless of whether an exception was thrown or not.





Q: What is the use of finally block in Java?


A: To clean up resources or perform other tasks that should always be executed, regardless of whether an exception was thrown or not.

B: To catch exceptions that were thrown but not caught by a catch block.

C: To throw exceptions that were not caught by a catch block.


Correct Response: 1

Explanation: The use of finally block in Java is to clean up resources or perform other tasks that should always be executed, regardless of whether an exception was thrown or not. For example, a finally block can be used to close a file that was opened in a try block.





Q: Can we create a finally block without creating a catch block?


A: Yes

B: No

C: nan


Correct Response: 1

Explanation: Yes, we can create a finally block without creating a catch block. For example, a finally block can be used to perform cleanup tasks even if no exception was thrown in the try block.





Q: Do we have to always put a catch block after a try block?


A: No

B: Yes

C: nan


Correct Response: 1

Explanation: No, we do not have to always put a catch block after a try block. A try block can be followed by a catch block, a finally block, or both. If no exception is thrown in the try block, the catch block will not be executed, but the finally block will be executed if it exists.





Q: In what scenarios, a finally block will not be executed?


A: When a program exits or is terminated by a call to System.exit().

B: When an exception is thrown but not caught in the try-catch block.

C: When an exception is caught and handled in the catch block.


Correct Response: 1

Explanation: A finally block will not be executed when a program exits or is terminated by a call to System.exit(). In all other scenarios, the finally block will be executed, regardless of whether an exception was thrown or caught.





Q: Can we re-throw an Exception in Java?


A: Yes

B: No

C: nan


Correct Response: 1

Explanation: Yes, we can re-throw an Exception in Java by using the throw statement in a catch block. This allows the exception to be propagated to a higher level of the program where it can be handled or logged. For example, try { ... } catch (Exception e) { throw e; } will re-throw the exception that was caught in the catch block.





Q: What is the difference between throw and throws in Java?


A: The throw keyword is used to throw an exception, while the throws keyword is used to declare that a method may throw an exception.

B: The throws keyword is used to throw an exception, while the throw keyword is used to declare that a method may throw an exception.

C: Both the throw and throws keywords are used to throw an exception.

D: Neither the throw nor the throws keyword is used to throw an exception.


Correct Response: 1

Explanation: The difference between throw and throws in Java is that the throw keyword is used to throw an exception, while the throws keyword is used to declare that a method may throw an exception. For example, public void foo() throws IOException { throw new IOException(); } declares that the method foo() may throw an IOException, while the line throw new IOException(); actually throws the exception.





Q: What is the concept of Exception Propagation?


A: The process of passing an exception up the call stack to be handled by a higher level of the program.

B: The process of passing an exception down the call stack to be handled by a lower level of the program.

C: The process of logging an exception without passing it to another level of the program.


Correct Response: 1

Explanation: The concept of Exception Propagation refers to the process of passing an exception up the call stack to be handled by a higher level of the program. If an exception is not caught and handled in the method where it was thrown, it will be propagated to the caller of that method, and so on, until it is caught and handled by a catch block or until the program terminates.





Q: When we override a method in a Child class, can we throw an additional Exception that is not thrown by the Parent class method?


A: Yes

B: No

C: nan


Correct Response: 1

Explanation: Yes, we can throw an additional Exception that is not thrown by the Parent class method when we override a method in a Child class. This is because the Child class method must either declare the same exceptions as the Parent class method, or a subset of them, or it can declare additional exceptions.





Q: What is the purpose of using Exception Handling in Java?


A: To handle errors and exceptional conditions in a program and allow the program to continue executing, rather than crashing or terminating.

B: To ignore errors and exceptional conditions in a program.

C: To debug errors and exceptional conditions in a program.


Correct Response: 1

Explanation: The purpose of using Exception Handling in Java is to handle errors and exceptional conditions in a program and allow the program to continue executing, rather than crashing or terminating. By using exception handling, we can gracefully handle and recover from errors and exceptional conditions, improving the stability and robustness of the program.





Q: What is a try-catch block in Java and how does it work?


A: A try-catch block in Java is a mechanism for handling exceptions, where code that may throw an exception is placed in a try block, and the exception is caught and handled in a corresponding catch block.

B: A try-catch block in Java is a mechanism for ignoring exceptions, where code that may throw an exception is placed in a try block, and the exception is ignored in a corresponding catch block.

C: A try-catch block in Java is a mechanism for debugging exceptions, where code that may throw an exception is placed in a try block, and the exception is logged in a corresponding catch block.


Correct Response: 1

Explanation: A try-catch block in Java is a mechanism for handling exceptions, where code that may throw an exception is placed in a try block, and the exception is caught and handled in a corresponding catch block. The try block is executed, and if an exception is thrown, control is transferred to the corresponding catch block, where the exception can be logged, handled, or re-thrown.





Q: Can a try block be without a catch block in Java?


A: No

B: Yes

C: nan


Correct Response: 2

Explanation: Yes, a try block can be without a catch block in Java. In this case, the try block must be followed by a finally block, which can be used to perform cleanup tasks or release resources. For example, try { ... } finally { ... }.





Q: What is a throw keyword in Java and when is it used?


A: The throw keyword in Java is used to throw an exception, indicating that an error or exceptional condition has occurred.

B: The throw keyword in Java is used to declare that a method may throw an exception.

C: The throw keyword in Java is used to catch an exception.


Correct Response: 1

Explanation: The throw keyword in Java is used to throw an exception, indicating that an error or exceptional condition has occurred. For example, throw new IOException(); throws an IOException. The exception can then be caught and handled by a catch block in a try-catch block.





Q: What is the role of a catch block in Exception Handling in Java?


A: The role of a catch block in Exception Handling in Java is to catch an exception that was thrown in a try block and handle it, either by logging it, recovering from it, or re-throwing it.

B: The role of a catch block in Exception Handling in Java is to ignore exceptions that were thrown in a try block.

C: The role of a catch block in Exception Handling in Java is to debug exceptions that were thrown in a try block.


Correct Response: 1

Explanation: The role of a catch block in Exception Handling in Java is to catch an exception that was thrown in a try block and handle it, either by logging it, recovering from it, or re-throwing it. The catch block specifies the type of exception it can handle, and the code inside the catch block is executed if an exception of that type is thrown in the try block.





Q: What is a custom exception in Java and how do you create one?


A: A custom exception in Java is a user-defined exception class that you create to handle specific errors or exceptional conditions in your program. To create a custom exception, you can extend the Exception class or create a new class that implements the Throwable interface.

B: A custom exception in Java is a pre-defined exception class that you use to handle specific errors or exceptional conditions in your program. To create a custom exception, you can use one of the pre-defined exception classes or modify one of them.

C: A custom exception in Java is not supported in the Java language.


Correct Response: 1

Explanation: A custom exception in Java is a user-defined exception class that you create to handle specific errors or exceptional conditions in your program. To create a custom exception, you can extend the Exception class or create a new class that implements the Throwable interface. For example, class MyException extends Exception { ... } creates a custom exception class named MyException.





Q: What is the use of throws keyword in Java?


A: The throws keyword in Java is used to declare that a method may throw an exception, indicating that the caller of the method must handle the exception or propagate it to its own caller.

B: The throws keyword in Java is used to ignore exceptions that may be thrown by a method.

C: The throws keyword in Java is used to catch exceptions that may be thrown by a method.


Correct Response: 1

Explanation: The throws keyword in Java is used to declare that a method may throw an exception, indicating that the caller of the method must handle the exception or propagate it to its own caller. For example, public void foo() throws IOException { ... } declares that the method foo() may throw an IOException, and the caller of foo() must either handle the exception or propagate it.





Q: What is a finally block used for in Java and when is it executed?


A: A finally block in Java is used to perform cleanup tasks or release resources, and it is executed regardless of whether an exception was thrown or caught in the try block.

B: A finally block in Java is used to ignore exceptions that were thrown in a try block, and it is executed only if an exception was thrown and not caught in the try block.

C: A finally block in Java is used to log exceptions that were thrown in a try block, and it is executed only if an exception was thrown and caught in the try block.


Correct Response: 1

Explanation: A finally block in Java is used to perform cleanup tasks or release resources, and it is executed regardless of whether an exception was thrown or caught in the try block. The finally block is optional, but if it is specified, it is executed after the try block and any corresponding catch blocks. The finally block can be used to ensure that resources are released, even if an exception occurs.





Q: Can we use multiple catch blocks with a single try block in Java?


A: Yes

B: No

C: nan


Correct Response: 1

Explanation: Yes, we can use multiple catch blocks with a single try block in Java. This allows us to handle different types of exceptions in separate catch blocks, based on the type of exception that was thrown. Each catch block specifies a different exception type, and the first catch block that matches the type of the thrown exception is executed.





Q: How Multi-threading works in Java?


A: Multi-threading in Java works by dividing a program into multiple threads, each of which can run concurrently and independently of the other threads. The Java Virtual Machine schedules the execution of threads based on their priority and the availability of system resources.

B: Multi-threading in Java works by executing all threads in sequence, one after the other.

C: Multi-threading in Java is not supported.


Correct Response: 1

Explanation: Multi-threading in Java works by dividing a program into multiple threads, each of which can run concurrently and independently of the other threads. The Java Virtual Machine schedules the execution of threads based on their priority and the availability of system resources. This allows multiple tasks to be executed simultaneously, improving the overall performance and responsiveness of the program.





Q: What are the advantages of Multithreading?


A: Improved performance and responsiveness

B: Increased resource utilization

C: Improved scalability and flexibility

D: Improved user experience


Correct Response: 1, 2, 3, 4

Explanation: Multi-threading provides several advantages, including improved performance and responsiveness, increased resource utilization, improved scalability and flexibility, and improved user experience. By dividing a program into multiple threads, each of which can run concurrently and independently of the other threads, multi-threading allows multiple tasks to be executed simultaneously, improving the overall performance and responsiveness of the program.





Q: What are the disadvantages of Multithreading?


A: Increased complexity and difficulty of debugging

B: Increased risk of race conditions and deadlocks

C: Decreased performance and responsiveness

D: Decreased scalability and flexibility


Correct Response: 1, 2

Explanation: Multi-threading has several disadvantages, including increased complexity and difficulty of debugging, and increased risk of race conditions and deadlocks. Debugging multi-threaded programs can be difficult, as the execution of threads may interact in unexpected ways, leading to bugs that are difficult to isolate and fix. In addition, race conditions and deadlocks can occur, where multiple threads access and modify shared data concurrently, leading to unpredictable results and potential deadlocks.





Q: What is a Thread in Java?


A: A Thread in Java is a lightweight and independent unit of execution, representing a single task or operation within a program.

B: A Thread in Java is a heavyweight and dependent unit of execution, representing a single task or operation within a program.

C: A Thread in Java is not supported.


Correct Response: 1

Explanation: A Thread in Java is a lightweight and independent unit of execution, representing a single task or operation within a program. Threads are scheduled and executed by the Java Virtual Machine, and can run concurrently and independently of other threads in the same program.





Q: What is a Thread’s priority and how it is used in scheduling?


A: A Thread's priority in Java is an integer value that determines the order in which the threads are scheduled and executed by the Java Virtual Machine. The priority of a thread is used to determine the order in which threads are scheduled for execution, with higher-priority threads being executed before lower-priority threads.

B: A Thread's priority in Java is a boolean value that determines whether the thread is executed or not.

C: A Thread's priority in Java is not used in scheduling.


Correct Response: 1

Explanation: A Thread's priority in Java is an integer value that determines the order in which the threads are scheduled and executed by the Java Virtual Machine. The priority of a thread is used to determine the order in which threads are scheduled for execution, with higher-priority threads being executed before lower-priority threads. The Java Virtual Machine uses the priority of a thread to determine the order in which threads are executed, but the actual scheduling and execution of threads may depend on several factors, including the underlying operating system, the number and priority of other threads, and the availability of system resources.





Q: What are the differences between Pre-emptive Scheduling Scheduler and Time Slicing Scheduler?


A: In a pre-emptive scheduling scheduler, a higher-priority thread can interrupt the execution of a lower-priority thread at any time. In a time slicing scheduler, the execution of threads is divided into equal time slices, and each thread is executed for a fixed amount of time before being preempted.

B: In a pre-emptive scheduling scheduler, a higher-priority thread cannot interrupt the execution of a lower-priority thread. In a time slicing scheduler, the execution of threads is divided into unequal time slices, and each thread is executed for a different amount of time based on its priority.

C: In a pre-emptive scheduling scheduler, all threads are executed in sequence, one after the other. In a time slicing scheduler, all threads are executed concurrently and simultaneously.


Correct Response: 1

Explanation: In a pre-emptive scheduling scheduler, a higher-priority thread can interrupt the execution of a lower-priority thread at any time. In a time slicing scheduler, the execution of threads is divided into equal time slices, and each thread is executed for a fixed amount of time before being preempted. The actual scheduling and execution of threads in Java may depend on several factors, including the underlying operating system, the number and priority of other threads, and the availability of system resources.





Q: How will you make a user thread into daemon thread if it has already started?


A: It is not possible to change the status of a thread from user to daemon once it has already started.

B: You can make a user thread into a daemon thread by calling the setDaemon(true) method on the thread object before calling the start() method.

C: You can make a user thread into a daemon thread by calling the setDaemon(true) method on the thread object after calling the start() method.


Correct Response: 2

Explanation: You can make a user thread into a daemon thread by calling the setDaemon(true) method on the thread object before calling the start() method. The setDaemon(true) method sets the status of the thread as a daemon thread, which is a low-priority background thread that runs only as long as there are other non-daemon threads running in the program.





Q: Can we start a thread two times in Java?


A: No, a thread can only be started once in Java. Attempting to start a thread that has already been started will result in an IllegalThreadStateException.

B: Yes, a thread can be started multiple times in Java.

C: It depends on the implementation of the thread.


Correct Response: 1

Explanation: No, a thread can only be started once in Java. Attempting to start a thread that has already been started will result in an IllegalThreadStateException. Once a thread has completed its execution, it cannot be restarted, and a new thread must be created for a new task.





Q: In what scenarios can we interrupt a thread?


A: When the thread is blocked in a sleep, wait, or join method.

B: When the thread is executing an I/O operation.

C: When the thread is waiting for a lock.

D: When the thread is performing a task that takes a long time to complete.


Correct Response: 1, 2, 3

Explanation: We can interrupt a thread in several scenarios, including when the thread is blocked in a sleep, wait, or join method, when the thread is executing an I/O operation, or when the thread is waiting for a lock. Interrupting a thread can be used to stop a running task or to signal a blocked task to unblock and return control to the calling thread.





Q: In Java, is it possible to lock an object for exclusive use by a thread?


A: Yes, in Java, it is possible to lock an object for exclusive use by a thread using the synchronized keyword or by using the java.util.concurrent.locks package.

B: No, in Java, it is not possible to lock an object for exclusive use by a thread.

C: It depends on the implementation of the thread.


Correct Response: 1

Explanation: Yes, in Java, it is possible to lock an object for exclusive use by a thread using the synchronized keyword or by using the java.util.concurrent.locks package. The synchronized keyword can be used to synchronize the access to a shared resource, ensuring that only one thread can access the resource at a time. The java.util.concurrent.locks package provides a more flexible and powerful mechanism for locking and synchronization in Java.





Q: How notify() method is different from notifyAll() method?


A: The notify() method is used to signal a single waiting thread to wake up and continue execution. The notifyAll() method is used to signal all waiting threads to wake up and continue execution.

B: The notify() method is used to signal all waiting threads to wake up and continue execution. The notifyAll() method is used to signal a single waiting thread to wake up and continue execution.

C: Both the notify() and notifyAll() methods are used to signal all waiting threads to wake up and continue execution.


Correct Response: 1

Explanation: The notify() method is used to signal a single waiting thread to wake up and continue execution. The notifyAll() method is used to signal all waiting threads to wake up and continue execution. The notify() method is used when you want to wake up only one of the waiting threads, while the notifyAll() method is used when you want to wake up all of the waiting threads.





Q: What is the purpose of using synchronized keyword in Java multi-threading?


A: The purpose of using the synchronized keyword in Java multi-threading is to ensure that only one thread can access a shared resource at a time, preventing race conditions and other synchronization-related issues.

B: The purpose of using the synchronized keyword in Java multi-threading is to improve the performance of multi-threaded applications.

C: The purpose of using the synchronized keyword in Java multi-threading is to provide a mechanism for inter-thread communication.


Correct Response: 1

Explanation: The purpose of using the synchronized keyword in Java multi-threading is to ensure that only one thread can access a shared resource at a time, preventing race conditions and other synchronization-related issues. The synchronized keyword can be used to synchronize the access to a shared resource, ensuring that only one thread can access the resource at a time. This can be useful for preventing race conditions, where multiple threads try to access and modify the same resource simultaneously, leading to unpredictable and incorrect results.





Q: What is the difference between wait() and sleep() methods in Java?


A: The wait() method is used to signal a waiting thread to wake up and continue execution, while the sleep() method is used to pause the execution of a thread for a specified amount of time.

B: The wait() method is used to pause the execution of a thread for a specified amount of time, while the sleep() method is used to signal a waiting thread to wake up and continue execution.

C: Both the wait() and sleep() methods are used to pause the execution of a thread for a specified amount of time.


Correct Response: 1

Explanation: The wait() method is used to signal a waiting thread to wake up and continue execution, while the sleep() method is used to pause the execution of a thread for a specified amount of time. The wait() method is used in the context of inter-thread communication, where one thread signals another waiting thread to wake up and continue execution. The sleep() method, on the other hand, is used to temporarily pause the execution of a thread for a specified amount of time.





Q: What is the difference between a process and a thread in Java?


A: A process is a program in execution, while a thread is a lightweight sub-process that runs within a process and shares the process's resources.

B: A process is a lightweight sub-process that runs within a process and shares the process's resources, while a thread is a program in execution.

C: Both a process and a thread are the same thing in Java.


Correct Response: 1

Explanation: A process is a program in execution, while a thread is a lightweight sub-process that runs within a process and shares the process's resources. A process is a standalone program that runs on a computer and has its own memory space, system resources, and environment. A thread, on the other hand, is a smaller unit of execution that runs within a process and shares the process's memory space, system resources, and environment.





Q: How does multi-threading improve performance in Java?


A: Multi-threading improves performance in Java by allowing multiple tasks to run concurrently, utilizing the available processing power and system resources more efficiently.

B: Multi-threading improves performance in Java by increasing the speed of execution of individual tasks.

C: Multi-threading improves performance in Java by reducing the amount of memory used by the program.


Correct Response: 1

Explanation: Multi-threading improves performance in Java by allowing multiple tasks to run concurrently, utilizing the available processing power and system resources more efficiently. By breaking a large task into smaller subtasks and executing them in parallel using multiple threads, multi-threading can improve the overall performance and responsiveness of a program. This can be particularly useful for programs that perform intensive computations or wait for external events, such as I/O operations or network requests.





Q: What is the difference between Thread and Runnable in Java?


A: The difference between Thread and Runnable in Java is that the Thread class is a subclass of the Object class and implements the Runnable interface, while the Runnable interface is used to define a task that can be executed by a thread.

B: The difference between Thread and Runnable in Java is that the Thread class implements the Runnable interface, while the Runnable interface is a subclass of the Object class and is used to define a task that can be executed by a thread.

C: Both Thread and Runnable are the same thing in Java.


Correct Response: 1

Explanation: The difference between Thread and Runnable in Java is that the Thread class is a subclass of the Object class and implements the Runnable interface, while the Runnable interface is used to define a task that can be executed by a thread. The Runnable interface defines a single method, run(), that represents the task to be executed by a thread. To create a new thread and execute a task, you can either extend the Thread class or implement the Runnable interface and pass it as an argument to the Thread constructor.





Q: What is the role of the thread scheduler in Java multi-threading?


A: The role of the thread scheduler in Java multi-threading is to determine which thread should run next, based on the priority and status of the available threads.

B: The role of the thread scheduler in Java multi-threading is to create new threads and manage the execution of existing threads.

C: The role of the thread scheduler in Java multi-threading is to coordinate the communication between threads.


Correct Response: 1

Explanation: The role of the thread scheduler in Java multi-threading is to determine which thread should run next, based on the priority and status of the available threads. The thread scheduler is responsible for selecting the next thread to be executed, based on the priority of the available threads and the current state of the system. The scheduler is responsible for deciding when a running thread should be preempted and when a waiting thread should be resumed.





Q: What is the use of the join() method in Java multi-threading?


A: The use of the join() method in Java multi-threading is to wait for a thread to complete its execution before continuing with the next statement.

B: The use of the join() method in Java multi-threading is to start a new thread and run a task concurrently.

C: The use of the join() method in Java multi-threading is to signal a waiting thread to wake up and continue execution.


Correct Response: 1

Explanation: The use of the join() method in Java multi-threading is to wait for a thread to complete its execution before continuing with the next statement. The join() method can be used to wait for a thread to complete its execution, ensuring that the current thread does not proceed to the next statement until the specified thread has finished. The join() method can be useful for coordinating the execution of multiple threads and ensuring that the program runs in the desired order.





Q: What is the difference between yield() and join() methods in Java?


A: The difference between yield() and join() methods in Java is that the yield() method is used to temporarily pause the execution of the current thread to allow other threads with the same priority to run, while the join() method is used to wait for a thread to complete its execution before continuing with the next statement.

B: The difference between yield() and join() methods in Java is that the join() method is used to temporarily pause the execution of the current thread to allow other threads with the same priority to run, while the yield() method is used to wait for a thread to complete its execution before continuing with the next statement.

C: Both the yield() and join() methods are used to start a new thread and run a task concurrently.


Correct Response: 1

Explanation: The difference between yield() and join() methods in Java is that the yield() method is used to temporarily pause the execution of the current thread to allow other threads with the same priority to run, while the join() method is used to wait for a thread to complete its execution before continuing with the next statement. The yield() method can be used to temporarily pause the execution of the current thread and allow other threads with the same priority to run, improving the overall responsiveness of the program. The join() method, on the other hand, can be used to wait for a thread to complete its execution, ensuring that the current thread does not proceed to the next statement until the specified thread has finished.





Q: What is the use of the volatile keyword in Java multi-threading?


A: The use of the volatile keyword in Java multi-threading is to ensure that a variable's value is read from main memory and not from the thread cache, ensuring that multiple threads access the latest value of the variable.

B: The use of the volatile keyword in Java multi-threading is to ensure that a variable's value is read from the thread cache and not from main memory, improving the performance of the program.

C: The use of the volatile keyword in Java multi-threading is to ensure that a variable's value is read from both the thread cache and main memory, improving the reliability of the program.


Correct Response: 1

Explanation: The use of the volatile keyword in Java multi-threading is to ensure that a variable's value is read from main memory and not from the thread cache, ensuring that multiple threads access the latest value of the variable. The volatile keyword can be used to declare a variable as volatile, which means that its value can be changed by multiple threads and that the value of the variable is guaranteed to be the latest value when accessed from any thread. This can be useful for ensuring that multiple threads access the latest value of a variable, improving the reliability of the program.





Q: What is the difference between producer-consumer problem and readers-writers problem in Java multi-threading?


A: The producer-consumer problem is when multiple producers try to write to a single buffer, while the readers-writers problem is when multiple readers try to read from a single buffer.

B: The producer-consumer problem is when multiple consumers try to read from a single buffer, while the readers-writers problem is when multiple writers try to write to a single buffer.

C: The producer-consumer problem and readers-writers problem are the same thing.


Correct Response: 1

Explanation: The producer-consumer problem is when multiple producers try to write to a single buffer, while the readers-writers problem is when multiple readers try to read from a single buffer. These are both synchronization problems that can occur in multi-threaded systems.





Q: What are the differences between the two data structures: a Vector and an ArrayList?


A: Vectors are synchronized while ArrayLists are not.

B: ArrayLists are synchronized while Vectors are not.

C: Both Vectors and ArrayLists are synchronized.


Correct Response: 1

Explanation: Vectors are synchronized, meaning multiple threads can access a Vector without causing any problems, while ArrayLists are not synchronized. This makes ArrayLists faster, but it also means that they are not thread-safe.





Q: What are the differences between Collection and Collections in Java?


A: Collection is an interface, while Collections is a class.

B: Collection is a class, while Collections is an interface.

C: Both Collection and Collections are interfaces.


Correct Response: 1

Explanation: Collection is an interface that defines the methods for working with collections in Java, while Collections is a class that provides utility methods for working with collections.





Q: In which scenario, LinkedList is better than ArrayList in Java?


A: When inserting or deleting elements in the middle of a list.

B: When accessing elements at the beginning or end of a list.

C: When accessing elements in the middle of a list.


Correct Response: 1

Explanation: LinkedList is better than ArrayList when inserting or deleting elements in the middle of a list, as it requires less shifting of elements. ArrayList is better for accessing elements at the beginning or end of a list, as it has faster access times due to its index-based structure.





Q: What are the differences between a List and Set collection in Java?


A: Lists allow duplicate elements, while Sets do not.

B: Sets allow duplicate elements, while Lists do not.

C: Both Lists and Sets allow duplicate elements.


Correct Response: 1

Explanation: Lists allow duplicate elements, while Sets do not. Sets are collections that store unique elements, while Lists are collections that can store duplicate elements.





Q: What are the differences between a HashSet and TreeSet collection in Java?


A: HashSet is unordered, while TreeSet is ordered.

B: TreeSet is unordered, while HashSet is ordered.

C: Both HashSet and TreeSet are ordered.


Correct Response: 1

Explanation: HashSet is unordered, meaning the elements are stored in a random order, while TreeSet is ordered, meaning the elements are stored in a sorted order.





Q: In Java, how will you decide when to use a List, Set or a Map collection?


A: Use a List when you need to maintain the order of elements, use a Set when you need to store unique elements, and use a Map when you need to store key-value pairs.

B: Use a List when you need to store key-value pairs, use a Set when you need to maintain the order of elements, and use a Map when you need to store unique elements.

C: Use a List when you need to store unique elements, use a Set when you need to store key-value pairs, and use a Map when you need to maintain the order of elements.


Correct Response: 1

Explanation: Use a List when you need to maintain the order of elements, use a Set when you need to store unique elements, and use a Map when you need to store key-value pairs.





Q: What are the differences between a HashMap and a Hashtable in Java?


A: HashMap is unsynchronized, while Hashtable is synchronized.

B: Hashtable is unsynchronized, while HashMap is synchronized.

C: Both HashMap and Hashtable are synchronized.


Correct Response: 1

Explanation: HashMap is unsynchronized, meaning multiple threads can access it at the same time, while Hashtable is synchronized, meaning only one thread can access it at a time. This makes Hashtable slower, but it also makes it thread-safe.





Q: What are the differences between a HashMap and a TreeMap?


A: HashMap is unordered, while TreeMap is ordered.

B: TreeMap is unordered, while HashMap is ordered.

C: Both HashMap and TreeMap are ordered.


Correct Response: 1

Explanation: HashMap is unordered, meaning the elements are stored in a random order, while TreeMap is ordered, meaning the elements are stored in a sorted order.





Q: What are the differences between Comparable and Comparator?


A: Comparable is used for default natural sorting order, while Comparator is used for custom sorting order.

B: Comparator is used for default natural sorting order, while Comparable is used for custom sorting order.

C: Both Comparable and Comparator are used for default natural sorting order.


Correct Response: 1

Explanation: Comparable is used for default natural sorting order, meaning it defines the natural order of elements, while Comparator is used for custom sorting order, meaning it allows you to define a custom sorting order for elements.





Q: In Java, what is the purpose of Properties file?


A: To store configuration data that can be easily changed without recompiling the code.

B: To store program logic.

C: To store class definitions.


Correct Response: 1

Explanation: Properties files are used to store configuration data that can be easily changed without recompiling the code. This makes it easier to modify the behavior of a program without changing the source code.





Q: What is the reason for overriding equals() method?


A: To check if two objects are equal based on their contents.

B: To check if two objects are equal based on their references.

C: To check if two objects are equal based on their class.


Correct Response: 1

Explanation: The purpose of overriding the equals() method is to check if two objects are equal based on their contents, rather than their references. This allows you to determine if two objects have the same data, even if they are not the same object in memory.





Q: How does hashCode() method work in Java?


A: It returns a unique identifier for an object based on its contents.

B: It returns a unique identifier for an object based on its reference.

C: It returns a unique identifier for an object based on its class.


Correct Response: 1

Explanation: The hashCode() method returns a unique identifier for an object based on its contents. This allows objects to be stored and retrieved efficiently in data structures like HashMap and HashSet.





Q: Is it a good idea to use Generics in collections?


A: Yes, it is a good idea to use Generics in collections as it provides type safety and eliminates the need for type casting.

B: No, it is not a good idea to use Generics in collections as it adds complexity to the code.

C: It depends on the use case.


Correct Response: 1

Explanation: Yes, it is a good idea to use Generics in collections as it provides type safety and eliminates the need for type casting. This makes the code more readable and less prone to errors.





Q: What are the different types of collections in Java and what are their uses?


A: List, Set, Map, and Queue. They are used for storing, manipulating, and retrieving elements.

B: Stack, Queue, Set, and Map. They are used for storing, manipulating, and retrieving elements.

C: Tree, Set, Map, and List. They are used for storing, manipulating, and retrieving elements.


Correct Response: 1

Explanation: List, Set, Map, and Queue are the different types of collections in Java. They are used for storing, manipulating, and retrieving elements. List stores elements in a specific order, Set stores unique elements, Map stores key-value pairs, and Queue stores elements in a specific order for processing.





Q: What is the difference between Iterator and ListIterator in Java?


A: Iterator allows you to traverse elements in a collection in a forward direction, while ListIterator allows you to traverse elements in a collection in both forward and backward directions.

B: ListIterator allows you to traverse elements in a collection in a forward direction, while Iterator allows you to traverse elements in a collection in both forward and backward directions.

C: Both Iterator and ListIterator allow you to traverse elements in a collection in a forward direction.


Correct Response: 1

Explanation: Iterator allows you to traverse elements in a collection in a forward direction, while ListIterator allows you to traverse elements in a collection in both forward and backward directions. This makes ListIterator more flexible than Iterator.





Q: What is the difference between ArrayList and LinkedList in terms of performance?


A: ArrayList is faster for accessing elements at the beginning or end of a list, while LinkedList is faster for inserting or deleting elements in the middle of a list.

B: LinkedList is faster for accessing elements at the beginning or end of a list, while ArrayList is faster for inserting or deleting elements in the middle of a list.

C: Both ArrayList and LinkedList have the same performance.


Correct Response: 1

Explanation: ArrayList is faster for accessing elements at the beginning or end of a list, while LinkedList is faster for inserting or deleting elements in the middle of a list. This is because ArrayList uses an index-based structure, while LinkedList uses a linked structure.





Q: What is the difference between HashMap and HashSet in Java?


A: HashMap stores key-value pairs, while HashSet stores unique elements.

B: HashSet stores key-value pairs, while HashMap stores unique elements.

C: Both HashMap and HashSet store key-value pairs.


Correct Response: 1

Explanation: HashMap stores key-value pairs, while HashSet stores unique elements. This means that HashMap allows you to store data as key-value pairs, while HashSet only allows you to store unique elements.





Q: What is the difference between a Map and a HashMap in Java?


A: Map is an interface, while HashMap is a class.

B: HashMap is an interface, while Map is a class.

C: Both Map and HashMap are classes.


Correct Response: 1

Explanation: Map is an interface that defines the methods for working with maps in Java, while HashMap is a class that implements the Map interface.





Q: What is the use of the Collections class in Java?


A: It provides utility methods for working with collections.

B: It provides methods for creating collections.

C: It provides methods for sorting collections.


Correct Response: 1

Explanation: The Collections class provides utility methods for working with collections, such as sorting, searching, and shuffling. This makes it easier to perform common operations on collections.





Q: What is the difference between a HashMap and a TreeMap in terms of performance?


A: HashMap is faster for inserting and retrieving elements, while TreeMap is slower but provides ordered elements.

B: TreeMap is faster for inserting and retrieving elements, while HashMap is slower but provides ordered elements.

C: Both HashMap and TreeMap have the same performance.


Correct Response: 1

Explanation: HashMap is faster for inserting and retrieving elements, while TreeMap is slower but provides ordered elements. This means that HashMap is a better choice for large collections when you don't care about the order of elements, while TreeMap is a better choice for small collections when you need to maintain the order of elements.





Q: What is the difference between a SortedSet and a NavigableSet in Java?


A: SortedSet provides a sorted view of elements, while NavigableSet provides a sorted view of elements and additional navigation methods.

B: NavigableSet provides a sorted view of elements, while SortedSet provides a sorted view of elements and additional navigation methods.

C: Both SortedSet and NavigableSet provide the same view of elements.


Correct Response: 2

Explanation: NavigableSet provides a sorted view of elements and additional navigation methods, such as retrieving the next element or the previous element, while SortedSet only provides a sorted view of elements.





Q: What is the difference between a Queue and a Stack in Java?


A: Queue follows the First-In-First-Out (FIFO) principle, while Stack follows the Last-In-First-Out (LIFO) principle.

B: Stack follows the First-In-First-Out (FIFO) principle, while Queue follows the Last-In-First-Out (LIFO) principle.

C: Both Queue and Stack follow the First-In-First-Out (FIFO) principle.


Correct Response: 1

Explanation: Queue follows the First-In-First-Out (FIFO) principle, meaning that the first element added to the queue will be the first element to be removed, while Stack follows the Last-In-First-Out (LIFO) principle, meaning that the last element added to the stack will be the first element to be removed.





Q: What is the difference between a Set and a Map in Java?


A: Set stores unique elements, while Map stores key-value pairs.

B: Map stores unique elements, while Set stores key-value pairs.

C: Both Set and Map store unique elements.


Correct Response: 1

Explanation: Set stores unique elements, while Map stores key-value pairs. This means that Set only allows you to store unique elements, while Map allows you to store data as key-value pairs.





Q: What is the purpose of the Map interface in Java and what are its implementations?


A: The Map interface is used for storing key-value pairs in Java, and its implementations include HashMap, TreeMap, and Hashtable.

B: The Map interface is used for storing unique elements in Java, and its implementations include Set, List, and ArrayList.

C: The Map interface is used for storing elements in a sorted order in Java, and its implementations include SortedSet, TreeSet, and NavigableSet.


Correct Response: 1

Explanation: The Map interface is used for storing key-value pairs in Java, and its implementations include HashMap, TreeMap, and Hashtable. This means that Map allows you to store data as key-value pairs, while its implementations provide different ways of storing and retrieving this data.





Q: What are Wrapper classes in Java?


A: Wrapper classes are classes that wrap primitive data types in Java, allowing them to be treated as objects.

B: Wrapper classes are classes that provide additional functionality for primitive data types in Java.

C: Wrapper classes are classes that provide a way to store primitive data types in Java.


Correct Response: 1

Explanation: Wrapper classes are classes that wrap primitive data types in Java, allowing them to be treated as objects. This means that you can perform operations on primitive data types that you can perform on objects, such as storing them in collections and passing them as parameters.





Q: What is the purpose of native method in Java?


A: A native method is used to access system-specific functionality that is not available in Java.

B: A native method is used to access platform-independent functionality in Java.

C: A native method is used to access platform-specific functionality in Java.


Correct Response: 1

Explanation: A native method is used to access system-specific functionality that is not available in Java. This allows you to access functionality that is not provided by the Java platform, such as operating system-specific features or low-level hardware access.





Q: What is System class?


A: The System class is a class in Java that provides access to system-level resources, such as standard input and output streams, environment variables, and the current time.

B: The System class is a class in Java that provides access to platform-level resources, such as files and directories.

C: The System class is a class in Java that provides access to application-level resources, such as classes and methods.


Correct Response: 1

Explanation: The System class is a class in Java that provides access to system-level resources, such as standard input and output streams, environment variables, and the current time. This allows you to perform common system-level operations in your Java programs.





Q: What is System, out and println in System.out.println method call?


A: System is a class in Java, out is an object of the PrintStream class, and println is a method that prints a line of text to the standard output stream.

B: System is an object of the PrintStream class, out is a class in Java, and println is a method that prints a line of text to the standard output stream.

C: System is a method in Java, out is an object of the PrintStream class, and println is a class that prints a line of text to the standard output stream.


Correct Response: 1

Explanation: System is a class in Java, out is an object of the PrintStream class, and println is a method that prints a line of text to the standard output stream. This allows you to perform common output operations in your Java programs.





Q: What is the other name of Shallow Copy in Java?


A: A shallow copy is also known as a bitwise copy.

B: A shallow copy is also known as a reference copy.

C: A shallow copy is also known as a deep copy.


Correct Response: 2

Explanation: A shallow copy is also known as a reference copy. This means that a shallow copy creates a new reference to the same object, rather than creating a new object with the same data.





Q: What is the difference between Shallow Copy and Deep Copy in Java?


A: A shallow copy creates a new reference to the same object, while a deep copy creates a new object with the same data.

B: A deep copy creates a new reference to the same object, while a shallow copy creates a new object with the same data.

C: Both shallow copy and deep copy create a new reference to the same object.


Correct Response: 1

Explanation: A shallow copy creates a new reference to the same object, while a deep copy creates a new object with the same data. This means that changes to the original object will affect both the original object and the shallow copy, while changes to the original object will only affect the original object and not the deep copy.





Q: What is a Singleton class?


A: A Singleton class is a class that can only have one instance, and provides a global point of access to that instance.

B: A Singleton class is a class that can have multiple instances, and provides a global point of access to those instances.

C: A Singleton class is a class that cannot have any instances, and provides a global point of access to a null value.


Correct Response: 1

Explanation: A Singleton class is a class that can only have one instance, and provides a global point of access to that instance. This means that you can use the Singleton class to enforce a single instance of a class in your Java programs.





Q: What is the difference between Singleton class and Static class?


A: A Singleton class can only have one instance, while a Static class can have multiple instances.

B: A Static class can only have one instance, while a Singleton class can have multiple instances.

C: Both Singleton class and Static class can only have one instance.


Correct Response: 1

Explanation: A Singleton class can only have one instance, while a Static class can have multiple instances. This means that you can use the Singleton class to enforce a single instance of a class in your Java programs, while you can use the Static class to provide class-level methods and properties that are shared by all instances of the class.





Q: What is the difference between Collection and Collections Framework in Java?


A: Collection is an interface in Java that represents a group of objects, while Collections Framework is a set of classes and interfaces that provide additional functionality for Collection.

B: Collections Framework is an interface in Java that represents a group of objects, while Collection is a set of classes and interfaces that provide additional functionality for Collections Framework.

C: Both Collection and Collections Framework represent a group of objects in Java.


Correct Response: 1

Explanation: Collection is an interface in Java that represents a group of objects, while Collections Framework is a set of classes and interfaces that provide additional functionality for Collection. This means that Collection provides a basic way to represent a group of objects in Java, while Collections Framework provides additional functionality such as sorting, searching, and manipulating these collections.





Q: What are the main benefits of Collections Framework in Java?


A: The main benefits of Collections Framework in Java are improved performance, increased flexibility, and reduced code complexity.

B: The main benefits of Collections Framework in Java are reduced performance, decreased flexibility, and increased code complexity.

C: The main benefits of Collections Framework in Java are increased performance, decreased flexibility, and reduced code complexity.


Correct Response: 1

Explanation: The main benefits of Collections Framework in Java are improved performance, increased flexibility, and reduced code complexity. This means that Collections Framework provides a way to efficiently store and manipulate groups of objects, with a simplified API that reduces the amount of code you need to write.





Q: What is the root interface of Collection hierarchy in Java?


A: The root interface of Collection hierarchy in Java is Collection.

B: The root interface of Collection hierarchy in Java is Map.

C: The root interface of Collection hierarchy in Java is List.


Correct Response: 1

Explanation: The root interface of Collection hierarchy in Java is Collection. This means that Collection is the top-level interface in the Java Collections Framework, and all other interfaces and classes in the framework inherit from it.





Q: What are the main differences between Collection and Collections?


A: Collection is an interface in Java that represents a group of objects, while Collections is a class that provides utility methods for working with collections.

B: Collection is a class in Java that provides utility methods for working with collections, while Collections is an interface that represents a group of objects.

C: Both Collection and Collections represent a group of objects in Java.


Correct Response: 1

Explanation: Collection is an interface in Java that represents a group of objects, while Collections is a class that provides utility methods for working with collections. This means that Collection provides a basic way to represent a group of objects in Java, while Collections provides additional utility methods such as sorting and searching collections.





Q: What are the Thread-safe classes in Java Collections framework?


A: The thread-safe classes in Java Collections framework are Vector, Hashtable, and synchronized wrapper classes.

B: The thread-safe classes in Java Collections framework are ArrayList, HashMap, and unsynchronized wrapper classes.

C: The thread-safe classes in Java Collections framework are List, Map, and synchronized collection classes.


Correct Response: 1

Explanation: The thread-safe classes in Java Collections framework are Vector, Hashtable, and synchronized wrapper classes. This means that these classes are designed to be used in multithreaded environments, and provide synchronized access to their data to prevent data corruption or inconsistent results.





Q: How will you efficiently remove elements while iterating a Collection?


A: You can efficiently remove elements while iterating a Collection by using an Iterator and the remove() method.

B: You can efficiently remove elements while iterating a Collection by using a for loop and the remove() method.

C: You can efficiently remove elements while iterating a Collection by using a for each loop and the remove() method.


Correct Response: 1

Explanation: You can efficiently remove elements while iterating a Collection by using an Iterator and the remove() method. This allows you to remove elements from the Collection while iterating through it, without causing any ConcurrentModificationExceptions or other errors.





Q: How will you convert a List into an array of integers like- int[]?


A: You can convert a List into an array of integers using the toArray() method of the List interface and then casting the result to int[].

B: You can convert a List into an array of integers using the toArray() method of the ArrayList class and then casting the result to int[].

C: You can convert a List into an array of integers using the asList() method of the Arrays class and then casting the result to int[].


Correct Response: 1

Explanation: You can convert a List into an array of integers using the toArray() method of the List interface and then casting the result to int[]. This allows you to convert a List of Integer objects into an array of primitive integers, which can be useful when working with arrays in Java.





Q: How will you convert an array of primitive integers int[] to a List collection?


A: You can convert an array of primitive integers int[] to a List collection using the Arrays.asList() method.

B: You can convert an array of primitive integers int[] to a List collection using the List.of() method.

C: You can convert an array of primitive integers int[] to a List collection using the new ArrayList<>(Arrays.asList(array)) constructor.


Correct Response: 3

Explanation: You can convert an array of primitive integers int[] to a List collection using the new ArrayList<>(Arrays.asList(array)) constructor. This allows you to convert an array of primitive integers into a List of Integer objects, which can be useful when working with collections in Java.





Q: How will you run a filter on a Collection?


A: You can run a filter on a Collection using the filter() method of the Stream interface.

B: You can run a filter on a Collection using the filter() method of the Collection interface.

C: You can run a filter on a Collection using the filter() method of the List interface.


Correct Response: 1

Explanation: You can run a filter on a Collection using the filter() method of the Stream interface. This allows you to apply a filter to a Collection, and only keep the elements that match the filter criteria.





Q: How will you convert a List to a Set?


A: You can convert a List to a Set using the new HashSet<>(list) constructor.

B: You can convert a List to a Set using the new TreeSet<>(list) constructor.

C: You can convert a List to a Set using the addAll() method of the Set interface.


Correct Response: 1

Explanation: You can convert a List to a Set using either the new HashSet<>(list) constructor or the new TreeSet<>(list) constructor. This allows you to convert a List into a Set, which is a collection that does not allow duplicates and is unordered.





Q: How will you remove duplicate elements from an ArrayList?


A: You can remove duplicate elements from an ArrayList by using the removeDuplicates() method of the ArrayList class.

B: You can remove duplicate elements from an ArrayList by using the distinct() method of the Stream interface.

C: You can remove duplicate elements from an ArrayList by using the Set view of the List and then copying back to the List.


Correct Response: 3

Explanation: You can remove duplicate elements from an ArrayList by using the Set view of the List and then copying back to the List. This allows you to remove duplicates from an ArrayList by converting it to a Set, which does not allow duplicates, and then copying the unique elements back to the ArrayList.





Q: How can you maintain a Collection with elements in Sorted order?


A: You can maintain a Collection with elements in sorted order by using the sort() method of the Collections class.

B: You can maintain a Collection with elements in sorted order by using the sorted() method of the Stream interface.

C: You can maintain a Collection with elements in sorted order by using the TreeSet class.


Correct Response: 3

Explanation: You can maintain a Collection with elements in sorted order by using the TreeSet class. This allows you to store elements in a Collection in sorted order, based on the natural ordering of the elements or a custom ordering defined by a Comparator.





Q: What is the difference between Collections.emptyList() and creating new instance of Collection?


A: Collections.emptyList() returns a read-only list, while creating a new instance of Collection allows you to add elements to the Collection.

B: Collections.emptyList() returns a write-only list, while creating a new instance of Collection allows you to add elements to the Collection.

C: Collections.emptyList() returns a fixed-size list, while creating a new instance of Collection allows you to add or remove elements from the Collection.


Correct Response: 1

Explanation: Collections.emptyList() returns a read-only list, while creating a new instance of Collection allows you to add elements to the Collection. This means that Collections.emptyList() returns an empty list that cannot be modified, while creating a new instance of a Collection such as ArrayList or LinkedList allows you to add elements to the Collection.





Q: How will you copy elements from a Source List to another list?


A: You can copy elements from a Source List to another list by using the addAll() method of the Destination List.

B: You can copy elements from a Source List to another list by using the copy() method of the Collections class.

C: You can copy elements from a Source List to another list by using the new ArrayList<>(sourceList) constructor.


Correct Response: 1

Explanation: You can copy elements from a Source List to another list by using either the addAll() method of the Destination List or the new ArrayList<>(sourceList) constructor. This allows you to copy the elements from one List to another, creating a new List that is a copy of the original.





Q: What are the Java Collection classes that implement List interface?


A: ArrayList

B: LinkedList

C: Stack

D: Vector


Correct Response: 1, 2

Explanation: The Java Collection classes that implement List interface are ArrayList and LinkedList. ArrayList is a dynamic array implementation of the List interface, while LinkedList is a doubly linked list implementation of the List interface.





Q: What are the Java Collection classes that implement Set interface?


A: HashSet

B: TreeSet

C: LinkedHashSet

D: SortedSet


Correct Response: 1, 2, 3

Explanation: The Java Collection classes that implement Set interface are HashSet, TreeSet, and LinkedHashSet. HashSet is an unordered set implementation that uses a hash table for storage, TreeSet is a sorted set implementation that uses a tree data structure for storage, and LinkedHashSet is an ordered set implementation that uses a doubly linked list for storage.





Q: What is the difference between an Iterator and ListIterator in Java?


A: An Iterator is a basic interface for iterating over a collection, while a ListIterator is an extension of the Iterator interface that provides additional methods for bidirectional iteration over a List.

B: An Iterator is a basic interface for iterating over a List, while a ListIterator is an extension of the List interface that provides additional methods for bidirectional iteration over a collection.

C: An Iterator is a basic interface for iterating over a Set, while a ListIterator is an extension of the Set interface that provides additional methods for bidirectional iteration over a collection.


Correct Response: 1

Explanation: An Iterator is a basic interface for iterating over a collection, while a ListIterator is an extension of the Iterator interface that provides additional methods for bidirectional iteration over a List. This means that a ListIterator provides the ability to traverse a List in both forward and backward directions, as well as modify the List while iterating.





Q: What is the difference between Iterator and Enumeration?


A: Iterator is a more modern interface for iterating over a collection, while Enumeration is an older interface for iterating over a collection.

B: Iterator is a basic interface for iterating over a List, while Enumeration is a basic interface for iterating over an Array.

C: Iterator is a basic interface for iterating over a Set, while Enumeration is a basic interface for iterating over a Map.


Correct Response: 1

Explanation: Iterator is a more modern interface for iterating over a collection, while Enumeration is an older interface for iterating over a collection. This means that Iterator provides more functionality and is generally preferred over Enumeration, although Enumeration is still used in some older Java APIs.





Q: What is the difference between an ArrayList and a LinkedList data structure?


A: An ArrayList is an implementation of a dynamic array, while a LinkedList is an implementation of a doubly linked list.

B: An ArrayList is an implementation of a stack, while a LinkedList is an implementation of a queue.

C: An ArrayList is an implementation of a singly linked list, while a LinkedList is an implementation of a binary tree.


Correct Response: 1

Explanation: An ArrayList is an implementation of a dynamic array, while a LinkedList is an implementation of a doubly linked list. This means that ArrayList provides fast random access to elements, but slow insertion and deletion at the beginning of the list, while LinkedList provides fast insertion and deletion at the beginning of the list, but slow random access to elements.





Q: What is the difference between a Set and a Map in Java?


A: A Set is a collection of unique elements, while a Map is a collection of key-value pairs.

B: A Set is a collection of ordered elements, while a Map is a collection of unordered elements.

C: A Set is a collection of elements that allows duplicates, while a Map is a collection of elements that does not allow duplicates.


Correct Response: 1

Explanation: A Set is a collection of unique elements, while a Map is a collection of key-value pairs. This means that a Set stores a collection of individual elements without any associated data, while a Map stores a collection of key-value pairs, where each key is associated with a value.





Q: What is the use of a Dictionary class?


A: The Dictionary class is an abstract class that represents a key-value storage repository and is the parent class of Hashtable.

B: The Dictionary class is a concrete class that represents a collection of key-value pairs and is used to store data in a dictionary-like structure.

C: The Dictionary class is an interface that defines a set of methods for working with key-value pairs and is used to store data in a dictionary-like structure.


Correct Response: 1

Explanation: The Dictionary class is an abstract class that represents a key-value storage repository and is the parent class of Hashtable. This means that the Dictionary class provides a basic framework for storing and retrieving key-value pairs, while Hashtable is a concrete implementation of the Dictionary class that provides a synchronized, hash-table based implementation of the Map interface.





Q: What is the default size of load factor in a HashMap collection in Java?


A: The default size of the load factor in a HashMap collection in Java is 0.75.

B: The default size of the load factor in a HashMap collection in Java is 1.0.

C: The default size of the load factor in a HashMap collection in Java is 0.5.


Correct Response: 1

Explanation: The default size of the load factor in a HashMap collection in Java is 0.75. This means that when the number of elements in a HashMap exceeds the capacity of the HashMap multiplied by its load factor, the HashMap will be resized and rehashed to maintain an optimal performance.





Q: What is the significance of load factor in a HashMap in Java?


A: The load factor is used to determine the size of the hash table in a HashMap, and when the number of elements in the HashMap exceeds the capacity of the hash table multiplied by the load factor, the HashMap will be resized and rehashed to maintain optimal performance.

B: The load factor is used to determine the order in which elements are stored in a HashMap, and when the number of elements in the HashMap exceeds the capacity of the hash table multiplied by the load factor, the elements will be reordered.

C: The load factor is used to determine the hash function used in a HashMap, and when the number of elements in the HashMap exceeds the capacity of the hash table multiplied by the load factor, the hash function will be changed.


Correct Response: 1

Explanation: The load factor is used to determine the size of the hash table in a HashMap, and when the number of elements in the HashMap exceeds the capacity of the hash table multiplied by the load factor, the HashMap will be resized and rehashed to maintain optimal performance. This means that the load factor determines the trade-off between the cost of resizing the hash table and the cost of hash collisions in the HashMap.





Q: What are the major differences between a HashSet and a HashMap?


A: The major difference between a HashSet and a HashMap is that a HashSet stores a collection of unique elements without any associated data, while a HashMap stores a collection of key-value pairs, where each key is associated with a value.

B: The major difference between a HashSet and a HashMap is that a HashSet stores a collection of elements in a sorted order, while a HashMap stores a collection of elements in an unsorted order.

C: The major difference between a HashSet and a HashMap is that a HashSet stores a collection of elements that allows duplicates, while a HashMap stores a collection of elements that does not allow duplicates.


Correct Response: 1

Explanation: The major difference between a HashSet and a HashMap is that a HashSet stores a collection of unique elements without any associated data, while a HashMap stores a collection of key-value pairs, where each key is associated with a value. This means that a HashSet provides a simple way to store a collection of unique elements, while a HashMap provides a way to associate data with each element in the collection.





Q: What are the similarities between a HashSet and a HashMap in Java?


A: Both store elements as key-value pairs.

B: Both do not allow duplicate elements.

C: Both use hashCode and equals methods for element storage and retrieval.

D: Both are part of the java.util package.


Correct Response: 2, 3

Explanation: Both HashSet and HashMap store elements as key-value pairs and use the hashCode and equals methods for element storage and retrieval. They also do not allow duplicate elements.





Q: What is the reason for overriding equals() method?


A: To compare the contents of two objects.

B: To compare the memory locations of two objects.

C: To compare the hashcodes of two objects.


Correct Response: 1

Explanation: The equals() method is used to compare the contents of two objects. By default, the equals() method in Java compares the memory locations of two objects. However, it can be overridden to compare the contents of two objects, making it easier to determine if two objects are equal.





Q: How can we synchronize the elements of a List, a Set or a Map?


A: By using the synchronized keyword.

B: By using the volatile keyword.

C: By using the transient keyword.


Correct Response: 1

Explanation: To synchronize the elements of a List, a Set, or a Map, you can use the synchronized keyword. This ensures that only one thread can access the collection at a time, preventing data inconsistencies and race conditions.





Q: What is Hash Collision? How Java handles hash-collision in HashMap?


A: Hash collision is when two keys have the same hashCode value. Java handles hash-collision by storing both keys in the same bucket.

B: Hash collision is when two keys have different hashCode values. Java handles hash-collision by storing both keys in different buckets.

C: Hash collision does not occur in Java.


Correct Response: 1

Explanation: Hash collision is when two keys have the same hashCode value. Java handles hash-collision by storing both keys in the same bucket, using a linked list to store all the keys that have the same hashCode. When a key is searched, the linked list is traversed to find the correct key.





Q: What are the Hash Collision resolution techniques?


A: Separate Chaining

B: Open Addressing

C: Linear Probing

D: Double Hashing


Correct Response: 1, 2

Explanation: Separate Chaining and Open Addressing are two techniques used to resolve hash collisions in HashMap. Separate Chaining uses linked lists to store all the keys with the same hashCode, while Open Addressing involves finding the next available slot in the hash table to store the key.





Q: What is the difference between Queue and Stack data structures?


A: Queue follows First-In-First-Out (FIFO) and Stack follows Last-In-First-Out (LIFO).

B: Queue follows Last-In-First-Out (LIFO) and Stack follows First-In-First-Out (FIFO).

C: Both Queue and Stack follow First-In-First-Out (FIFO).


Correct Response: 1

Explanation: Queue follows First-In-First-Out (FIFO) and Stack follows Last-In-First-Out (LIFO). In Queue, the first element added to the queue is the first one to be removed, while in Stack, the last element added to the stack is the first one to be removed.





Q: What is an Iterator in Java?


A: An interface used to traverse a collection of objects.

B: A class used to store objects.

C: A method used to remove elements from a collection.


Correct Response: 1

Explanation: An Iterator is an interface in Java used to traverse a collection of objects. It allows you to access the elements of a collection one by one, without knowing the underlying structure of the collection.





Q: What is the difference between Iterator and Enumeration in Java?


A: Iterator has a remove() method, while Enumeration does not.

B: Enumeration has a remove() method, while Iterator does not.

C: Both Iterator and Enumeration have a remove() method.


Correct Response: 1

Explanation: Iterator has a remove() method, while Enumeration does not. Iterator is a more advanced version of Enumeration, offering more functionality and flexibility when working with collections.





Q: What is the design pattern used in the implementation of Enumeration in Java?


A: Adapter pattern.

B: Singleton pattern.

C: Factory pattern.

D: Observer pattern.


Correct Response: 1

Explanation: The implementation of Enumeration in Java uses the Adapter pattern, which is used to convert the interface of a class into another interface that a client expects. In this case, Enumeration is used to adapt the legacy collections to the new collection framework.





Q: Which methods do we need to override to use an object as key in a HashMap?


A: hashCode()

B: equals()

C: toString()

D: compareTo()


Correct Response: 1, 2

Explanation: To use an object as a key in a HashMap, we need to override the hashCode() and equals() methods. The hashCode() method is used to determine the bucket location for storing the key-value pair, while the equals() method is used to compare the keys for equality.





Q: How will you reverse a List in Java?


A: By using the reverse() method of the Collections class.

B: By using the sort() method of the Collections class.

C: By using the reverseOrder() method of the Comparator interface.


Correct Response: 1

Explanation: To reverse a List in Java, you can use the reverse() method of the Collections class. This method takes a List as an argument and returns a reversed version of the List.





Q: How will you convert an array of String objects into a List?


A: By using the asList() method of the Arrays class.

B: By using the toList() method of the Arrays class.

C: By using the toArray() method of the List class.


Correct Response: 1

Explanation: To convert an array of String objects into a List, you can use the asList() method of the Arrays class. This method takes an array as an argument and returns a List view of the array.





Q: What is the difference between peek(), poll() and remove() methods of Queue interface in java?


A: peek() returns the head of the queue without removing it, poll() removes and returns the head of the queue, and remove() also removes and returns the head of the queue.

B: peek() removes and returns the head of the queue, poll() returns the head of the queue without removing it, and remove() also removes and returns the head of the queue.

C: peek() returns the head of the queue, poll() and remove() both remove and return the head of the queue.


Correct Response: 3

Explanation: peek() returns the head of the queue without removing it, poll() removes and returns the head of the queue, and remove() also removes and returns the head of the queue. The difference between poll() and remove() is that poll() returns null if the queue is empty, while remove() throws an exception in this case.





Q: What is the difference between Array and ArrayList in Java?


A: An array is a fixed-size data structure, while an ArrayList is a dynamic-size data structure.

B: An ArrayList is a fixed-size data structure, while an array is a dynamic-size data structure.

C: Both Array and ArrayList have the same size.


Correct Response: 1

Explanation: An array is a fixed-size data structure in Java, meaning its size cannot be changed once it is created. On the other hand, an ArrayList is a dynamic-size data structure, meaning its size can be changed dynamically as elements are added or removed.





Q: How will you insert, delete and retrieve elements from a HashMap collection in Java?


A: You can use the put(), remove(), and get() methods respectively.

B: You can use the add(), delete(), and retrieve() methods respectively.

C: You can use the insert(), delete(), and retrieve() methods respectively.


Correct Response: 1

Explanation: To insert, delete, and retrieve elements from a HashMap collection in Java, you can use the put(), remove(), and get() methods respectively. The put() method is used to insert a key-value pair into the HashMap, the remove() method is used to remove a key-value pair, and the get() method is used to retrieve the value associated with a given key.





Q: What are the main differences between HashMap and ConcurrentHashMap in Java?


A: HashMap is not thread-safe, while ConcurrentHashMap is thread-safe.

B: ConcurrentHashMap is not thread-safe, while HashMap is thread-safe.

C: Both HashMap and ConcurrentHashMap are thread-safe.


Correct Response: 1

Explanation: HashMap is not thread-safe, meaning multiple threads can access and modify the HashMap simultaneously, leading to data inconsistencies and race conditions. ConcurrentHashMap, on the other hand, is thread-safe, meaning only one thread can access and modify the ConcurrentHashMap at a time, preventing data inconsistencies and race conditions.





Q: What is the increasing order of performance for following collection classes in Java?


A: ArrayList, LinkedList, Vector

B: Vector, LinkedList, ArrayList

C: LinkedList, ArrayList, Vector


Correct Response: 1

Explanation: The increasing order of performance for the collection classes in Java is ArrayList, LinkedList, and Vector. ArrayList is the fastest, followed by LinkedList, and Vector is the slowest due to its synchronized nature.





Q: Why does Map interface not extend Collection interface in Java?


A: Because Map is a key-value based data structure, while Collection is a group of objects.

B: Because Map is a group of objects, while Collection is a key-value based data structure.

C: Both Map and Collection are key-value based data structures.


Correct Response: 1

Explanation: The Map interface does not extend the Collection interface in Java because Map is a key-value based data structure, while Collection is a group of objects. The Map interface provides a way to store elements as key-value pairs, while the Collection interface provides a way to store a group of objects.





Q: What are the different ways to iterate elements of a list in Java?


A: For-loop

B: Enhanced For-loop

C: Iterator

D: ListIterator


Correct Response: 1, 2, 3

Explanation: There are three different ways to iterate elements of a list in Java: for-loop, enhanced for-loop, and Iterator. The for-loop and enhanced for-loop are used to traverse the elements of a list sequentially, while the Iterator is used to traverse the elements of a list one by one.





Q: What is CopyOnWriteArrayList? How it is different from ArrayList in Java?


A: CopyOnWriteArrayList is a thread-safe version of ArrayList, meaning only one thread can modify the list at a time. ArrayList is not thread-safe, meaning multiple threads can modify the list simultaneously.

B: ArrayList is a thread-safe version of CopyOnWriteArrayList, meaning only one thread can modify the list at a time. CopyOnWriteArrayList is not thread-safe, meaning multiple threads can modify the list simultaneously.

C: Both ArrayList and CopyOnWriteArrayList are thread-safe, meaning only one thread can modify the list at a time.


Correct Response: 1

Explanation: CopyOnWriteArrayList is a thread-safe version of ArrayList, meaning only one thread can modify the list at a time. Unlike ArrayList, where multiple threads can modify the list simultaneously, leading to data inconsistencies and race conditions, CopyOnWriteArrayList creates a new copy of the list every time it is modified, ensuring that the list remains consistent and thread-safe.





Q: How remove() method is implemented in a HashMap?


A: By using the hashCode() and equals() methods to determine the correct key-value pair to remove.

B: By using the indexOf() method to determine the correct key-value pair to remove.

C: By using the get() method to determine the correct key-value pair to remove.


Correct Response: 1

Explanation: The remove() method in a HashMap is implemented by using the hashCode() and equals() methods to determine the correct key-value pair to remove. The hashCode() method is used to determine the bucket location for storing the key-value pair, while the equals() method is used to compare the keys for equality.





Q: What is BlockingQueue in Java Collections?


A: A queue that blocks the operation until it can be executed.

B: A queue that does not block the operation.

C: A list that blocks the operation until it can be executed.


Correct Response: 1

Explanation: A BlockingQueue is a queue in Java Collections that blocks the operation until it can be executed. For example, if a thread tries to insert an element into a full BlockingQueue, it will wait until space becomes available. Similarly, if a thread tries to remove an element from an empty BlockingQueue, it will wait until an element becomes available.





Q: How is TreeMap class implemented in Java?


A: TreeMap is implemented as a Red-Black tree.

B: TreeMap is implemented as a Binary Search Tree.

C: TreeMap is implemented as a Heap.


Correct Response: 1

Explanation: The TreeMap class in Java is implemented as a Red-Black tree. A Red-Black tree is a type of self-balancing binary search tree, where each node has a color attribute, either red or black, and the tree satisfies certain properties to ensure that the height of the tree is logarithmic in the number of nodes.





Q: What is the difference between Fail-fast and Fail-safe iterator in Java?


A: Fail-fast iterator throws a ConcurrentModificationException if the underlying collection is modified during iteration, while fail-safe iterator does not.

B: Fail-safe iterator throws a ConcurrentModificationException if the underlying collection is modified during iteration, while fail-fast iterator does not.

C: Both Fail-fast and Fail-safe iterator do not throw a ConcurrentModificationException if the underlying collection is modified during iteration.


Correct Response: 1

Explanation: Fail-fast iterator throws a ConcurrentModificationException if the underlying collection is modified during iteration, while fail-safe iterator does not. Fail-fast iterator works on the original collection, while fail-safe iterator works on a copy of the collection.





Q: How does ConcurrentHashMap work in Java?


A: ConcurrentHashMap uses multiple locks to lock different parts of the map, allowing multiple threads to read and write to the map simultaneously.

B: ConcurrentHashMap uses a single lock to lock the entire map, allowing only one thread to read and write to the map at a time.

C: ConcurrentHashMap uses no locks, allowing multiple threads to read and write to the map simultaneously.


Correct Response: 1

Explanation: ConcurrentHashMap uses multiple locks to lock different parts of the map, allowing multiple threads to read and write to the map simultaneously. By dividing the map into segments and locking each segment separately, ConcurrentHashMap provides a high level of concurrency, even when the map is being modified frequently.





Q: What is the importance of hashCode() and equals() methods?


A: The hashCode() and equals() methods are used to determine object equality and to store objects in collections such as HashMap and HashSet.

B: The hashCode() and equals() methods are used to determine object identity and to store objects in collections such as ArrayList and LinkedList.

C: The hashCode() and equals() methods are used to determine object size and to store objects in collections such as Stack and Queue.


Correct Response: 1

Explanation: The hashCode() and equals() methods are important in Java because they are used to determine object equality and to store objects in collections such as HashMap and HashSet. The hashCode() method is used to determine the hash code of an object, which is used to index the object in a collection, while the equals() method is used to compare two objects for equality.





Q: What is the contract of hashCode() and equals() methods in Java?


A: The hashCode() method should return the same value for two equal objects, and the equals() method should return true for two objects with the same hash code.

B: The hashCode() method should return a different value for two equal objects, and the equals() method should return false for two objects with the same hash code.

C: The hashCode() method should return a random value, and the equals() method should return true for all objects.


Correct Response: 1

Explanation: The contract of the hashCode() and equals() methods in Java is that the hashCode() method should return the same value for two equal objects, and the equals() method should return true for two objects with the same hash code. This ensures that objects that are equal are stored in the same bucket in collections such as HashMap and HashSet, and can be retrieved and compared efficiently.





Q: What is an EnumSet in Java?


A: An EnumSet is a specialized Set implementation for use with enum types.

B: An EnumSet is a specialized Map implementation for use with enum types.

C: An EnumSet is a specialized List implementation for use with enum types.


Correct Response: 1

Explanation: An EnumSet is a specialized Set implementation in Java for use with enum types. It is optimized for use with enum types and provides a high-performance alternative to regular Set implementations for enum types.





Q: What are the main Concurrent Collection classes in Java?


A: ConcurrentHashMap

B: CopyOnWriteArrayList

C: BlockingQueue

D: SynchronizedList


Correct Response: 1, 2, 3

Explanation: The main concurrent collection classes in Java are ConcurrentHashMap, CopyOnWriteArrayList, and BlockingQueue. These classes provide thread-safe implementations of common collection interfaces, allowing multiple threads to access and modify the collections simultaneously without data inconsistencies or race conditions.





Q: How will you convert a Collection to SynchronizedCollection in Java?


A: By using the synchronizedCollection() method of the Collections class.

B: By using the synchronizedList() method of the Collections class.

C: By using the synchronizedMap() method of the Collections class.


Correct Response: 1

Explanation: You can convert a Collection to a SynchronizedCollection in Java by using the synchronizedCollection() method of the Collections class. The synchronizedCollection() method returns a thread-safe Collection backed by the specified Collection. All access to the Collection is synchronized, ensuring that multiple threads can access the Collection simultaneously without data inconsistencies or race conditions.





Q: How IdentityHashMap is different from a regular Map in Java?


A: IdentityHashMap uses the == operator to compare keys, while a regular Map uses the equals() method to compare keys.

B: IdentityHashMap uses the equals() method to compare keys, while a regular Map uses the == operator to compare keys.

C: IdentityHashMap and a regular Map both use the == operator to compare keys.


Correct Response: 1

Explanation: IdentityHashMap is different from a regular Map in Java because it uses the == operator to compare keys, while a regular Map uses the equals() method to compare keys. This means that two keys are considered equal in an IdentityHashMap if they are the same object, while in a regular Map they are considered equal if they have the same value.





Q: What is the main use of IdentityHashMap?


A: The main use of IdentityHashMap is to map the identity of objects, rather than their value.

B: The main use of IdentityHashMap is to map the value of objects, rather than their identity.

C: The main use of IdentityHashMap is to map both the identity and value of objects.


Correct Response: 1

Explanation: The main use of IdentityHashMap in Java is to map the identity of objects, rather than their value. This makes IdentityHashMap suitable for use cases where the == operator is used to compare keys, rather than the equals() method.





Q: How can we improve the performance of IdentityHashMap?


A: By using smaller initial capacity and load factor values.

B: By using larger initial capacity and load factor values.

C: By using the same initial capacity and load factor values for all maps.


Correct Response: 1

Explanation: We can improve the performance of an IdentityHashMap by using smaller initial capacity and load factor values. By using smaller initial capacity and load factor values, we can reduce the number of rehashes required, which can be an expensive operation, and improve the overall performance of the map.





Q: Is IdentityHashMap thread-safe?


A: No, IdentityHashMap is not thread-safe.

B: Yes, IdentityHashMap is thread-safe.

C: It depends on the implementation.


Correct Response: 1

Explanation: No, IdentityHashMap is not thread-safe. Multiple threads can access and modify the map simultaneously, leading to data inconsistencies and race conditions. To make IdentityHashMap thread-safe, it must be synchronized manually or by using a thread-safe implementation such as ConcurrentHashMap.





Q: What is a WeakHashMap in Java?


A: A WeakHashMap is a Map implementation that uses weak keys, allowing keys to be garbage collected if they are no longer referenced.

B: A WeakHashMap is a Map implementation that uses strong keys, preventing keys from being garbage collected.

C: A WeakHashMap is a Map implementation that uses weak values, allowing values to be garbage collected if they are no longer referenced.


Correct Response: 1

Explanation: A WeakHashMap is a Map implementation in Java that uses weak keys, allowing keys to be garbage collected if they are no longer referenced. This makes WeakHashMap suitable for use cases where it is necessary to store keys that may not always be strongly reachable, without preventing them from being garbage collected.





Q: How can you make a Collection class read-only in Java?


A: By using the unmodifiableCollection() method of the Collections class.

B: By using the synchronizedCollection() method of the Collections class.

C: By using the readOnlyCollection() method of the Collections class.


Correct Response: 1

Explanation: You can make a Collection class read-only in Java by using the unmodifiableCollection() method of the Collections class. The unmodifiableCollection() method returns a Collection that cannot be modified. Attempts to modify the Collection result in an UnsupportedOperationException being thrown.





Q: When is UnsupportedOperationException thrown in Java?


A: UnsupportedOperationException is thrown when an unsupported operation is attempted on a Collection.

B: UnsupportedOperationException is thrown when an supported operation is attempted on a Collection.

C: UnsupportedOperationException is thrown when an error occurs during an operation on a Collection.


Correct Response: 1

Explanation: UnsupportedOperationException is thrown in Java when an unsupported operation is attempted on a Collection. For example, if a Collection is made read-only using the unmodifiableCollection() method, and an attempt is made to modify the Collection, an UnsupportedOperationException will be thrown.





Q: What is the difference between Synchronized Collection and Concurrent Collection?


A: Synchronized Collection is a Collection that is synchronized for thread-safety, while Concurrent Collection is a Collection that is designed for high performance and thread-safety.

B: Synchronized Collection is a Collection that is designed for high performance and thread-safety, while Concurrent Collection is a Collection that is synchronized for thread-safety.

C: Both Synchronized Collection and Concurrent Collection are Collections that are synchronized for thread-safety.


Correct Response: 2

Explanation: The difference between a Synchronized Collection and a Concurrent Collection is that a Synchronized Collection is a Collection that is synchronized for thread-safety, while a Concurrent Collection is a Collection that is designed for high performance and thread-safety. A Synchronized Collection provides basic thread-safety by synchronizing access to the Collection, while a Concurrent Collection provides high performance and thread-safety by using advanced techniques such as lock-free data structures and fine-grained locking.





Q: What is the scenario to use ConcurrentHashMap in Java?


A: The scenario to use ConcurrentHashMap in Java is when multiple threads need to access and modify the Map simultaneously without data inconsistencies or race conditions.

B: The scenario to use ConcurrentHashMap in Java is when a single thread needs to access and modify the Map.

C: The scenario to use ConcurrentHashMap in Java is when the Map is never modified.


Correct Response: 1

Explanation: The scenario to use ConcurrentHashMap in Java is when multiple threads need to access and modify the Map simultaneously without data inconsistencies or race conditions. ConcurrentHashMap provides high performance and thread-safety by using advanced techniques such as lock-free data structures and fine-grained locking.





Q: How will you create an empty Map in Java?


A: By using the emptyMap() method of the Collections class.

B: By using the newMap() method of the Collections class.

C: By using the emptyList() method of the Collections class.


Correct Response: 1

Explanation: You can create an empty Map in Java by using the emptyMap() method of the Collections class. The emptyMap() method returns an empty Map, which cannot be modified. Attempts to modify the Map result in an UnsupportedOperationException being thrown.





Q: What is the difference between remove() method of Collection and remove() method of Iterator?


A: The remove() method of Collection removes the specified element from the Collection, while the remove() method of Iterator removes the current element from the Collection.

B: The remove() method of Collection removes the current element from the Collection, while the remove() method of Iterator removes the specified element from the Collection.

C: Both the remove() method of Collection and the remove() method of Iterator remove the specified element from the Collection.


Correct Response: 2

Explanation: The difference between the remove() method of Collection and the remove() method of Iterator is that the remove() method of Collection removes the specified element from the Collection, while the remove() method of Iterator removes the current element from the Collection. The remove() method of Iterator is used to remove elements while iterating over a Collection, while the remove() method of Collection is used to remove elements from the Collection.





Q: Between an Array and ArrayList, which one is the preferred collection for storing objects?


A: ArrayList is the preferred collection for storing objects, because it is dynamic and resizable, while an Array is fixed-size.

B: Array is the preferred collection for storing objects, because it is efficient and fast, while an ArrayList is slow and has overhead.

C: Both Array and ArrayList are equally preferred for storing objects, depending on the specific requirements of the application.


Correct Response: 1

Explanation: ArrayList is the preferred collection for storing objects, because it is dynamic and resizable, while an Array is fixed-size. ArrayList provides a dynamic and flexible data structure for storing objects, allowing elements to be added, removed, and modified dynamically, without the need to create a new Array. On the other hand, an Array is a fixed-size data structure that is efficient and fast, but does not provide the same level of flexibility as an ArrayList.





Q: Is it possible to replace Hashtable with ConcurrentHashMap in Java?


A: Yes, it is possible to replace Hashtable with ConcurrentHashMap in Java, as ConcurrentHashMap provides the same thread-safety guarantees as Hashtable, but with better performance and scalability.

B: No, it is not possible to replace Hashtable with ConcurrentHashMap in Java, as Hashtable provides better thread-safety guarantees than ConcurrentHashMap.

C: It depends on the specific requirements of the application.


Correct Response: 1

Explanation: Yes, it is possible to replace Hashtable with ConcurrentHashMap in Java, as ConcurrentHashMap provides the same thread-safety guarantees as Hashtable, but with better performance and scalability. ConcurrentHashMap provides high performance and thread-safety by using advanced techniques such as lock-free data structures and fine-grained locking, while Hashtable provides thread-safety by synchronizing access to the data structure.





Q: How CopyOnWriteArrayList class is different from ArrayList and Vector Classes?


A: CopyOnWriteArrayList is different from ArrayList and Vector Classes, because it provides thread-safety by copying the underlying data structure for every modification operation, while ArrayList and Vector Classes provide thread-safety through synchronization.

B: CopyOnWriteArrayList is different from ArrayList and Vector Classes, because it provides better performance and scalability by using lock-free data structures, while ArrayList and Vector Classes provide basic thread-safety through synchronization.

C: CopyOnWriteArrayList is different from ArrayList and Vector Classes, because it does not provide thread-safety, while ArrayList and Vector Classes provide thread-safety through synchronization.


Correct Response: 1

Explanation: CopyOnWriteArrayList is different from ArrayList and Vector Classes, because it provides thread-safety by copying the underlying data structure for every modification operation, while ArrayList and Vector Classes provide thread-safety through synchronization. This makes CopyOnWriteArrayList suitable for use cases where it is necessary to provide thread-safety for read-intensive data structures, while maintaining high performance.





Q: Why ListIterator has add() method but Iterator does not have?


A: ListIterator has add() method but Iterator does not have, because ListIterator is an extension of Iterator that provides additional functionality for adding elements to a List, while Iterator is a basic interface for iterating over a Collection.

B: ListIterator has add() method but Iterator does not have, because ListIterator is a more advanced version of Iterator, while Iterator is a basic interface for iterating over a Collection.

C: ListIterator has add() method but Iterator does not have, because ListIterator is used for iterating over a List, while Iterator is used for iterating over a Collection.


Correct Response: 1

Explanation: ListIterator has add() method but Iterator does not have, because ListIterator is an extension of Iterator that provides additional functionality for adding elements to a List, while Iterator is a basic interface for iterating over a Collection. ListIterator provides bidirectional iteration over a List, as well as the ability to add elements to the List while iterating, while Iterator provides unidirectional iteration over a Collection.





Q: Why do we sometimes get ConcurrentModificationException during iteration?


A: We sometimes get ConcurrentModificationException during iteration, because the underlying data structure was modified while the iteration was in progress, causing the iteration to become invalid.

B: We sometimes get ConcurrentModificationException during iteration, because the underlying data structure was not modified while the iteration was in progress, causing the iteration to become invalid.

C: We sometimes get ConcurrentModificationException during iteration, because the iteration was not properly initialized.


Correct Response: 1

Explanation: We sometimes get ConcurrentModificationException during iteration, because the underlying data structure was modified while the iteration was in progress, causing the iteration to become invalid. This can happen if multiple threads access and modify the same data structure simultaneously, or if the data structure is modified within the iteration loop. ConcurrentModificationException is thrown to prevent data inconsistencies or race conditions.





Q: How will you convert a Map to a List in Java?


A: By using the values() method of the Map to get a Collection of the values in the Map, and then converting the Collection to a List using the List constructor.

B: By using the keys() method of the Map to get a Set of the keys in the Map, and then converting the Set to a List using the List constructor.

C: By using the entrySet() method of the Map to get a Set of the entries in the Map, and then converting the Set to a List using the List constructor.


Correct Response: 1

Explanation: You can convert a Map to a List in Java by using the values() method of the Map to get a Collection of the values in the Map, and then converting the Collection to a List using the List constructor. The values() method returns a Collection of the values in the Map, which can be converted to a List using the List constructor.





Q: How can we create a Map with reverse view and lookup in Java?


A: By using the reverseOrder() method of the Collections class to create a reverse view of the Map, and then using the TreeMap constructor to create a TreeMap that is sorted in reverse order.

B: By using the reverse() method of the Collections class to create a reverse view of the Map, and then using the HashMap constructor to create a HashMap that is sorted in reverse order.

C: By using the reverse() method of the Map class to create a reverse view of the Map, and then using the LinkedHashMap constructor to create a LinkedHashMap that is sorted in reverse order.


Correct Response: 1

Explanation: You can create a Map with reverse view and lookup in Java by using the reverseOrder() method of the Collections class to create a reverse view of the Map, and then using the TreeMap constructor to create a TreeMap that is sorted in reverse order. The reverseOrder() method returns a Comparator that can be used to sort the Map in reverse order, while the TreeMap constructor creates a Map that is sorted based on the Comparator.





Q: How will you create a shallow copy of a Map?


A: By using the clone() method of the Map class to create a shallow copy of the Map.

B: By using the copyOf() method of the Map class to create a shallow copy of the Map.

C: By using the copyOfRange() method of the Arrays class to create a shallow copy of the Map.


Correct Response: 1

Explanation: You can create a shallow copy of a Map in Java by using the clone() method of the Map class. The clone() method creates a shallow copy of the Map, which means that the new Map will refer to the same objects as the original Map, but will be a separate instance.





Q: Why we cannot create a generic array in Java?


A: We cannot create a generic array in Java, because arrays in Java are statically typed, and the type information for generic types is only available at runtime, not at compile time.

B: We cannot create a generic array in Java, because arrays in Java are dynamically typed, and the type information for generic types is only available at runtime, not at compile time.

C: We cannot create a generic array in Java, because arrays in Java are not compatible with generic types.


Correct Response: 1

Explanation: We cannot create a generic array in Java, because arrays in Java are statically typed, and the type information for generic types is only available at runtime, not at compile time. This means that the type information for generic types is not available to the compiler, and therefore it is not possible to create an array of generic types.





Q: What is a PriorityQueue in Java?


A: A PriorityQueue is a collection class in Java that provides a priority-based ordering of elements, where elements are ordered according to their priority.

B: A PriorityQueue is a collection class in Java that provides a random-based ordering of elements, where elements are ordered randomly.

C: A PriorityQueue is a collection class in Java that provides a time-based ordering of elements, where elements are ordered according to the time they were added.


Correct Response: 1

Explanation: A PriorityQueue is a collection class in Java that provides a priority-based ordering of elements, where elements are ordered according to their priority. The elements in a PriorityQueue are ordered according to their natural ordering, or according to a Comparator that is provided at the time the PriorityQueue is created. The highest-priority element is always at the head of the queue, and can be retrieved using the poll() or remove() methods.





Q: What are the important points to remember while using Java Collections Framework?


A: It is important to remember that Java Collections Framework provides a powerful set of classes and interfaces for working with collections of objects, but they should be used with care to ensure that they are used efficiently and correctly.

B: It is important to remember that Java Collections Framework provides a limited set of classes and interfaces for working with collections of objects, and they should be used with caution to ensure that they are used efficiently and correctly.

C: It is important to remember that Java Collections Framework provides a weak set of classes and interfaces for working with collections of objects, and they should be used with care to ensure that they are used efficiently and correctly.


Correct Response: 1

Explanation: It is important to remember that Java Collections Framework provides a powerful set of classes and interfaces for working with collections of objects, but they should be used with care to ensure that they are used efficiently and correctly. This includes choosing the right collection class for the task, using the collection classes in a thread-safe manner, using efficient algorithms for searching and sorting elements, and avoiding performance issues such as ConcurrentModificationException.





Q: How can we pass a Collection as an argument to a method and ensure that method will not be able to modify it?


A: By passing a read-only Collection, such as an instance of Collections.unmodifiableCollection(), to the method.

B: By passing a synchronized Collection, such as an instance of Collections.synchronizedCollection(), to the method.

C: By passing a copy of the Collection, such as an instance of a new ArrayList created from the original Collection, to the method.


Correct Response: 1

Explanation: You can pass a Collection as an argument to a method and ensure that the method will not be able to modify it by passing a read-only Collection, such as an instance of Collections.unmodifiableCollection(), to the method. The unmodifiableCollection() method returns a Collection that cannot be modified, and any attempt to modify the Collection will result in an UnsupportedOperationException being thrown.





Q: Can you explain how HashMap works in Java?


A: HashMap uses an array to store key-value pairs.

B: HashMap uses a linked list to store key-value pairs.

C: HashMap uses a tree to store key-value pairs.

D: HashMap uses a hash table to store key-value pairs.


Correct Response: 4

Explanation: HashMap uses a hash table to store key-value pairs. It works by hashing the keys to determine the index at which the value can be stored. This allows for efficient insertions, deletions, and lookups of values based on keys.





Q: Can you explain how HashSet is implemented in Java?


A: HashSet uses an array to store elements.

B: HashSet uses a linked list to store elements.

C: HashSet uses a tree to store elements.

D: HashSet uses a hash table to store elements.


Correct Response: 4

Explanation: HashSet uses a hash table to store elements. It works by hashing the elements to determine the index at which they can be stored. This allows for efficient insertions, deletions, and lookups of elements.





Q: What is a NavigableMap in Java?


A: A Map that provides navigation methods to traverse the map.

B: A Map that doesn't provide navigation methods.

C: A Map that can only be traversed in one direction.


Correct Response: 1

Explanation: NavigableMap is a subinterface of Map that provides navigation methods to traverse the map. It allows you to retrieve elements based on their position relative to other elements in the map.





Q: What is the difference between descendingKeySet() and descendingMap() methods of NavigableMap?


A: descendingKeySet() returns a set of keys in descending order, while descendingMap() returns a map in descending order.

B: descendingKeySet() returns a map in descending order, while descendingMap() returns a set of keys in descending order.

C: Both methods return the same result.


Correct Response: 1

Explanation: descendingKeySet() returns a set of keys in descending order, while descendingMap() returns a map in descending order. The set of keys can be used to access the values in the map, while the descending map provides direct access to the key-value pairs in descending order.





Q: What is the advantage of NavigableMap over Map?


A: NavigableMap provides navigation methods to traverse the map.

B: NavigableMap allows you to store elements in descending order.

C: NavigableMap provides better performance compared to Map.


Correct Response: 1

Explanation: NavigableMap provides navigation methods to traverse the map, allowing you to retrieve elements based on their position relative to other elements in the map. This makes it more flexible and efficient than the regular Map interface.





Q: What is the difference between headMap(), tailMap() and subMap() methods of NavigableMap?


A: headMap() returns a map with elements less than the specified key, tailMap() returns a map with elements greater than or equal to the specified key, and subMap() returns a map with elements between two specified keys.

B: headMap() returns a map with elements greater than the specified key, tailMap() returns a map with elements less than or equal to the specified key, and subMap() returns a map with elements outside two specified keys.

C: headMap() and tailMap() return the same result, and subMap() returns a map with all the elements.


Correct Response: 1

Explanation: headMap() returns a map with elements less than the specified key, tailMap() returns a map with elements greater than or equal to the specified key, and subMap() returns a map with elements between two specified keys. This allows you to retrieve elements based on their position relative to other elements in the map.





Q: How will you sort objects by Natural order in a Java List?


A: By implementing the Comparable interface in the objects and using the Collections.sort() method.

B: By implementing the Comparator interface in the objects and using the Collections.sort() method.

C: By using the Arrays.sort() method.


Correct Response: 1

Explanation: By implementing the Comparable interface in the objects and using the Collections.sort() method, you can sort objects by their natural order in a Java List. The natural order is determined by the compareTo() method of the Comparable interface.





Q: How can we get a Stream from a List in Java?


A: By using the stream() method of the List interface.

B: By using the parallelStream() method of the List interface.

C: By using the toArray() method of the List interface.


Correct Response: 1

Explanation: By using the stream() method of the List interface, you can get a Stream from a List in Java. The stream() method returns a sequential Stream with the elements of the List.





Q: Can we get a Map from a Stream in Java?


A: Yes, by using the collect() method of the Stream interface.

B: No, it's not possible to get a Map from a Stream in Java.

C: Yes, by using the toArray() method of the Stream interface.


Correct Response: 1

Explanation: Yes, you can get a Map from a Stream in Java by using the collect() method of the Stream interface. The collect() method allows you to collect the elements of a Stream into a Map using a collector provided by the Collectors class.





Q: What are the popular implementations of Deque in Java?


A: ArrayDeque

B: LinkedList

C: Stack

D: Queue


Correct Response: 1, 2

Explanation: ArrayDeque and LinkedList are popular implementations of the Deque interface in Java. ArrayDeque is an array-based implementation that provides better performance for add and remove operations at both ends of the deque, while LinkedList is a linked list-based implementation that provides better performance for add and remove operations in the middle of the deque.





Q: What is the difference between a HashMap and a TreeMap in Java?


A: HashMap stores elements in an unsorted and unordered manner, while TreeMap stores elements in a sorted and ordered manner.

B: HashMap stores elements in a sorted and ordered manner, while TreeMap stores elements in an unsorted and unordered manner.

C: Both HashMap and TreeMap store elements in the same manner.


Correct Response: 1

Explanation: HashMap stores elements in an unsorted and unordered manner, while TreeMap stores elements in a sorted and ordered manner based on the natural ordering of its keys or a custom comparator. This makes TreeMap suitable for use cases where you need to access elements in a specific order.





Q: What is the difference between a HashSet and a TreeSet in Java?


A: HashSet stores elements in an unsorted and unordered manner, while TreeSet stores elements in a sorted and ordered manner.

B: HashSet stores elements in a sorted and ordered manner, while TreeSet stores elements in an unsorted and unordered manner.

C: Both HashSet and TreeSet store elements in the same manner.


Correct Response: 1

Explanation: HashSet stores elements in an unsorted and unordered manner, while TreeSet stores elements in a sorted and ordered manner based on the natural ordering of its elements or a custom comparator. This makes TreeSet suitable for use cases where you need to access elements in a specific order.





Q: What is the difference between a LinkedList and a LinkedHashSet in Java?


A: LinkedList is a list-based implementation that maintains the order of elements, while LinkedHashSet is a set-based implementation that does not maintain the order of elements.

B: LinkedList is a set-based implementation that does not maintain the order of elements, while LinkedHashSet is a list-based implementation that maintains the order of elements.

C: Both LinkedList and LinkedHashSet store elements in the same manner.


Correct Response: 1

Explanation: LinkedList is a list-based implementation that maintains the order of elements, allowing you to access elements based on their position in the list. LinkedHashSet, on the other hand, is a set-based implementation that does not allow duplicates, but maintains the order of elements as they were inserted.





Q: What is the difference between Iterator and ListIterator in terms of functionality?


A: Iterator allows you to traverse a collection in a single direction and remove elements, while ListIterator allows you to traverse a list in both directions and add and remove elements.

B: Iterator allows you to traverse a collection in both directions and add and remove elements, while ListIterator allows you to traverse a list in a single direction and remove elements.

C: Both Iterator and ListIterator have the same functionality.


Correct Response: 1

Explanation: Iterator allows you to traverse a collection in a single direction and remove elements, while ListIterator allows you to traverse a list in both directions and add and remove elements. ListIterator also provides methods to access the previous and next elements in the list, and to retrieve the index of the current element.





Q: What is the difference between a Vector and an ArrayList in Java?


A: Vector is synchronized, while ArrayList is not synchronized.

B: ArrayList is synchronized, while Vector is not synchronized.

C: Both Vector and ArrayList are synchronized.

D: Both Vector and ArrayList are not synchronized.


Correct Response: 1

Explanation: Vector is synchronized, meaning that all its methods are thread-safe and can be accessed by multiple threads at the same time. ArrayList, on the other hand, is not synchronized, meaning that it is not thread-safe and can only be accessed by a single thread at a time.





Q: What is the difference between a Stack and a Queue in Java?


A: Stack is a last-in-first-out (LIFO) data structure, while Queue is a first-in-first-out (FIFO) data structure.

B: Stack is a first-in-first-out (FIFO) data structure, while Queue is a last-in-first-out (LIFO) data structure.

C: Both Stack and Queue are the same.


Correct Response: 1

Explanation: Stack is a last-in-first-out (LIFO) data structure, meaning that the last element added to the stack is the first one to be removed. Queue, on the other hand, is a first-in-first-out (FIFO) data structure, meaning that the first element added to the queue is the first one to be removed.





Q: What is the difference between an Array and an ArrayList in terms of performance and functionality?


A: Array is fixed-size and provides better performance for index-based operations, while ArrayList is dynamic-size and provides better performance for add and remove operations.

B: Array is dynamic-size and provides better performance for add and remove operations, while ArrayList is fixed-size and provides better performance for index-based operations.

C: Both Array and ArrayList have the same performance and functionality.


Correct Response: 1

Explanation: Array is fixed-size, meaning that its size cannot be changed once it is created. It provides better performance for index-based operations, such as accessing elements at a specific index. ArrayList, on the other hand, is dynamic-size, meaning that its size can be changed as needed. It provides better performance for add and remove operations, but may be slower for index-based operations.





Q: What are the different ways to sort elements in a List in Java?


A: Using the sort() method of the Collections class

B: Using the sorted() method of the Stream API

C: Implementing the Comparable interface in the elements of the List and using the sort() method of the Collections class

D: Implementing the Comparator interface in the elements of the List and using the sort() method of the Collections class


Correct Response: 1, 4

Explanation: You can sort elements in a List in Java by using the sort() method of the Collections class or by implementing the Comparable or Comparator interface in the elements of the List and using the sort() method of the Collections class. The sorted() method of the Stream API can be used to sort elements in a stream.





Q: What is the difference between the add() method of a List and the put() method of a Map in Java?


A: The add() method adds an element to the end of a List, while the put() method adds a key-value pair to a Map.

B: The add() method adds a key-value pair to a Map, while the put() method adds an element to the end of a List.

C: Both the add() method and the put() method have the same functionality.


Correct Response: 1

Explanation: The add() method adds an element to the end of a List, while the put() method adds a key-value pair to a Map. This allows you to store and retrieve elements in a List based on their position, and in a Map based on their keys.





Q: What is the significance of the hashCode() method in Java Collections Framework?


A: The hashCode() method is used to determine the hash value of an object, which is used to efficiently store and retrieve elements in a HashMap.

B: The hashCode() method is used to compare two objects to determine if they are equal.

C: The hashCode() method is used to convert an object to a string representation.


Correct Response: 1

Explanation: The hashCode() method is used to determine the hash value of an object, which is used to efficiently store and retrieve elements in a HashMap. The hash value of an object is used as an index in the hash table where the object is stored. When retrieving an object, the hash value is used to quickly locate the object in the hash table.





Q: What is the difference between the keySet() and values() methods of a Map in Java?


A: The keySet() method returns a set of all the keys in a Map, while the values() method returns a collection of all the values in a Map.

B: The keySet() method returns a collection of all the values in a Map, while the values() method returns a set of all the keys in a Map.

C: Both the keySet() and values() methods return the same information.


Correct Response: 1

Explanation: The keySet() method returns a set of all the keys in a Map, while the values() method returns a collection of all the values in a Map. This allows you to access either the keys or the values of a Map independently, depending on your use case.





Q: How does the HashMap class handle collisions in Java?


A: The HashMap class handles collisions by using chaining, where multiple key-value pairs are stored in the same bucket using linked lists.

B: The HashMap class handles collisions by using open addressing, where key-value pairs are stored in the next available bucket.

C: The HashMap class does not handle collisions.


Correct Response: 1

Explanation: The HashMap class handles collisions by using chaining, where multiple key-value pairs are stored in the same bucket using linked lists. When two key-value pairs have the same hash value, they are stored in the same bucket, and each bucket is implemented as a linked list. This allows the HashMap to handle collisions efficiently and maintain the constant-time average performance for add, remove, and lookup operations.





Q: What is the difference between the for-each loop and the Iterator in Java?


A: The for-each loop is used to traverse a collection in a single direction, while the Iterator is used to traverse a collection in both directions and remove elements.

B: The for-each loop is used to traverse a collection in both directions and remove elements, while the Iterator is used to traverse a collection in a single direction.

C: Both the for-each loop and the Iterator have the same functionality.


Correct Response: 2

Explanation: The for-each loop is used to traverse a collection in a single direction, allowing you to access elements one by one. The Iterator, on the other hand, is used to traverse a collection in both directions and remove elements, allowing you to access elements one by one and remove elements as needed.





Q: What is the difference between a Set and a List in Java?


A: A Set is an unordered collection that does not allow duplicates, while a List is an ordered collection that allows duplicates.

B: A Set is an ordered collection that allows duplicates, while a List is an unordered collection that does not allow duplicates.

C: Both Set and List have the same functionality.


Correct Response: 1

Explanation: A Set is an unordered collection that does not allow duplicates, meaning that each element in a Set is unique. A List, on the other hand, is an ordered collection that allows duplicates, meaning that you can have multiple elements with the same value in a List.





Q: What is the difference between a Map and a Set in Java?


A: A Map is a collection of key-value pairs, while a Set is a collection of unique elements.

B: A Map is a collection of unique elements, while a Set is a collection of key-value pairs.

C: Both Map and Set have the same functionality.


Correct Response: 1

Explanation: A Map is a collection of key-value pairs, meaning that each element in a Map is a combination of a key and a value. A Set, on the other hand, is a collection of unique elements, meaning that each element in a Set is a single value.





Q: What are the different types of Collection classes in Java and what are their use cases?


A: ArrayList: dynamic-sized array for storing elements in a specific order

B: LinkedList: doubly linked list for fast add and remove operations

C: HashMap: hash table for fast lookup and add operations based on keys

D: TreeMap: balanced binary search tree for sorted elements based on keys


Correct Response: 1,2,3,4

Explanation: ArrayList is a dynamic-sized array for storing elements in a specific order. LinkedList is a doubly linked list for fast add and remove operations. HashMap is a hash table for fast lookup and add operations based on keys. TreeMap is a balanced binary search tree for sorted elements based on keys.





Q: What is the difference between a HashMap and a LinkedHashMap in Java?


A: A HashMap is a hash table for fast lookup and add operations based on keys, while a LinkedHashMap is a hash table with a linked list to maintain the order of elements.

B: A LinkedHashMap is a hash table for fast lookup and add operations based on keys, while a HashMap is a hash table with a linked list to maintain the order of elements.

C: Both HashMap and LinkedHashMap have the same functionality.


Correct Response: 2

Explanation: A LinkedHashMap is a hash table with a linked list to maintain the order of elements, meaning that the elements in a LinkedHashMap are stored in the order in which they were inserted. A HashMap, on the other hand, is a hash table for fast lookup and add operations based on keys, meaning that the elements in a HashMap are not stored in any specific order.





Q: What is a Thread in Java?


A: A Thread is a separate flow of execution in a program.

B: A Thread is a data structure used to store elements in a specific order.

C: A Thread is a class used to handle exceptions in a program.


Correct Response: 1

Explanation: A Thread is a separate flow of execution in a program, meaning that a program can have multiple threads executing simultaneously, each in its own flow of execution. This allows for multitasking and parallel processing in a program.





Q: What is the priority of a Thread and how it is used in scheduling?


A: The priority of a Thread is a value that determines the order in which it is executed by the scheduler. The scheduler uses the priority of a Thread to determine which Thread to run next.

B: The priority of a Thread has no effect on its execution.

C: The priority of a Thread determines the amount of memory it is allocated.


Correct Response: 1

Explanation: The priority of a Thread is a value that determines the order in which it is executed by the scheduler. The scheduler uses the priority of a Thread to determine which Thread to run next. Higher priority Threads are executed before lower priority Threads, but the exact order of execution depends on the scheduler implementation.





Q: What is the default priority of a thread in Java?


A: The default priority of a thread in Java is 5.

B: The default priority of a thread in Java is 10.

C: The default priority of a thread in Java is 0.

D: The default priority of a thread in Java is 1.


Correct Response: 1

Explanation: The default priority of a thread in Java is 5. This means that a thread created without explicitly setting its priority will have a priority of 5.





Q: What are the three different priorities that can be set on a Thread in Java?


A: MIN_PRIORITY

B: MAX_PRIORITY

C: NORM_PRIORITY

D: MID_PRIORITY


Correct Response: 1, 2, 3

Explanation: The three different priorities that can be set on a Thread in Java are MIN_PRIORITY, MAX_PRIORITY, and NORM_PRIORITY. MIN_PRIORITY is the lowest priority, MAX_PRIORITY is the highest priority, and NORM_PRIORITY is the default priority.





Q: What is the purpose of join() method in Thread class?


A: The purpose of join() method in Thread class is to wait for a Thread to complete its execution.

B: The purpose of join() method in Thread class is to start a Thread.

C: The purpose of join() method in Thread class is to interrupt a Thread.


Correct Response: 1

Explanation: The purpose of join() method in Thread class is to wait for a Thread to complete its execution. When you call join() on a Thread, the currently executing thread will wait until the Thread on which join() is called completes its execution.





Q: What is the fundamental difference between wait() and sleep() methods?


A: The fundamental difference between wait() and sleep() methods is that wait() releases the lock, while sleep() does not.

B: The fundamental difference between wait() and sleep() methods is that sleep() releases the lock, while wait() does not.

C: There is no difference between wait() and sleep() methods.


Correct Response: 1

Explanation: The fundamental difference between wait() and sleep() methods is that wait() releases the lock, while sleep() does not. When a Thread calls wait(), it releases the lock and enters a waiting state, allowing other Threads to access the shared resources. When a Thread calls sleep(), it does not release the lock, but simply goes to sleep for the specified amount of time.





Q: Is it possible to call run() method instead of start() on a thread in Java?


A: Yes, it is possible to call run() method instead of start() on a thread in Java.

B: No, it is not possible to call run() method instead of start() on a thread in Java.

C: It depends on the implementation of the Thread class.


Correct Response: 1

Explanation: Yes, it is possible to call run() method instead of start() on a thread in Java. However, this is not recommended as it will simply execute the run() method in the same thread as the calling thread, rather than creating a new thread of execution. To create a new thread, it is necessary to call start().





Q: What is a daemon thread in Java?


A: A daemon thread in Java is a low-priority thread that runs in the background to perform tasks such as garbage collection.

B: A daemon thread in Java is a high-priority thread that runs in the foreground to perform tasks such as user input processing.

C: A daemon thread in Java is a special type of thread that does not affect the termination of the program.


Correct Response: 1

Explanation: A daemon thread in Java is a low-priority thread that runs in the background to perform tasks such as garbage collection. Daemon threads are automatically terminated by the Java Virtual Machine (JVM) when there are no other non-daemon threads running. This makes them useful for background tasks that do not need to run after the program has completed.





Q: How can we make a regular thread Daemon thread in Java?


A: To make a regular thread Daemon thread, we can call setDaemon(true) method on the thread before starting it.

B: To make a regular thread Daemon thread, we can call setDaemon(false) method on the thread before starting it.

C: To make a regular thread Daemon thread, we can call setDaemon(true) method on the thread after starting it.


Correct Response: 1

Explanation: To make a regular thread Daemon thread, we can call setDaemon(true) method on the thread before starting it. This method sets the daemon status of the thread, and a thread that is marked as a daemon thread will automatically terminate when the program terminates, even if it has not completed its execution.





Q: How will you make a user thread into daemon thread if it has already started?


A: It is not possible to make a user thread into a daemon thread if it has already started.

B: To make a user thread into a daemon thread if it has already started, we can call setDaemon(true) method on the thread.

C: To make a user thread into a daemon thread if it has already started, we can call interrupt() method on the thread.


Correct Response: 1

Explanation: It is not possible to make a user thread into a daemon thread if it has already started. The daemon status of a thread must be set before the thread is started, otherwise it cannot be changed.





Q: Can we start a thread two times in Java?


A: No, a thread can only be started once in Java.

B: Yes, a thread can be started multiple times in Java.

C: It depends on the implementation of the Thread class.


Correct Response: 1

Explanation: No, a thread can only be started once in Java. Attempting to start a thread that has already been started will result in an IllegalThreadStateException.





Q: What is a Shutdown hook in Java?


A: A Shutdown hook in Java is a special type of thread that runs just before the JVM shuts down.

B: A Shutdown hook in Java is a special type of thread that runs just after the JVM starts up.

C: A Shutdown hook in Java is a special type of thread that runs continuously in the background.


Correct Response: 1

Explanation: A Shutdown hook in Java is a special type of thread that runs just before the JVM shuts down. Shutdown hooks are registered with the JVM and are run when the JVM is shutting down, allowing the application to perform any necessary cleanup tasks before it terminates.





Q: What is synchronization in Java?


A: Synchronization in Java is a mechanism that ensures that only one Thread can access a shared resource at a time.

B: Synchronization in Java is a mechanism that ensures that all Threads can access a shared resource simultaneously.

C: Synchronization in Java is a mechanism that ensures that no Thread can access a shared resource.


Correct Response: 1

Explanation: Synchronization in Java is a mechanism that ensures that only one Thread can access a shared resource at a time. This is necessary to prevent problems such as race conditions and other forms of corruption that can occur when multiple Threads access the same resources simultaneously.





Q: What is the purpose of Synchronized block in Java?


A: The purpose of a Synchronized block in Java is to lock an object or a section of code so that only one Thread can access it at a time.

B: The purpose of a Synchronized block in Java is to allow multiple Threads to access an object or a section of code simultaneously.

C: The purpose of a Synchronized block in Java is to prevent access to an object or a section of code.


Correct Response: 1

Explanation: The purpose of a Synchronized block in Java is to lock an object or a section of code so that only one Thread can access it at a time. This helps to prevent problems such as race conditions and other forms of corruption that can occur when multiple Threads access the same resources simultaneously.





Q: What is static synchronization?


A: Static synchronization is a form of synchronization that ensures that only one Thread can access a static method or a static variable at a time.

B: Static synchronization is a form of synchronization that ensures that all Threads can access a static method or a static variable simultaneously.

C: Static synchronization is a form of synchronization that ensures that no Thread can access a static method or a static variable.


Correct Response: 1

Explanation: Static synchronization is a form of synchronization that ensures that only one Thread can access a static method or a static variable at a time. This helps to prevent problems such as race conditions and other forms of corruption that can occur when multiple Threads access the same resources simultaneously.





Q: What is a Deadlock situation?


A: A Deadlock situation is a situation in which two or more Threads are blocked indefinitely, waiting for each other to release a resource.

B: A Deadlock situation is a situation in which two or more Threads are blocked temporarily, waiting for each other to release a resource.

C: A Deadlock situation is a situation in which two or more Threads are able to access a resource simultaneously.


Correct Response: 1

Explanation: A Deadlock situation is a situation in which two or more Threads are blocked indefinitely, waiting for each other to release a resource. Deadlocks can occur when multiple Threads hold locks on resources that they need to access, and each Thread is waiting for another Thread to release a lock. This can result in a situation where all Threads are blocked, unable to make progress.





Q: What is the meaning of concurrency?


A: The ability of a program to perform multiple tasks simultaneously.

B: The ability of a program to perform one task at a time.

C: The ability of a program to switch between tasks quickly.


Correct Response: 1

Explanation: Concurrency is the ability of a program to perform multiple tasks simultaneously. This allows for multiple tasks to be executed in parallel, improving the performance and responsiveness of the program.





Q: What is the main difference between process and thread?


A: A process is a self-contained program, while a thread is a lightweight sub-process.

B: A process is a lightweight sub-process, while a thread is a self-contained program.

C: Both process and thread are the same.


Correct Response: 1

Explanation: A process is a self-contained program with its own memory space, while a thread is a lightweight sub-process that shares the memory space of its parent process. Threads are used to perform multiple tasks within a single process.





Q: What is a process and thread in the context of Java?


A: A process is a single instance of a Java program, while a thread is a separate execution path within a single process.

B: A process is a separate execution path within a single instance of a Java program, while a thread is a single instance of a Java program.

C: Both process and thread are the same in the context of Java.


Correct Response: 1

Explanation: In the context of Java, a process is a single instance of a Java program, while a thread is a separate execution path within a single process. Java supports multithreading, allowing multiple threads to run within a single process and share resources.





Q: What is a Scheduler?


A: A component that assigns tasks to threads for execution.

B: A component that executes tasks.

C: A component that manages the execution of tasks.


Correct Response: 1

Explanation: A Scheduler is a component that assigns tasks to threads for execution. It determines which thread should execute which task and when, improving the performance and responsiveness of the program.





Q: What is the minimum number of Threads in a Java program?


A: 1

B: 2

C: 0


Correct Response: 1

Explanation: The minimum number of threads in a Java program is 1. Every Java program has at least one thread, the main thread, which is responsible for executing the main method.





Q: What are the properties of a Java thread?


A: Name

B: Priority

C: State

D: Daemon


Correct Response: 1, 2, 3

Explanation: Java threads have several properties such as Name, Priority, and State. The name of a thread is used to identify it, the priority determines the order in which threads are executed, and the state indicates the current status of the thread (running, waiting, etc.).





Q: What are the different states of a Thread in Java?


A: Running

B: Waiting

C: Sleeping

D: Blocked


Correct Response: 1, 2, 3

Explanation: Java threads can be in several states such as Running, Waiting, Sleeping, and Blocked. Running means the thread is currently executing, Waiting means the thread is waiting for a resource to become available, Sleeping means the thread is temporarily inactive, and Blocked means the thread is waiting for a lock to be released.





Q: How will you set the priority of a thread in Java?


A: By calling the setPriority() method on the Thread instance.

B: By calling the setPriority() method on the Scheduler.

C: By setting the priority property of the Thread instance.


Correct Response: 1

Explanation: The priority of a thread in Java can be set by calling the setPriority() method on the Thread instance. The priority is an integer value between 1 and 10, with 1 being the lowest priority and 10 being the highest.





Q: What is the purpose of Thread Groups in Java?


A: To group related threads together for easier management.

B: To set the priority of threads.

C: To execute threads in a specific order.


Correct Response: 1

Explanation: The purpose of Thread Groups in Java is to group related threads together for easier management. Thread groups allow for the management of multiple threads as a single unit, making it easier to control and monitor the threads.





Q: Why we should not stop a thread by calling its stop() method?


A: Because the stop() method is deprecated and can cause unpredictable results.

B: Because the stop() method is not supported in Java.

C: Because the stop() method is too slow.


Correct Response: 1

Explanation: We should not stop a thread by calling its stop() method because the stop() method is deprecated and can cause unpredictable results, such as data corruption. Instead, we should use alternative methods such as interrupting the thread or using a flag to signal the thread to stop.





Q: How will you create a Thread in Java?


A: By extending the Thread class.

B: By implementing the Runnable interface.

C: By creating a new instance of the Thread class.

D: All of the above.


Correct Response: 2

Explanation: A Thread in Java can be created by implementing the Runnable interface and passing an instance of the class to the constructor of the Thread class. Alternatively, a Thread can be created by extending the Thread class and overriding the run() method.





Q: How can we stop a thread in the middle of execution in Java?


A: By calling the stop() method on the Thread instance.

B: By using a flag to signal the thread to stop.

C: By interrupting the thread.


Correct Response: 2

Explanation: A thread in the middle of execution in Java can be stopped by using a flag to signal the thread to stop or by interrupting the thread. The stop() method should not be used as it is deprecated and can cause unpredictable results.





Q: How do you access the current thread in a Java program?


A: By calling the currentThread() method on the Thread class.

B: By calling the getCurrentThread() method on the Scheduler.

C: By calling the getCurrentThread() method on the Thread class.


Correct Response: 1

Explanation: The current thread in a Java program can be accessed by calling the currentThread() method on the Thread class. This method returns a reference to the current thread.





Q: What is Busy waiting in Multi-threading?


A: A technique where a thread continuously checks a condition until it is satisfied.

B: A technique where a thread waits for a specific amount of time.

C: A technique where a thread waits for a resource to become available.


Correct Response: 1

Explanation: Busy waiting in Multi-threading is a technique where a thread continuously checks a condition until it is satisfied. This can result in high CPU utilization and is generally considered an ineffective method for synchronization.





Q: How can we prevent busy waiting in Java?


A: By using synchronization techniques such as locks.

B: By using the wait() and notify() methods.

C: By using the join() method.

D: All of the above.


Correct Response: 1

Explanation: Busy waiting in Java can be prevented by using synchronization techniques such as locks, the wait() and notify() methods, or the join() method. These methods allow for threads to wait for specific conditions or for other threads to complete, avoiding the need for busy waiting.





Q: Can we use Thread.sleep() method for real-time processing in Java?


A: No

B: Yes

C: Depends on the situation


Correct Response: 1

Explanation: No, the Thread.sleep() method should not be used for real-time processing as it can cause unpredictable results and should not be relied upon for precise timing.





Q: Can we wake up a thread that has been put to sleep by using Thread.sleep() method?


A: No

B: Yes

C: Depends on the situation


Correct Response: 2

Explanation: Yes, a thread that has been put to sleep using the Thread.sleep() method can be woken up by interrupting the thread. The interrupt() method can be called on the Thread instance to interrupt the thread and cause an InterruptedException to be thrown.





Q: What are the two ways to check if a Thread has been interrupted?


A: By calling the isInterrupted() method on the Thread instance.

B: By checking the value of the interrupted status flag.

C: By catching an InterruptedException.

D: All of the above.


Correct Response: 1, 2

Explanation: There are two ways to check if a thread has been interrupted in Java. One way is by calling the isInterrupted() method on the Thread instance, which returns the value of the interrupted status flag. Another way is by checking the value of the interrupted status flag directly.





Q: How can we make sure that Parent thread waits for termination of Child thread?


A: By using the join() method on the Child thread instance.

B: By using the wait() method on the Parent thread instance.

C: By using the notify() method on the Child thread instance.


Correct Response: 1

Explanation: To make sure that a Parent thread waits for termination of a Child thread, the join() method can be used on the Child thread instance. The join() method blocks the calling thread until the Child thread terminates.





Q: How will you handle InterruptedException in Java?


A: By catching the InterruptedException and continuing the execution of the thread.

B: By catching the InterruptedException and terminating the execution of the thread.

C: By re-throwing the InterruptedException.


Correct Response: 1

Explanation: InterruptedException in Java can be handled by catching the exception and continuing the execution of the thread. This allows the thread to continue executing even if it has been interrupted. Alternatively, the InterruptedException can be re-thrown if the interruption needs to be propagated to the calling method.





Q: Which intrinsic lock is acquired by a synchronized method in Java?


A: The intrinsic lock associated with the instance of the class.

B: The intrinsic lock associated with the class itself.

C: The intrinsic lock associated with the method.


Correct Response: 1

Explanation: A synchronized method in Java acquires the intrinsic lock associated with the instance of the class. This lock is used to ensure that only one thread can execute the synchronized method at a time, preventing data corruption and ensuring thread-safety.





Q: Can we mark a constructor as synchronized in Java?


A: No

B: Yes

C: Depends on the situation


Correct Response: 2

Explanation: Yes, a constructor in Java can be marked as synchronized. This ensures that only one thread can create an instance of the class at a time, preventing data corruption and ensuring thread-safety.





Q: Can we use primitive values for intrinsic locks?


A: No

B: Yes

C: Depends on the situation


Correct Response: 1

Explanation: No, primitive values cannot be used for intrinsic locks in Java. Intrinsic locks are associated with objects and are used to synchronize access to the objects.





Q: Do we have re-entrant property in intrinsic locks?


A: Yes

B: No

C: Depends on the situation


Correct Response: 1

Explanation: Yes, intrinsic locks in Java have the re-entrant property. This means that a thread can acquire a lock multiple times, as long as it releases the lock the same number of times. This allows for nested synchronization, improving the performance and responsiveness of the program.





Q: What is an atomic operation?


A: An operation that is indivisible and uninterruptible.

B: An operation that can be interrupted.

C: An operation that can be divided into smaller operations.


Correct Response: 1

Explanation: An atomic operation is an operation that is indivisible and uninterruptible. This means that the operation is executed as a single, uninterruptible step, without the possibility of another thread interfering. Atomic operations are used to ensure the consistency and integrity of data in multi-threaded environments.





Q: Can we consider the statement i++ as an atomic operation in Java?


A: No

B: Yes

C: Depends on the situation


Correct Response: 1

Explanation: No, the statement i++ is not considered an atomic operation in Java. An atomic operation is an operation that is indivisible and uninterruptible, whereas the statement i++ is made up of multiple operations (fetching the value of i, incrementing the value, and storing the result) and can be interrupted by another thread.





Q: What are the Atomic operations in Java?


A: Operations that are indivisible and uninterruptible.

B: Operations that can be interrupted.

C: Operations that can be divided into smaller operations.


Correct Response: 1

Explanation: Atomic operations in Java are operations that are indivisible and uninterruptible. These operations are used to ensure the consistency and integrity of data in multi-threaded environments by preventing data corruption from concurrent access. Examples of atomic operations in Java include using the Atomic classes such as AtomicInteger and AtomicLong, or using the synchronized keyword.





Q: Can you check if following code is thread-safe?


A: No

B: Yes

C: Depends on the situation


Correct Response: 3

Explanation: The thread-safety of code depends on the specific implementation and usage, so the answer to this question would depend on the code in question. To determine if a piece of code is thread-safe, it is necessary to consider the data being accessed and the synchronization mechanisms being used.





Q: What are the minimum requirements for a Deadlock situation in a program?


A: Two or more threads, each holding a resource and waiting for the other to release a resource.

B: Three or more threads, each holding a resource and waiting for the other to release a resource.

C: Four or more threads, each holding a resource and waiting for the other to release a resource.


Correct Response: 1

Explanation: The minimum requirements for a Deadlock situation in a program are two or more threads, each holding a resource and waiting for the other to release a resource. This creates a situation where the threads are blocked and unable to make progress, resulting in a Deadlock.





Q: How can we prevent a Deadlock?


A: By ensuring that threads only request resources in a specific order.

B: By using timeouts to release resources.

C: By using a Deadlock detection algorithm to detect and resolve Deadlocks.

D: All of the above.


Correct Response: 4

Explanation: Deadlocks can be prevented by using several techniques, including ensuring that threads only request resources in a specific order, using timeouts to release resources, and using a Deadlock detection algorithm to detect and resolve Deadlocks. Implementing a combination of these techniques can help to prevent Deadlocks in a program.





Q: How can we detect a Deadlock situation?


A: By using a Deadlock detection algorithm.

B: By using a Deadlock resolution algorithm.

C: By using a timeout mechanism.

D: All of the above.


Correct Response: 1

Explanation: Deadlock situations can be detected by using a Deadlock detection algorithm. This algorithm monitors the state of the threads and resources in a program and identifies when a Deadlock has occurred.





Q: What is a Livelock?


A: A situation where two or more threads are blocked and unable to make progress.

B: A situation where two or more threads continuously change their state in response to the state of others, without making progress.

C: A situation where a thread is blocked and unable to make progress.


Correct Response: 2

Explanation: A Livelock is a situation where two or more threads continuously change their state in response to the state of others, without making progress. This creates a situation where the threads are in a loop and unable to make progress, even though they are not blocked.





Q: What is Thread starvation?


A: A situation where a thread is blocked and unable to make progress.

B: A situation where a thread is unable to obtain the resources it needs to complete its task.

C: A situation where a thread is unable to execute because it is waiting for another thread.


Correct Response: 2

Explanation: Thread starvation is a situation where a thread is unable to obtain the resources it needs to complete its task. This can occur when a high-priority thread continually monopolizes the resources, causing low-priority threads to be starved of the resources they need to execute.





Q: How can a synchronized block cause Thread starvation in Java?


A: By monopolizing the resources needed by other threads.

B: By releasing the resources too soon.

C: By not releasing the resources at all.


Correct Response: 1

Explanation: A synchronized block can cause Thread starvation in Java by monopolizing the resources needed by other threads. If a high-priority thread continually executes a synchronized block and holds the lock for a long time, it can prevent low-priority threads from obtaining the resources they need to execute, leading to Thread starvation.





Q: What is a Race condition?


A: A situation where the outcome of a program depends on the relative timing of events.

B: A situation where two or more threads access shared data simultaneously and interfere with each other's execution.

C: A situation where a thread is blocked and unable to make progress.


Correct Response: 2

Explanation: A Race condition is a situation where two or more threads access shared data simultaneously and interfere with each other's execution. This creates a situation where the outcome of a program depends on the relative timing of events and can result in unpredictable and inconsistent results.





Q: What is a Fair lock in multi-threading?


A: A lock that ensures that threads are granted access to a shared resource in the order in which they requested it.

B: A lock that ensures that threads are granted access to a shared resource randomly.

C: A lock that ensures that threads are granted access to a shared resource based on their priority.


Correct Response: 1

Explanation: A Fair lock is a lock that ensures that threads are granted access to a shared resource in the order in which they requested it. This ensures that lower-priority threads are not blocked indefinitely by higher-priority threads, improving the fairness and responsiveness of the program.





Q: Which two methods of Object class can be used to implement a Producer Consumer scenario?


A: wait() and notifyAll()

B: wait() and notify()

C: sleep() and notifyAll()

D: sleep() and notify()


Correct Response: 1

Explanation: The wait() and notify() methods of the Object class can be used to implement a Producer Consumer scenario. The wait() method is used to block a thread until a certain condition is met, and the notify() method is used to wake up a thread that is waiting. These methods are used to coordinate the behavior of multiple threads and ensure that the program runs smoothly.





Q: How JVM determines which thread should wake up on notify()?


A: Based on the order in which the threads called wait().

B: Based on the priority of the threads.

C: Based on the order in which the threads were created.

D: Based on a random selection.


Correct Response: 1

Explanation: The JVM determines which thread should wake up on notify() based on the order in which the threads called wait(). The thread that has been waiting the longest is the first to be awakened when notify() is called. This ensures that lower-priority threads are not blocked indefinitely by higher-priority threads, improving the fairness and responsiveness of the program.





Q: Check if following code is thread-safe for retrieving an integer value from a Queue?


A: No

B: Yes

C: Depends on the situation


Correct Response: 3

Explanation: The thread-safety of code depends on the specific implementation and usage, so the answer to this question would depend on the code in question. To determine if a piece of code is thread-safe, it is necessary to consider the data being accessed and the synchronization mechanisms being used.





Q: How can we check if a thread has a monitor lock on a given object?


A: By using the isAlive() method of the Thread class.

B: By using the getState() method of the Thread class.

C: By using the holdsLock() method of the Thread class.


Correct Response: 3

Explanation: We can check if a thread has a monitor lock on a given object by using the holdsLock() method of the Thread class. This method returns true if the current thread holds the monitor lock on the specified object, and false otherwise.





Q: What is the use of yield() method in Thread class?


A: To cause the current thread to pause execution temporarily.

B: To cause the current thread to pause execution permanently.

C: To cause the current thread to terminate.

D: To cause the current thread to yield control to other threads of the same priority.


Correct Response: 4

Explanation: The yield() method of the Thread class is used to cause the current thread to yield control to other threads of the same priority. This method can be used to improve the responsiveness and fairness of a program by allowing lower-priority threads to execute more frequently.





Q: What is an important point to consider while passing an object from one thread to another thread?


A: The object should be thread-safe.

B: The object should be immutable.

C: The object should be passed by reference.

D: The object should be passed by value.


Correct Response: 1

Explanation: An important point to consider while passing an object from one thread to another thread is that the object should be thread-safe. This means that the object should be designed to be used by multiple threads simultaneously, without corrupting the data or producing incorrect results.





Q: What are the rules for creating Immutable Objects?


A: All fields should be final and private.

B: The class should not have any setters.

C: The class should be final.

D: All of the above.


Correct Response: 4

Explanation: To create an Immutable Object, all fields should be final and private, the class should not have any setters, and the class should be final. These rules ensure that the state of the object cannot be modified after it has been created, making it easier to reason about the behavior of the program and reducing the risk of bugs.





Q: What is the use of ThreadLocal class?


A: To store values that are associated with a specific thread.

B: To store values that are shared between all threads.

C: To store values that are associated with a specific process.


Correct Response: 1

Explanation: The ThreadLocal class is used to store values that are associated with a specific thread. This allows each thread to have its own private copy of the value, improving the thread-safety and scalability of the program.





Q: What are the scenarios suitable for using ThreadLocal class?


A: When you need to store values that are associated with a specific thread.

B: When you need to store values that are shared between all threads.

C: When you need to store values that are associated with a specific process.


Correct Response: 1

Explanation: The ThreadLocal class is suitable for use in scenarios where you need to store values that are associated with a specific thread. For example, you might use ThreadLocal to store a transaction ID, user ID, or other information that is specific to the current thread.





Q: How will you improve the performance of an application by multithreading?


A: By using multiple threads to perform multiple tasks simultaneously.

B: By using multiple threads to perform a single task.

C: By using a single thread to perform multiple tasks simultaneously.

D: By using a single thread to perform a single task.


Correct Response: 1

Explanation: You can improve the performance of an application by multithreading by using multiple threads to perform multiple tasks simultaneously. This allows the program to make better use of the available processing resources, improving the overall performance and responsiveness of the program.





Q: What is scalability in a Software program?


A: The ability of a program to handle increasing workloads effectively.

B: The ability of a program to handle decreasing workloads effectively.

C: The ability of a program to handle constant workloads effectively.


Correct Response: 1

Explanation: Scalability in a software program refers to the ability of the program to handle increasing workloads effectively. This means that as the size or complexity of the workload increases, the program should continue to perform well and provide acceptable levels of performance and responsiveness.





Q: How will you calculate the maximum speed up of an application by using multiple processors?


A: By using Amdahl's Law.

B: By using Gustafson's Law.

C: By using Moore's Law.


Correct Response: 1

Explanation: The maximum speed up of an application by using multiple processors can be calculated using Amdahl's Law. This law states that the maximum theoretical speedup of a program using multiple processors is limited by the amount of time that the program spends executing serial (non-parallelizable) code.





Q: What is Lock contention in multi-threading?


A: The situation in which multiple threads are trying to access the same resource simultaneously.

B: The situation in which multiple threads are trying to access different resources simultaneously.

C: The situation in which a single thread is trying to access multiple resources simultaneously.


Correct Response: 1

Explanation: Lock contention in multi-threading refers to the situation in which multiple threads are trying to access the same resource simultaneously. This can lead to performance problems and decreased responsiveness, as the threads compete for access to the shared resource.





Q: What are the techniques to reduce Lock contention?


A: By using finer-grained locks.

B: By using coarser-grained locks.

C: By using lock-free algorithms.

D: By using lock-based algorithms.


Correct Response: 1

Explanation: One technique to reduce lock contention in multi-threading is to use finer-grained locks. This means that instead of using a single, coarse-grained lock to protect a large region of shared memory, multiple smaller locks are used to protect smaller regions of memory. This can help to reduce the frequency and duration of lock contention, improving the performance and responsiveness of the program.





Q: What technique can be used in following code to reduce Lock contention?


A: Finer-grained locks.

B: Coarser-grained locks.

C: Lock-free algorithms.

D: Lock-based algorithms.


Correct Response: 1

Explanation: One technique that can be used in code to reduce lock contention is to use finer-grained locks. This means that instead of using a single, coarse-grained lock to protect a large region of shared memory, multiple smaller locks are used to protect smaller regions of memory. This can help to reduce the frequency and duration of lock contention, improving the performance and responsiveness of the program.





Q: What is Lock splitting technique?


A: A technique for reducing lock contention by using multiple locks to protect different regions of shared memory.

B: A technique for increasing lock contention by using a single lock to protect a large region of shared memory.

C: A technique for avoiding lock contention by using lock-free algorithms.


Correct Response: 1

Explanation: Lock splitting is a technique for reducing lock contention by using multiple locks to protect different regions of shared memory. This can help to reduce the frequency and duration of lock contention, improving the performance and responsiveness of the program.





Q: Which technique is used in ReadWriteLock class for reducing Lock contention?


A: Finer-grained locks.

B: Coarser-grained locks.

C: Lock-free algorithms.

D: Lock-based algorithms.


Correct Response: 1

Explanation: The ReadWriteLock class uses finer-grained locks to reduce lock contention. This means that instead of using a single lock to protect the entire shared memory region, multiple locks are used to protect smaller regions of memory. This can help to reduce the frequency and duration of lock contention, improving the performance and responsiveness of the program.





Q: What is Lock striping?


A: A technique for reducing lock contention by using multiple locks to protect different regions of shared memory.

B: A technique for increasing lock contention by using a single lock to protect a large region of shared memory.

C: A technique for avoiding lock contention by using lock-free algorithms.


Correct Response: 1

Explanation: Lock striping is a technique for reducing lock contention by using multiple locks to protect different regions of shared memory. This can help to reduce the frequency and duration of lock contention, improving the performance and responsiveness of the program.





Q: What is a CAS operation?


A: A Compare-And-Swap operation is an atomic operation that compares the contents of a memory location with a given value, and if the contents match, updates the memory location with a new value.

B: A Create-And-Swap operation is an atomic operation that creates a new memory location and swaps its contents with a given value.

C: A Copy-And-Swap operation is an atomic operation that copies the contents of a memory location to a new location and swaps its contents with a given value.


Correct Response: 1

Explanation: A Compare-And-Swap (CAS) operation is an atomic operation that compares the contents of a memory location with a given value, and if the contents match, updates the memory location with a new value. This can be used to implement efficient, thread-safe algorithms without the need for locks.





Q: Which Java classes use CAS operation?


A: The java.util.concurrent.atomic package.

B: The java.util.concurrent package.

C: The java.lang.Thread class.

D: The java.lang package.


Correct Response: 1

Explanation: The java.util.concurrent.atomic package provides classes that use the Compare-And-Swap (CAS) operation, such as the AtomicInteger and AtomicReference classes. These classes provide a way to implement efficient, thread-safe algorithms without the need for locks.





Q: Is it always possible to improve performance by object pooling in a multi-threading application?


A: No, it is not always possible to improve performance by object pooling in a multi-threading application.

B: Yes, it is always possible to improve performance by object pooling in a multi-threading application.

C: It depends on the implementation of object pooling.


Correct Response: 1

Explanation: No, it is not always possible to improve performance by object pooling in a multi-threading application. Object pooling can help to reduce the overhead of creating and destroying objects, but it also requires synchronization to ensure that the objects are used correctly by multiple threads. If the synchronization overhead outweighs the benefits of object pooling, the performance may actually degrade in a multi-threading application.





Q: How can techniques used for performance improvement in a single thread application may degrade the performance in a multi-threading application?


A: By increasing the amount of synchronization required to coordinate the actions of multiple threads.

B: By reducing the amount of synchronization required to coordinate the actions of multiple threads.

C: By increasing the number of objects created and destroyed.


Correct Response: 1

Explanation: Techniques used for performance improvement in a single thread application may degrade the performance in a multi-threading application by increasing the amount of synchronization required to coordinate the actions of multiple threads. For example, object pooling can help to reduce the overhead of creating and destroying objects, but it also requires synchronization to ensure that the objects are used correctly by multiple threads. If the synchronization overhead outweighs the benefits of object pooling, the performance may actually degrade in a multi-threading application.





Q: What is the relation between Executor and ExecutorService interface?


A: The ExecutorService interface extends the Executor interface.

B: The Executor interface implements the ExecutorService interface.

C: The Executor and ExecutorService interfaces are not related.


Correct Response: 1

Explanation: The ExecutorService interface extends the Executor interface. The Executor interface provides a way to run tasks asynchronously, while the ExecutorService interface provides additional functionality for managing a pool of threads and for running tasks that return a result.





Q: What will happen on calling submit() method of an ExecutorService instance whose queue is already full?


A: The task will be rejected and a RejectedExecutionException will be thrown.

B: The task will be added to the end of the queue.

C: The task will be executed immediately, bypassing the queue.


Correct Response: 1

Explanation: If the queue of an ExecutorService instance is already full and the submit() method is called, the task will be rejected and a RejectedExecutionException will be thrown. This exception indicates that the task cannot be executed due to resource constraints.





Q: What is a ScheduledExecutorService?


A: A ScheduledExecutorService is a special type of ExecutorService that can be used to schedule tasks to run after a specified delay, or to run periodically.

B: A ScheduledExecutorService is a special type of Executor that can be used to schedule tasks to run after a specified delay, or to run periodically.

C: A ScheduledExecutorService is a type of Timer.


Correct Response: 1

Explanation: A ScheduledExecutorService is a special type of ExecutorService that can be used to schedule tasks to run after a specified delay, or to run periodically. It provides a convenient way to schedule tasks that need to be executed repeatedly or at a specific time in the future.





Q: How will you create a Thread pool in Java?


A: By using the Executors class.

B: By using the Executor interface.

C: By using the ThreadPoolExecutor class.


Correct Response: 1

Explanation: You can create a Thread pool in Java by using either the Executors class or the ThreadPoolExecutor class. The Executors class provides convenient factory methods for creating various types of ExecutorService objects, including thread pools. The ThreadPoolExecutor class provides a more flexible way to create and configure a thread pool, allowing you to specify the size of the pool, the size of the work queue, and the behavior of the pool when it is full.





Q: What is the main difference between Runnable and Callable interface?


A: The Callable interface can return a value, while the Runnable interface cannot.

B: The Runnable interface can return a value, while the Callable interface cannot.

C: The Callable interface is more flexible than the Runnable interface.


Correct Response: 1

Explanation: The main difference between the Runnable and Callable interfaces is that the Callable interface can return a value, while the Runnable interface cannot. The Callable interface is used to represent a task that can return a result, while the Runnable interface is used to represent a task that cannot return a result.





Q: What are the uses of Future interface in Java?


A: To retrieve the result of a task executed asynchronously.

B: To cancel a task that has not yet started.

C: To check if a task has completed.

D: To retrieve the result of a task executed synchronously.


Correct Response: 1, 2, 3

Explanation: The Future interface provides methods for retrieving the result of a task executed asynchronously, cancelling a task that has not yet started, and checking if a task has completed. The Future interface represents the result of an asynchronous computation, and can be used to wait for and retrieve the result of a task executed in a separate thread.





Q: What is the difference in concurrency in HashMap and in Hashtable?


A: HashMap is not thread-safe, while Hashtable is thread-safe.

B: HashMap is thread-safe, while Hashtable is not thread-safe.

C: Both HashMap and Hashtable are thread-safe.


Correct Response: 1

Explanation: The main difference in terms of concurrency between HashMap and Hashtable is that HashMap is not thread-safe, while Hashtable is thread-safe. HashMap allows multiple threads to access the map concurrently, while Hashtable provides synchronization to ensure that only one thread can access the map at a time.





Q: How will you create synchronized instance of List or Map Collection?


A: By using the synchronizedList() or synchronizedMap() method of the Collections class.

B: By using the synchronized keyword when accessing the list or map.

C: By using the synchronizedList() or synchronizedMap() method of the Arrays class.


Correct Response: 1

Explanation: You can create a synchronized instance of a List or Map collection by using the synchronizedList() or synchronizedMap() method of the Collections class. These methods return a thread-safe version of the specified list or map, respectively. The returned collection implements all of the optional list or map operations, and is thread-safe.





Q: What is a Semaphore in Java?


A: A Semaphore is a synchronization mechanism that allows multiple threads to access a shared resource, with a control on the number of threads that can access the resource simultaneously.

B: A Semaphore is a thread-safe collection that stores elements in a particular order.

C: A Semaphore is a low-level thread synchronization mechanism that can be used to implement locks and other synchronization constructs.


Correct Response: 1

Explanation: A Semaphore is a synchronization mechanism that allows multiple threads to access a shared resource, with a control on the number of threads that can access the resource simultaneously. A Semaphore maintains a count of the number of permits that are available for a shared resource, and can be used to enforce mutual exclusion or to limit the number of threads that can access the resource at any given time.





Q: What is a CountDownLatch in Java?


A: A CountDownLatch is a synchronization mechanism that allows one or more threads to wait for a set of operations to complete.

B: A CountDownLatch is a thread-safe collection that stores elements in a particular order.

C: A CountDownLatch is a low-level thread synchronization mechanism that can be used to implement locks and other synchronization constructs.


Correct Response: 1

Explanation: A CountDownLatch is a synchronization mechanism that allows one or more threads to wait for a set of operations to complete. A CountDownLatch maintains a count of the number of events that need to occur before it can be released, and can be used to coordinate the actions of multiple threads. When all of the events have occurred, the latch is released and any waiting threads can proceed.





Q: What is the difference between CountDownLatch and CyclicBarrier?


A: A CountDownLatch is used to coordinate the actions of multiple threads that wait for a set of operations to complete, while a CyclicBarrier is used to coordinate the actions of multiple threads that work together to solve a problem.

B: A CountDownLatch is used to coordinate the actions of multiple threads that work together to solve a problem, while a CyclicBarrier is used to coordinate the actions of multiple threads that wait for a set of operations to complete.

C: Both CountDownLatch and CyclicBarrier are used for the same purpose.


Correct Response: 1

Explanation: The main difference between CountDownLatch and CyclicBarrier is that a CountDownLatch is used to coordinate the actions of multiple threads that wait for a set of operations to complete, while a CyclicBarrier is used to coordinate the actions of multiple threads that work together to solve a problem. A CountDownLatch allows one or more threads to wait for a set of operations to complete, while a CyclicBarrier allows multiple threads to work together to solve a problem and wait for each other to complete their work.





Q: What are the scenarios suitable for using Fork/Join framework?


A: When the task can be divided into smaller subtasks that can be executed independently.

B: When the task is too complex to be executed by a single thread.

C: When the task requires a lot of computational power.

D: When the task is too simple to be executed by multiple threads.


Correct Response: 1, 2

Explanation: The Fork/Join framework is suitable for scenarios where the task can be divided into smaller subtasks that can be executed independently and when the task is too complex to be executed by a single thread. This allows for parallel execution of the subtasks, resulting in improved performance.





Q: What is the difference between RecursiveTask and RecursiveAction class?


A: RecursiveTask returns a value, while RecursiveAction does not.

B: RecursiveAction returns a value, while RecursiveTask does not.

C: Both classes return a value.

D: Neither class returns a value.


Correct Response: 1

Explanation: RecursiveTask returns a value, while RecursiveAction does not. This makes RecursiveTask suitable for tasks that need to return a result, while RecursiveAction is used for tasks that do not return a result.





Q: In Java, can we process stream operations with a Thread pool?


A: Yes, we can process stream operations with a Thread pool.

B: No, we cannot process stream operations with a Thread pool.

C: It depends on the stream operations.


Correct Response: 1

Explanation: Yes, we can process stream operations with a Thread pool. This allows for parallel execution of the stream operations, resulting in improved performance.





Q: What are the scenarios to use parallel stream in Java?


A: When processing large amounts of data.

B: When the data can be divided into smaller chunks and processed independently.

C: When the processing of data requires a lot of computational power.

D: When the processing of data is too simple to be executed by multiple threads.


Correct Response: 1, 2

Explanation: Parallel streams are suitable for scenarios where the data can be divided into smaller chunks and processed independently and when processing large amounts of data. This allows for parallel execution of the stream operations, resulting in improved performance.





Q: How Stack and Heap work in Java multi-threading environment?


A: Each thread has its own Stack and Heap.

B: All threads share a single Stack and Heap.

C: Stack is shared among threads, while Heap is not.

D: Heap is shared among threads, while Stack is not.


Correct Response: 1

Explanation: In Java's multi-threading environment, each thread has its own Stack and Heap. Stack is used to store method invocations and local variables, while Heap is used to store objects and instance variables. This helps prevent data corruption and race conditions.





Q: How can we take Thread dump in Java?


A: Using the "jstack" command.

B: Using the "jmap" command.

C: Using the "jstat" command.

D: All of the above.


Correct Response: 1

Explanation: A thread dump can be taken in Java using the "jstack" command. The jstack tool is part of the Java Development Kit (JDK) and is used to dump the stack trace of a Java process.





Q: Which parameter can be used to control stack size of a thread in Java?


A: -Xss

B: -Xmx

C: -Xms

D: -Xgc


Correct Response: 1

Explanation: The "-Xss" parameter can be used to control the stack size of a thread in Java. This parameter specifies the maximum stack size that a thread can use.





Q: There are two threads T and T'. How will you ensure that these threads run in sequence T, T' in Java?


A: Using a ReentrantLock.

B: Using a synchronized method.

C: Using a synchronized block.

D: Using the wait() and notify() methods.


Correct Response: 4

Explanation: The wait() and notify() methods can be used to ensure that two threads run in sequence in Java. The wait() method causes a thread to wait until it is notified, while the notify() method notifies a waiting thread to continue execution.





Q: What is a ThreadLocalRandom class in Java?


A: A random number generator that is local to a thread.

B: A random number generator that is global to all threads.

C: A random number generator that is only used in parallel streams.


Correct Response: 1

Explanation: The ThreadLocalRandom class is a random number generator that is local to a thread. This means that each thread has its own instance of ThreadLocalRandom, which helps prevent race conditions and data corruption.





Q: What is the difference between a synchronized method and a synchronized block in Java?


A: A synchronized method locks the entire object, while a synchronized block only locks the specified section of code.

B: A synchronized block locks the entire object, while a synchronized method only locks the specified section of code.

C: Both a synchronized method and a synchronized block lock the entire object.

D: Neither a synchronized method nor a synchronized block lock the entire object.


Correct Response: 1

Explanation: A synchronized method locks the entire object, while a synchronized block only locks the specified section of code. This allows for more fine-grained control over synchronization in Java.





Q: What is the use of volatile keyword in Java?


A: To ensure that a variable is read from main memory, not from cache.

B: To ensure that a variable is read from cache, not from main memory.

C: To ensure that a variable is read from both cache and main memory.


Correct Response: 1

Explanation: The volatile keyword in Java is used to ensure that a variable is read from main memory, not from cache. This helps prevent race conditions and data corruption in multi-threaded environments.





Q: What is a ReadWriteLock in Java?


A: A lock that allows multiple threads to read a resource, but only one thread to write to it.

B: A lock that allows only one thread to read or write a resource.

C: A lock that allows multiple threads to read or write a resource.


Correct Response: 1

Explanation: A ReadWriteLock is a lock that allows multiple threads to read a resource, but only one thread to write to it. This helps improve performance in multi-threaded environments by allowing multiple threads to read the resource concurrently.





Q: What is the difference between wait() and notifyAll() methods in Java?


A: The wait() method causes a single thread to wait, while the notifyAll() method notifies all waiting threads.

B: The notifyAll() method causes a single thread to wait, while the wait() method notifies all waiting threads.

C: Both the wait() and notifyAll() methods cause a single thread to wait.

D: Both the wait() and notifyAll() methods notify all waiting threads.


Correct Response: 1

Explanation: The wait() method causes a single thread to wait until it is notified, while the notifyAll() method notifies all waiting threads. This allows for more fine-grained control over synchronization in Java.





Q: What is a Phaser class in Java?


A: A synchronization aid that allows multiple threads to wait for each other to reach a certain point.

B: A synchronization aid that allows only one thread to wait for other threads to reach a certain point.

C: A synchronization aid that allows multiple threads to race to reach a certain point.


Correct Response: 1

Explanation: The Phaser class in Java is a synchronization aid that allows multiple threads to wait for each other to reach a certain point. This allows for more fine-grained control over synchronization in multi-threaded environments.





Q: What is the difference between Executor and ExecutorService in Java?


A: Executor is a simple interface, while ExecutorService is a more feature-rich interface.

B: ExecutorService is a simple interface, while Executor is a more feature-rich interface.

C: Both Executor and ExecutorService are the same.

D: Neither Executor nor ExecutorService are interfaces.


Correct Response: 1

Explanation: Executor is a simple interface that provides a way to execute Runnable objects, while ExecutorService is a more feature-rich interface that provides additional methods for managing the execution of tasks, such as submitting tasks for execution, cancelling tasks, and awaiting task completion.





Q: What is a BlockingQueue in Java?


A: A queue that blocks when attempting to remove an item from an empty queue or add an item to a full queue.

B: A queue that does not block when attempting to remove an item from an empty queue or add an item to a full queue.

C: A queue that only blocks when attempting to remove an item from an empty queue.

D: A queue that only blocks when attempting to add an item to a full queue.


Correct Response: 1

Explanation: A BlockingQueue in Java is a queue that blocks when attempting to remove an item from an empty queue or add an item to a full queue. This allows for easier management of tasks in multi-threaded environments.





Q: What is a ThreadPoolExecutor in Java?


A: An executor that uses a pool of threads to execute tasks.

B: An executor that uses a single thread to execute tasks.

C: An executor that uses multiple threads to execute tasks randomly.


Correct Response: 1

Explanation: A ThreadPoolExecutor in Java is an executor that uses a pool of threads to execute tasks. This allows for efficient reuse of threads, improved performance, and easier management of tasks in multi-threaded environments.





Q: What is a RejectedExecutionHandler in Java?


A: A handler that is invoked when a task cannot be executed by a ThreadPoolExecutor.

B: A handler that is invoked when a task can be executed by a ThreadPoolExecutor.

C: A handler that is invoked when a task is executed by a ThreadPoolExecutor.


Correct Response: 1

Explanation: A RejectedExecutionHandler in Java is a handler that is invoked when a task cannot be executed by a ThreadPoolExecutor. This allows for custom handling of rejected tasks, such as logging, waiting, or discarding the task.





Q: What is a FutureTask in Java?


A: A task that returns a value when completed.

B: A task that does not return a value when completed.

C: A task that returns a value only when explicitly requested.


Correct Response: 1

Explanation: A FutureTask in Java is a task that returns a value when completed. This allows for asynchronous execution of tasks and retrieval of results in multi-threaded environments.





Q: What is a CompletionService in Java?


A: A service that allows for the retrieval of completed tasks.

B: A service that does not allow for the retrieval of completed tasks.

C: A service that only allows for the retrieval of completed tasks in a specific order.


Correct Response: 1

Explanation: A CompletionService in Java is a service that allows for the retrieval of completed tasks. This allows for efficient processing of a large number of tasks in multi-threaded environments.





Q: What is a CyclicBarrier in Java?


A: A synchronization aid that allows multiple threads to wait for each other to reach a certain point.

B: A synchronization aid that allows only one thread to wait for other threads to reach a certain point.

C: A synchronization aid that allows multiple threads to race to reach a certain point.


Correct Response: 1

Explanation: A CyclicBarrier in Java is a synchronization aid that allows multiple threads to wait for each other to reach a certain point. This allows for more fine-grained control over synchronization in multi-threaded environments and can be used to coordinate the actions of multiple threads.





Q: What is a Semaphore in the context of multi-threading in Java?


A: A synchronization aid that allows for a specified number of threads to access a shared resource simultaneously.

B: A synchronization aid that allows only one thread to access a shared resource at a time.

C: A synchronization aid that allows unlimited threads to access a shared resource simultaneously.


Correct Response: 1

Explanation: A Semaphore in the context of multi-threading in Java is a synchronization aid that allows for a specified number of threads to access a shared resource simultaneously. This helps regulate access to shared resources and prevent race conditions and data corruption.





Q: What is the difference between a Semaphore and a CountDownLatch in Java?


A: A Semaphore regulates access to a shared resource, while a CountDownLatch is used to wait for a set of events to occur.

B: A CountDownLatch regulates access to a shared resource, while a Semaphore is used to wait for a set of events to occur.

C: Both a Semaphore and a CountDownLatch regulate access to a shared resource.

D: Neither a Semaphore nor a CountDownLatch regulate access to a shared resource.


Correct Response: 1

Explanation: A Semaphore regulates access to a shared resource, while a CountDownLatch is used to wait for a set of events to occur. The CountDownLatch allows a thread to wait until a set number of events have occurred, while the Semaphore regulates access to a shared resource.





Q: What are the new features released in Java?


A: It depends on the version of Java.

B: Java does not have any new features.

C: All new features of Java have been listed above.


Correct Response: 1

Explanation: The new features released in Java depend on the version of Java. For example, Java 8 introduced features such as lambdas, streams, and functional interfaces, while Java 9 introduced the Java Platform Module System (JPMS) and improved the Java shell (JShell).





Q: What are the main benefits of new features introduced in Java?


A: Improved performance and increased efficiency.

B: Decreased performance and decreased efficiency.

C: No change in performance or efficiency.


Correct Response: 1

Explanation: The main benefits of new features introduced in Java include improved performance and increased efficiency. For example, the introduction of lambdas and streams in Java 8 improved the performance of code by allowing for more concise and efficient processing of data.





Q: What is a Lambda expression in Java?


A: A block of code that can be passed around as a value.

B: A value that can be passed around as a block of code.

C: A block of code that cannot be passed around as a value.


Correct Response: 1

Explanation: A Lambda expression in Java is a block of code that can be passed around as a value. This allows for more concise and expressive coding, as well as improved performance and increased efficiency.





Q: What are the three main parts of a Lambda expression in Java?


A: The parameters, the arrow, and the body.

B: The body, the arrow, and the return type.

C: The parameters, the body, and the return type.


Correct Response: 1

Explanation: The three main parts of a Lambda expression in Java are the parameters, the arrow, and the body. The parameters specify the inputs to the lambda expression, the arrow separates the parameters from the body, and the body specifies the code to be executed.





Q: What is the data type of a Lambda expression?


A: A functional interface.

B: A primitive data type.

C: An object.


Correct Response: 1

Explanation: The data type of a Lambda expression is a functional interface. A functional interface is an interface with a single abstract method, which can be used as the target type for a lambda expression.





Q: What is the meaning of following lambda expression?


A: The meaning of a lambda expression depends on its context.

B: A lambda expression is a meaningless symbol.

C: A lambda expression is a special type of object.


Correct Response: 1

Explanation: The meaning of a lambda expression depends on its context. A lambda expression is a block of code that can be passed around as a value, and its meaning depends on the functional interface it is used to implement and the parameters and body of the expression.





Q: Why did Oracle release a new version of Java like Java ?


A: To provide improved features and performance for Java developers.

B: To make Java development more difficult.

C: To replace Java with a new programming language.


Correct Response: 1

Explanation: Oracle releases new versions of Java, such as Java 8, in order to provide improved features and performance for Java developers. New releases of Java typically include new language features, libraries, and performance improvements to make Java development easier and more efficient.





Q: What are the advantages of a lambda expression?


A: Improved readability and conciseness of code, increased efficiency, and improved performance.

B: Decreased readability and conciseness of code, decreased efficiency, and decreased performance.

C: No change in readability, conciseness, efficiency, or performance.


Correct Response: 1

Explanation: The advantages of a lambda expression include improved readability and conciseness of code, increased efficiency, and improved performance. Lambda expressions allow for more concise and expressive coding, as well as improved performance and increased efficiency in multi-threaded environments.





Q: What is a Functional interface in Java ?


A: An interface with a single abstract method.

B: An interface with multiple abstract methods.

C: An interface with no abstract methods.


Correct Response: 1

Explanation: A Functional interface in Java is an interface with a single abstract method. Functional interfaces can be used as the target type for a lambda expression, and they provide a way to represent functions as objects in Java.





Q: What is a Single Abstract Method (SAM) interface in Java?


A: An interface with a single abstract method.

B: An interface with multiple abstract methods.

C: An interface with no abstract methods.


Correct Response: 1

Explanation: A Single Abstract Method (SAM) interface in Java is an interface with a single abstract method. SAM interfaces are also known as functional interfaces and can be used as the target type for a lambda expression.





Q: How can we define a Functional interface in Java?


A: By creating an interface with a single abstract method.

B: By creating an interface with multiple abstract methods.

C: By creating an interface with no abstract methods.


Correct Response: 1

Explanation: A Functional interface in Java can be defined by creating an interface with a single abstract method. This allows the interface to be used as the target type for a lambda expression and provides a way to represent functions as objects in Java.





Q: Why do we need Functional interface in Java?


A: To represent functions as objects and improve the readability and conciseness of code.

B: To make Java development more difficult.

C: To replace Java with a new programming language.


Correct Response: 1

Explanation: We need Functional interfaces in Java in order to represent functions as objects and improve the readability and conciseness of code. Lambda expressions and functional interfaces provide a way to write more expressive and efficient code in Java, especially in multi-threaded environments.





Q: Is it mandatory to use @FunctionalInterface annotation to define a Functional interface in Java?


A: No, it is not mandatory to use the @FunctionalInterface annotation to define a functional interface in Java.

B: Yes, it is mandatory to use the @FunctionalInterface annotation to define a functional interface in Java.

C: The @FunctionalInterface annotation is only used in special cases.


Correct Response: 1

Explanation: No, it is not mandatory to use the @FunctionalInterface annotation to define a functional interface in Java. However, it is a good practice to use the annotation to clearly indicate that an interface is intended to be used as a functional interface, and to ensure that the interface meets the requirements of a functional interface.





Q: What are the differences between Collection and Stream API in Java?


A: Collections are used to store data, while Streams are used to process data.

B: Streams are used to store data, while Collections are used to process data.

C: Both Collections and Streams are used to store data.

D: Neither Collections nor Streams are used to store or process data.


Correct Response: 1

Explanation: The main difference between Collection and Stream API in Java is that Collections are used to store data, while Streams are used to process data. Streams provide a way to perform operations on data in a functional and efficient manner, while Collections are used to store and manipulate data.





Q: What are the main uses of Stream API in Java?


A: Processing data in a functional and efficient manner.

B: Storing data.

C: Both processing and storing data.

D: Neither processing nor storing data.


Correct Response: 1

Explanation: The main use of Stream API in Java is to process data in a functional and efficient manner. Streams provide a way to perform operations on data, such as filtering, mapping, and reducing, in a more concise and efficient manner than traditional iteration and looping constructs.





Q: What are the differences between Intermediate and Terminal Operations in Java Streams?


A: Intermediate operations produce a stream, while terminal operations produce a non-stream result.

B: Terminal operations produce a stream, while intermediate operations produce a non-stream result.

C: Both intermediate and terminal operations produce a stream.

D: Neither intermediate nor terminal operations produce a stream.


Correct Response: 1

Explanation: The difference between Intermediate and Terminal Operations in Java Streams is that Intermediate operations produce a stream, while terminal operations produce a non-stream result. Intermediate operations, such as filter and map, allow for the creation of a new stream based on the input data, while terminal operations, such as forEach and reduce, produce a non-stream result.





Q: What is a Spliterator in Java?


A: A tool for iterating and splitting elements in a stream.

B: A tool for aggregating elements in a stream.

C: A tool for filtering elements in a stream.


Correct Response: 1

Explanation: A Spliterator in Java is a tool for iterating and splitting elements in a stream. Spliterators provide a way to traverse elements in a stream and to divide a stream into multiple parts for parallel processing.





Q: What are the differences between Iterator and Spliterator in Java?


A: An Iterator provides a sequential iteration, while a Spliterator provides a parallel iteration and splitting.

B: A Spliterator provides a sequential iteration, while an Iterator provides a parallel iteration and splitting.

C: Both Iterator and Spliterator provide sequential iteration.

D: Neither Iterator nor Spliterator provide sequential iteration.


Correct Response: 1

Explanation: The main difference between an Iterator and a Spliterator in Java is that an Iterator provides a sequential iteration, while a Spliterator provides a parallel iteration and splitting. Spliterators allow for the efficient parallel processing of data, while Iterators provide a simple way to traverse data sequentially.





Q: What is Type Inference in Java?


A: A feature that allows the Java compiler to deduce the type of an expression based on context.

B: A feature that prevents the Java compiler from deducing the type of an expression based on context.

C: A feature that forces the Java programmer to explicitly specify the type of an expression.


Correct Response: 1

Explanation: Type Inference in Java is a feature that allows the Java compiler to deduce the type of an expression based on context. This allows for more concise and expressive code, as the programmer does not need to explicitly specify the type of every expression.





Q: Does Java support Type Inference?


A: Yes, Java supports Type Inference.

B: No, Java does not support Type Inference.

C: Type Inference is only available in certain versions of Java.


Correct Response: 1

Explanation: Yes, Java supports Type Inference. Type Inference was introduced in Java 8 and allows for more concise and expressive code by allowing the Java compiler to deduce the type of an expression based on context.





Q: How does Internal Iteration work in Java?


A: Internal iteration is a process where the collection or data structure is processed internally by a forEach method or similar construct.

B: Internal iteration is a process where the collection or data structure is processed externally by a forEach method or similar construct.

C: Internal iteration is a process where the collection or data structure is processed by a forEach method or similar construct, but the exact mechanism depends on the implementation.


Correct Response: 1

Explanation: Internal iteration in Java is a process where the collection or data structure is processed internally by a forEach method or similar construct. This allows for more efficient processing of data, as the implementation can optimize the iteration process, and also provides a more concise and readable way to process data.





Q: What are the main differences between Internal and External Iterator?


A: Internal iteration is performed by the collection or data structure, while external iteration is performed by the programmer.

B: External iteration is performed by the collection or data structure, while internal iteration is performed by the programmer.

C: Both internal and external iteration are performed by the programmer.

D: Neither internal nor external iteration is performed by the programmer.


Correct Response: 1

Explanation: The main difference between Internal and External Iteration is that Internal iteration is performed by the collection or data structure, while external iteration is performed by the programmer. Internal iteration provides a more efficient and concise way to process data, while external iteration provides more control and flexibility over the iteration process.





Q: What are the main advantages of Internal Iteration over External Iteration in Java?


A: More efficient processing, more concise and readable code, and less control and flexibility over the iteration process.

B: Less efficient processing, less concise and readable code, and more control and flexibility over the iteration process.

C: More efficient processing, less concise and readable code, and more control and flexibility over the iteration process.

D: Less efficient processing, more concise and readable code, and less control and flexibility over the iteration process.


Correct Response: 1

Explanation: The main advantages of Internal Iteration over External Iteration in Java are more efficient processing, more concise and readable code, and less control and flexibility over the iteration process. Internal iteration allows the collection or data structure to perform the iteration process, which can be optimized for performance and conciseness, while external iteration provides more control and flexibility over the iteration process.





Q: What are the applications in which we should use Internal Iteration?


A: Applications where performance and conciseness are a priority, and control and flexibility over the iteration process are not as important.

B: Applications where control and flexibility over the iteration process are a priority, and performance and conciseness are not as important.

C: Applications where both performance and control are important.

D: Applications where neither performance nor control are important.


Correct Response: 1

Explanation: Internal iteration should be used in applications where performance and conciseness are a priority, and control and flexibility over the iteration process are not as important. Internal iteration provides a more efficient and concise way to process data, but with less control over the iteration process.





Q: What is the main disadvantage of Internal Iteration over External Iteration?


A: Less control and flexibility over the iteration process.

B: More control and flexibility over the iteration process.

C: The same level of control and flexibility over the iteration process.

D: Neither less nor more control and flexibility over the iteration process.


Correct Response: 1

Explanation: The main disadvantage of Internal Iteration over External Iteration is less control and flexibility over the iteration process. Internal iteration allows the collection or data structure to perform the iteration process, which can be optimized for performance and conciseness, but provides less control over the iteration process.





Q: Can we provide implementation of a method in a Java Interface?


A: No, we cannot provide an implementation of a method in a Java Interface.

B: Yes, we can provide an implementation of a method in a Java Interface using default methods.

C: Yes, we can provide an implementation of a method in a Java Interface using abstract methods.

D: Yes, we can provide an implementation of a method in a Java Interface using both default and abstract methods.


Correct Response: 2

Explanation: Yes, we can provide an implementation of a method in a Java Interface using default methods. Java 8 introduced the concept of default methods, which allow an interface to provide an implementation of a method. This allows for the addition of new functionality to existing interfaces without breaking backwards compatibility.





Q: What is a Default Method in an Interface?


A: A method in an interface that provides a default implementation.

B: A method in an interface that does not provide a default implementation.

C: A method in an interface that must be overridden by all implementing classes.


Correct Response: 1

Explanation: A Default Method in an Interface is a method in an interface that provides a default implementation. Java 8 introduced the concept of default methods, which allow an interface to provide an implementation of a method. This allows for the addition of new functionality to existing interfaces without breaking backwards compatibility.





Q: Why do we need Default method in a Java Interface?


A: To add new functionality to existing interfaces without breaking backwards compatibility.

B: To prevent new functionality from being added to existing interfaces.

C: To force all implementing classes to provide an implementation of the method.


Correct Response: 1

Explanation: We need Default Methods in a Java Interface to add new functionality to existing interfaces without breaking backwards compatibility. Default methods provide a way to add new functionality to existing interfaces while still allowing older implementations to work without modification.





Q: What is the purpose of a Static method in an Interface in Java?


A: To provide a method that can be called without creating an instance of the interface.

B: To provide a method that must be called on an instance of the interface.

C: To provide a method that can only be called on an instance of the interface.


Correct Response: 1

Explanation: The purpose of a Static method in an Interface in Java is to provide a method that can be called without creating an instance of the interface. Static methods in interfaces can be invoked using the interface name, rather than an instance of the interface.





Q: What are the core ideas behind the Date/Time API of Java?


A: Immutable objects, value-based classes, and the separation of time-based concepts into distinct objects.

B: Mutable objects, reference-based classes, and the combination of time-based concepts into single objects.

C: Immutable objects, reference-based classes, and the combination of time-based concepts into single objects.

D: Mutable objects, value-based classes, and the separation of time-based concepts into distinct objects.


Correct Response: 1

Explanation: The core ideas behind the Date/Time API of Java are Immutable objects, value-based classes, and the separation of time-based concepts into distinct objects. The Date/Time API provides a way to represent and manipulate date and time values in a consistent and efficient manner, while preserving the important characteristics of immutability and value-based classes.





Q: What are the advantages of new Date and Time API in Java over old Date API?


A: Improved type safety, more readable and concise code, and better support for representing and manipulating date and time values.

B: Reduced type safety, less readable and concise code, and worse support for representing and manipulating date and time values.

C: Improved type safety, less readable and concise code, and worse support for representing and manipulating date and time values.

D: Reduced type safety, more readable and concise code, and better support for representing and manipulating date and time values.


Correct Response: 1

Explanation: The advantages of new Date and Time API in Java over old Date API are Improved type safety, more readable and concise code, and better support for representing and manipulating date and time values. The new Date and Time API provides a more consistent and efficient way to represent and manipulate date and time values, while also improving type safety and making the code more readable and concise.





Q: What are the main differences between legacy Date/Time API in Java and Date/Time API of Java?


A: The new Date and Time API is more type-safe, readable, and concise, and provides better support for representing and manipulating date and time values. The legacy Date/Time API is less type-safe, less readable, and less concise, and provides weaker support for representing and manipulating date and time values.

B: The new Date and Time API is less type-safe, less readable, and less concise, and provides weaker support for representing and manipulating date and time values. The legacy Date/Time API is more type-safe, readable, and concise, and provides better support for representing and manipulating date and time values.

C: Both the new Date and Time API and the legacy Date/Time API are equally type-safe, readable, concise, and provide the same level of support for representing and manipulating date and time values.

D: Neither the new Date and Time API nor the legacy Date/Time API are type-safe, readable, concise, or provide support for representing and manipulating date and time values.


Correct Response: 1

Explanation: The main differences between legacy Date/Time API in Java and Date/Time API of Java are that the new Date and Time API is more type-safe, readable, and concise, and provides better support for representing and manipulating date and time values, while the legacy Date/Time API is less type-safe, less readable, and less concise, and provides weaker support for representing and manipulating date and time values.





Q: How can we get duration between two dates or time in Java?


A: By using the Duration class in the new Date and Time API.

B: By using the legacy Date class in the old Date/Time API.

C: By using a third-party library.


Correct Response: 1

Explanation: We can get the duration between two dates or time in Java by using the Duration class in the new Date and Time API. The Duration class provides a way to represent and manipulate durations of time, and can be used to calculate the difference between two dates or times.





Q: What is the new method family introduced in Java for processing of Arrays on multi-core machines?


A: The Stream API.

B: The Fork/Join framework.

C: The ThreadPoolExecutor.


Correct Response: 1

Explanation: The new method family introduced in Java for processing of Arrays on multi-core machines is the Stream API. The Stream API provides a way to process arrays and collections in parallel, taking advantage of the multiple cores in modern processors to achieve improved performance.





Q: How does Java solve Diamond problem of Multiple Inheritance?


A: By using Interfaces and implementing multiple Interfaces in a class.

B: By using Abstract classes and extending multiple Abstract classes in a class.

C: By using Interfaces and extending multiple Interfaces in a class.


Correct Response: 1

Explanation: Java solves the Diamond problem of Multiple Inheritance by using Interfaces and implementing multiple Interfaces in a class. In Java, a class can implement multiple interfaces, but can only extend a single class. This provides a way to achieve multiple inheritance without the ambiguity that can arise in traditional multiple inheritance systems.





Q: What are the differences between Predicate, Supplier and Consumer in Java?


A: Predicate represents a boolean-valued function that takes an argument, Supplier represents a function that takes no arguments and returns a value, and Consumer represents a function that takes an argument and returns no result.

B: Predicate represents a function that takes no arguments and returns a value, Supplier represents a boolean-valued function that takes an argument, and Consumer represents a function that takes no arguments and returns no result.

C: Predicate represents a function that takes an argument and returns a value, Supplier represents a boolean-valued function that takes no arguments, and Consumer represents a function that takes an argument and returns a result.

D: Predicate represents a function that takes no arguments and returns no result, Supplier represents a boolean-valued function that takes an argument, and Consumer represents a function that takes an argument and returns no result.


Correct Response: 1

Explanation: Predicate represents a boolean-valued function that takes an argument, Supplier represents a function that takes no arguments and returns a value, and Consumer represents a function that takes an argument and returns no result. These functional interfaces are part of the Java 8 functional programming features, and can be used to pass blocks of code as arguments to methods, or to represent operations that can be performed on values.





Q: Is it possible to have default method definition in an interface without marking it with default keyword?


A: No, it is not possible to have a default method definition in an interface without marking it with the default keyword.

B: Yes, it is possible to have a default method definition in an interface without marking it with the default keyword.

C: It depends on the version of Java being used.


Correct Response: 1

Explanation: No, it is not possible to have a default method definition in an interface without marking it with the default keyword. The default keyword is used to indicate that a method in an interface is a default method, and provides a default implementation that can be overridden by classes that implement the interface.





Q: Can we create a class that implements two Interfaces with default methods of same name and signature?


A: Yes, we can create a class that implements two interfaces with default methods of the same name and signature.

B: No, we cannot create a class that implements two interfaces with default methods of the same name and signature.

C: It depends on the version of Java being used.


Correct Response: 1

Explanation: Yes, we can create a class that implements two interfaces with default methods of the same name and signature. If the class implements two interfaces that have default methods with the same name and signature, it must provide its own implementation of the method to resolve the conflict, or it can use the super keyword to specify which default implementation it wants to use.





Q: How Java supports Multiple Inheritance?


A: Java supports Multiple Inheritance through Interfaces.

B: Java supports Multiple Inheritance through Abstract classes.

C: Java does not support Multiple Inheritance.

D: Java supports Multiple Inheritance through multiple inheritance of classes.


Correct Response: 1

Explanation: Java supports Multiple Inheritance through Interfaces. In Java, a class can implement multiple interfaces, but can only extend a single class. This provides a way to achieve multiple inheritance without the ambiguity that can arise in traditional multiple inheritance systems.





Q: In case we create a class that extends a base class and implements an interface. If both base class and interface have a default method with the same name and arguments, then which definition will be picked by JVM?


A: The definition in the class will be picked by the JVM.

B: The definition in the base class will be picked by the JVM.

C: The definition in the interface will be picked by the JVM.

D: It depends on the version of Java being used.


Correct Response: 1

Explanation: The definition in the class will be picked by the JVM. If a class extends a base class and implements an interface, and both the base class and the interface have a default method with the same name and arguments, the definition in the class will be picked by the JVM. The class can use the super keyword to specify which default implementation it wants to use.





Q: If we create the same method and define it in a class, in its parent class, and in an interface implemented by the class, then definition will be invoked if we access it using the reference of the Interface and the object of the class?


A: The definition in the class will be invoked.

B: The definition in the parent class will be invoked.

C: The definition in the interface will be invoked.


Correct Response: 1

Explanation: The definition in the class will be invoked. If a method is defined in a class, in its parent class, and in an interface implemented by the class, the definition in the class will be invoked if we access it using the reference of the interface and the object of the class.





Q: Can we access a static method of an interface by using a reference of the interface?


A: Yes, we can access a static method of an interface by using a reference of the interface.

B: No, we cannot access a static method of an interface by using a reference of the interface.

C: It depends on the version of Java being used.


Correct Response: 1

Explanation: Yes, we can access a static method of an interface by using a reference of the interface. In Java, static methods in interfaces can be accessed using the name of the interface, without the need to create an instance of the interface.





Q: How can you get the name of a Parameter in Java by using reflection?


A: By using the getName() method of the Parameter class.

B: By using the getDeclaredMethods() method of the Class class.

C: By using the getFields() method of the Class class.


Correct Response: 1

Explanation: You can get the name of a Parameter in Java by using the getName() method of the Parameter class. The Parameter class is part of the Java Reflection API, and provides information about the parameters of a method or constructor.





Q: What is Optional in Java?


A: Optional is a container object which may or may not contain a non-null value.

B: Optional is a container object which may contain a null value.

C: Optional is a container object which must contain a non-null value.


Correct Response: 1

Explanation: Optional is a container object which may or may not contain a non-null value. It is part of the Java 8 functional programming features, and provides a way to represent optional values without the need for null checks.





Q: What are the uses of Optional?


A: To represent an optional value.

B: To perform null checks.

C: To simplify error handling.

D: To simplify the code for dealing with null values.


Correct Response: 1, 3, 4

Explanation: Optional can be used to represent an optional value, simplify error handling, and simplify the code for dealing with null values. By using Optional, developers can avoid null checks and improve the readability and maintainability of their code.





Q: Which method in Optional provides the fallback mechanism in case of a null value?


A: The orElse() method provides the fallback mechanism in case of a null value.

B: The get() method provides the fallback mechanism in case of a null value.

C: The orElseGet() method provides the fallback mechanism in case of a null value.

D: The orElseThrow() method provides the fallback mechanism in case of a null value.


Correct Response: 1

Explanation: The orElse() method provides the fallback mechanism in case of a null value. The orElse() method returns the value contained in the Optional object if it is present, or returns the specified default value if it is not.





Q: How can we get the current time by using the Date/Time API of Java?


A: By using the LocalDateTime.now() method.

B: By using the Date.now() method.

C: By using the System.currentTimeMillis() method.


Correct Response: 1

Explanation: By using the LocalDateTime.now() method. The LocalDateTime.now() method returns the current date and time using the system clock in the default time zone.





Q: Is it possible to define a static method in an Interface?


A: Yes, it is possible to define a static method in an interface.

B: No, it is not possible to define a static method in an interface.

C: It depends on the version of Java being used.


Correct Response: 1

Explanation: Yes, it is possible to define a static method in an interface. In Java 8, interfaces can include static methods, which can be accessed using the name of the interface, without the need to create an instance of the interface.





Q: How can we analyze the dependencies in Java classes and packages?


A: By using a class diagram.

B: By using a package diagram.

C: By using a dependency diagram.


Correct Response: 2

Explanation: By using a package diagram. A package diagram is a UML diagram that shows the relationships between packages in a system. It can be used to analyze the dependencies between packages and classes, and to identify potential areas for refactoring or improvement.





Q: What is the type of a Lambda expression in Java?


A: A Lambda expression has no type in Java.

B: A Lambda expression has the type of its functional interface.

C: A Lambda expression has the type of its implementation.


Correct Response: 2

Explanation: A Lambda expression has the type of its functional interface. In Java, a Lambda expression is an instance of a functional interface, and its type is determined by the functional interface it implements.





Q: What is the target type of a lambda expression?


A: The target type of a lambda expression is the type of the functional interface that the lambda expression implements.

B: The target type of a lambda expression is the type of its implementation.

C: The target type of a lambda expression is the type of its arguments.


Correct Response: 1

Explanation: The target type of a lambda expression is the type of the functional interface that the lambda expression implements. In Java, a Lambda expression is an instance of a functional interface, and the target type is determined by the functional interface it implements.





Q: What are the main differences between an interface with a default method and an abstract class in Java?


A: An interface with a default method can have multiple implementations, while an abstract class can have only one implementation.

B: An abstract class can have instance variables, while an interface with a default method cannot.

C: An interface with a default method can inherit from multiple interfaces, while an abstract class can only inherit from one class.

D: An abstract class can have concrete methods, while an interface with a default method can only have abstract methods.


Correct Response: 2, 3

Explanation: An abstract class can have instance variables and can only inherit from one class, while an interface with a default method cannot have instance variables and can inherit from multiple interfaces.





Q: Is there any difference between the expressions a = a + b and a += b?


A: No, there is no difference between the expressions a = a + b and a += b.

B: Yes, the expression a += b is more efficient than a = a + b.

C: Yes, the expression a += b is a shorthand for a = a + b.


Correct Response: 3

Explanation: Yes, the expression a += b is a shorthand for a = a + b. The expression a += b adds the value of b to a and assigns the result back to a. It is equivalent to writing a = a + b, but is more concise and easier to read.





Q: What does the expression . / . return? Will there be any compilation error?


A: The expression . / . will return an error, because it is not a valid expression.

B: The expression . / . will return the value of 0.

C: The expression . / . will return the result of the division operation.


Correct Response: 1

Explanation: The expression . / . will return an error, because it is not a valid expression. In Java, the expression . / . is not a valid syntax, and will result in a compilation error.





Q: Can we use multiple main methods in multiple classes?


A: Yes, we can use multiple main methods in multiple classes.

B: No, we cannot use multiple main methods in multiple classes.

C: It depends on the version of Java being used.


Correct Response: 1

Explanation: Yes, we can use multiple main methods in multiple classes. In Java, a class can have a main method, and multiple classes can have their own main method. When the program is executed, we can specify which main method to run by passing the class name as an argument to the java command.





Q: Does Java allow you to override a private or static method?


A: No, Java does not allow you to override a private or static method.

B: Yes, Java allows you to override a private method.

C: Yes, Java allows you to override a static method.

D: Both B and C.


Correct Response: 1

Explanation: No, Java does not allow you to override a private or static method. In Java, private and static methods are not inherited by subclasses, and cannot be overridden.





Q: What happens when you put a key object in a HashMap that is already present?


A: The key object will be replaced by the new value.

B: The value associated with the key object will be appended to the new value.

C: The value associated with the key object will be overwritten by the new value.


Correct Response: 3

Explanation: The value associated with the key object will be overwritten by the new value. In Java, when you put a key object in a HashMap that is already present, the new value will overwrite the old value associated with the key.





Q: How can you make sure that N threads can access N resources without deadlock?


A: By using the synchronized keyword.

B: By using the wait() and notifyAll() methods.

C: By using a lock.

D: By using a semaphore.


Correct Response: 4

Explanation: By using a semaphore. A semaphore is a synchronization primitive that can be used to control access to a shared resource by multiple threads. By using a semaphore, you can ensure that N threads can access N resources without deadlock.





Q: How can you determine if JVM is 32-bit or 64-bit from a Java program?


A: By using the System.getProperty("sun.arch.data.model") method.

B: By using the System.getProperty("java.vm.version") method.

C: By using the System.getProperty("java.version") method.


Correct Response: 1

Explanation: By using the System.getProperty("sun.arch.data.model") method. The System.getProperty("sun.arch.data.model") method returns the data model of the JVM, which can be either 32 or 64, depending on whether the JVM is 32-bit or 64-bit.





Q: What is the right data type to represent Money (like Dollar/Pound) in Java?


A: int

B: float

C: double

D: BigDecimal


Correct Response: 4

Explanation: BigDecimal





Q: How can you do multiple inheritances in Java?


A: By using interfaces.

B: By using inheritance.

C: By using abstract classes.


Correct Response: 1

Explanation: By using interfaces. In Java, multiple inheritances can be achieved by using interfaces. A class can implement multiple interfaces, and thus inherit the methods and fields declared in those interfaces.





Q: Is the ++ operation thread-safe in Java?


A: No, the ++ operation is not thread-safe in Java.

B: Yes, the ++ operation is thread-safe in Java.

C: It depends on the version of Java being used.


Correct Response: 1

Explanation: No, the ++ operation is not thread-safe in Java. The ++ operation is a simple, atomic operation that increments the value of a variable. However, in a multi-threaded environment, multiple threads may access the same variable concurrently, leading to race conditions and unexpected results. To ensure thread-safety, it is recommended to use synchronization or locks when incrementing variables in a multi-threaded environment.





Q: How can you access a non-static variable from the static context?


A: By creating an instance of the class and accessing the variable through the instance.

B: By using the this keyword.

C: By using the class name and the dot operator.


Correct Response: 1

Explanation: By creating an instance of the class and accessing the variable through the instance. In Java, you can access a non-static variable from a static context by creating an instance of the class and accessing the variable through the instance.





Q: Let's say there is a method that throws NullPointerException in the superclass. Can we override it with a method that throws RuntimeException?


A: No, we cannot override the method with a method that throws a different exception.

B: Yes, we can override the method with a method that throws a different exception.

C: It depends on the version of Java being used.


Correct Response: 2

Explanation: Yes, we can override the method with a method that throws a different exception. In Java, when you override a method, you can change the exception that is thrown by the method. If a method in a superclass throws a NullPointerException, you can override it in a subclass with a method that throws a RuntimeException.





Q: How can you mark an array volatile in Java?


A: By declaring the array as volatile.

B: By declaring each element of the array as volatile.

C: Arrays cannot be declared volatile in Java.


Correct Response: 2

Explanation: By declaring each element of the array as volatile. In Java, arrays cannot be declared volatile. However, you can declare each element of the array as volatile to ensure that changes made to the elements are visible to all threads.





Q: What is a thread local variable in Java?


A: A variable that is local to a thread.

B: A variable that is shared between threads.

C: A variable that is global to all threads.


Correct Response: 1

Explanation: A variable that is local to a thread. In Java, a thread local variable is a variable that is local to a thread, and is not shared between threads. Thread local variables are useful for storing values that are specific to a particular thread, and cannot be accessed by other threads.





Q: What is the difference between sleep() and wait() methods in Java?


A: The sleep() method puts a thread to sleep for a specified amount of time, while the wait() method releases the lock held by a thread and waits for another thread to complete its execution.

B: The sleep() method releases the lock held by a thread and waits for another thread to complete its execution, while the wait() method puts a thread to sleep for a specified amount of time.

C: The sleep() method is a static method of the Thread class, while the wait() method is an instance method of the Object class.

D: Both sleep() and wait() methods are equivalent and can be used interchangeably.


Correct Response: 1

Explanation: The sleep() method puts a thread to sleep for a specified amount of time, while the wait() method releases the lock held by a thread and waits for another thread to complete its execution. The sleep() method is a static method of the Thread class and is used to pause the execution of a thread for a specified amount of time. The wait() method, on the other hand, is an instance method of the Object class and is used to release the lock held by a thread and wait for another thread to complete its execution.





Q: Can you create an Immutable object that contains a mutable object?


A: No, you cannot create an Immutable object that contains a mutable object.

B: Yes, you can create an Immutable object that contains a mutable object.

C: It depends on the implementation.


Correct Response: 2

Explanation: Yes, you can create an Immutable object that contains a mutable object. However, you need to take care that the mutable object is not accessible from outside the Immutable object. For example, you can store a mutable object as a private field in an Immutable object and provide only accessor methods for it. This way, the mutable object can be changed only from within the Immutable object, and not from outside.





Q: How can you convert an Array of bytes to String?


A: By using the toString() method of the Byte class.

B: By using the new String() constructor.

C: By using the valueOf() method of the String class.


Correct Response: 2

Explanation: By using the new String() constructor. In Java, you can convert an Array of bytes to a String by using the new String() constructor and passing the byte array and the character encoding to be used. For example, new String(byteArray, "UTF-8") will create a new String from the byte array using the UTF-8 encoding.





Q: What is the difference between CyclicBarrier and CountDownLatch class?


A: The CyclicBarrier class is used to wait for a set of threads to complete their execution, while the CountDownLatch class is used to count down from a specified number to zero.

B: The CyclicBarrier class is used to count down from a specified number to zero, while the CountDownLatch class is used to wait for a set of threads to complete their execution.

C: The CyclicBarrier class is used to wait for a specified number of threads to reach a barrier, while the CountDownLatch class is used to wait for a specified number of events to occur.

D: The CyclicBarrier class and the CountDownLatch class are equivalent and can be used interchangeably.


Correct Response: 1

Explanation: The CyclicBarrier class is used to wait for a set of threads to complete their execution, while the CountDownLatch class is used to count down from a specified number to zero. The CyclicBarrier class is used to wait for a specified number of threads to reach a barrier, at which point all the threads are released. The CountDownLatch class, on the other hand, is used to wait for a specified number of events to occur, and the threads are released as soon as the count reaches zero.





Q: What is the difference between StringBuffer and StringBuilder?


A: The StringBuffer class is synchronized, while the StringBuilder class is not synchronized.

B: The StringBuffer class is not synchronized, while the StringBuilder class is synchronized.

C: The StringBuffer class is used for legacy code, while the StringBuilder class is used for new code.

D: There is no difference between the StringBuffer class and the StringBuilder class.


Correct Response: 1

Explanation: The StringBuffer class is synchronized, while the StringBuilder class is not synchronized. Both StringBuffer and StringBuilder are used to represent a mutable sequence of characters, but StringBuffer is thread-safe, meaning that multiple threads can access it simultaneously without causing any issues. The StringBuilder class, on the other hand, is not thread-safe and is generally faster than StringBuffer.





Q: Which class contains clone method? Cloneable or Object class?


A: The Cloneable interface contains the clone() method.

B: The Object class contains the clone() method.

C: Both the Cloneable interface and the Object class contain the clone() method.


Correct Response: 2

Explanation: The Object class contains the clone() method. The Cloneable interface is used to indicate that an object is cloneable, but it does not contain the actual clone() method. The clone() method is defined in the Object class and is used to create a copy of an object.





Q: How will you take thread dump in Java?


A: Using jstack command line tool.

B: Using jmap command line tool.

C: Using jstat command line tool.


Correct Response: 1

Explanation: A thread dump in Java can be taken using the jstack command line tool. This tool provides a snapshot of the state of all threads in a Java process.





Q: Can you cast an int variable into a byte variable? What happens if the value of int is larger than byte?


A: Yes, it can be done, and the value will be truncated if it is larger than byte.

B: No, it cannot be done as int is larger than byte.

C: Yes, it can be done, and the value will be rounded if it is larger than byte.


Correct Response: 1

Explanation: An int variable can be cast into a byte variable, but the value will be truncated if it is larger than byte. The byte data type can only store values from -128 to 127.





Q: In Java, can we store a double value in a long variable without explicit casting?


A: No, we cannot store a double value in a long variable without explicit casting.

B: Yes, we can store a double value in a long variable without explicit casting.

C: No, we cannot store a double value in any variable without explicit casting.


Correct Response: 1

Explanation: We cannot store a double value in a long variable without explicit casting as the double data type uses 64 bits to store values, while the long data type uses only 64 bits. An explicit cast is required to convert a double value to a long value.





Q: What will this return * . == . ? true or false?


A: TRUE

B: FALSE

C: Compilation Error


Correct Response: 2

Explanation: This code will return false as "." and "." are not equal. The first symbol "" is a wildcard character that matches zero or more characters, while the second symbol "." is a dot that matches any single character.





Q: Out of an int and Integer, which one takes more memory?


A: An int takes more memory.

B: An Integer takes more memory.

C: Both int and Integer take the same amount of memory.


Correct Response: 2

Explanation: An Integer takes more memory than an int as Integer is an object, while int is a primitive data type. An Integer object requires additional memory to store information such as the type of the object and its identity, whereas an int value takes only 4 bytes of memory.





Q: Can we use String in the switch case statement in Java?


A: No, we cannot use String in the switch case statement in Java.

B: Yes, we can use String in the switch case statement in Java starting from Java 7.

C: Yes, we can use String in the switch case statement in Java starting from Java 6.


Correct Response: 2

Explanation: Starting from Java 7, we can use String in the switch case statement in Java. Prior to Java 7, only primitive data types and enums could be used in switch case statements.





Q: Can we use multiple main methods in the same class?


A: No, we cannot have multiple main methods in the same class.

B: Yes, we can have multiple main methods in the same class, but only one will be executed.

C: Yes, we can have multiple main methods in the same class, and all will be executed.


Correct Response: 1

Explanation: We cannot have multiple main methods in the same class as only one main method can be executed as the entry point of the program. If there are multiple main methods, the compiler will raise an error.





Q: When creating an abstract class, is it a good idea to call abstract methods inside its constructor?


A: No, it is not a good idea to call abstract methods inside its constructor as it will result in a compile-time error.

B: Yes, it is a good idea to call abstract methods inside its constructor to enforce implementation by subclasses.

C: No, it is not a good idea to call abstract methods inside its constructor as it may lead to unexpected behavior.


Correct Response: 1

Explanation: It is not a good idea to call abstract methods inside its constructor as it will result in a compile-time error. Abstract methods are meant to be overridden by subclasses and cannot be called directly.





Q: How can you do constructor chaining in Java?


A: By calling a constructor from another constructor of the same class using the "this" keyword.

B: By calling a constructor from another constructor of the same class using the "super" keyword.

C: By calling a constructor from a method of the same class using the "this" keyword.


Correct Response: 1

Explanation: Constructor chaining can be done by calling a constructor from another constructor of the same class using the "this" keyword. This allows for reusing the code from one constructor in another constructor.





Q: How can we find the memory usage of JVM from Java code?


A: By using the Runtime.totalMemory() method.

B: By using the System.totalMemory() method.

C: By using the System.freeMemory() method.


Correct Response: 1

Explanation: We can find the memory usage of JVM from Java code by using the Runtime.totalMemory() method. This method returns the total amount of memory in bytes that is available to the JVM.





Q: What is the difference between x == y and x.equals(y) expressions in Java?


A: x == y checks if the two references refer to the same object, while x.equals(y) checks if the objects have the same value.

B: x == y checks if the objects have the same value, while x.equals(y) checks if the two references refer to the same object.

C: Both x == y and x.equals(y) check if the objects have the same value.


Correct Response: 1

Explanation: The expression x == y checks if the two references refer to the same object, while x.equals(y) checks if the objects have the same value. The equals method must be overridden in the object's class to define how two objects are compared for equality.





Q: How can you guarantee that the garbage collection takes place?


A: You cannot guarantee that the garbage collection takes place.

B: By calling System.gc() method.

C: By calling Runtime.gc() method.


Correct Response: 1

Explanation: You cannot guarantee that the garbage collection takes place, as it is controlled by the JVM. However, you can suggest the JVM to run the garbage collector by calling System.gc() or Runtime.gc(). This is not a guarantee that the garbage collector will run, as the JVM may ignore the request.





Q: What is the relation between x.hashCode() method and x.equals(y) method of Object class?


A: The hashCode() method returns an integer value that represents the object's hash code, while the equals() method checks if two objects are equal.

B: The hashCode() method checks if two objects are equal, while the equals() method returns an integer value that represents the object's hash code.

C: Both the hashCode() method and the equals() method check if two objects are equal.


Correct Response: 1

Explanation: The hashCode method returns an integer value that represents the object's hash code, while the equals method checks if two objects are equal. The hash code of an object is used to efficiently determine if two objects are equal. If two objects are equal, then their hash codes must also be equal.





Q: What is a compile time constant in Java?


A: A value that can be evaluated at compile time and is stored as a constant in the class file.

B: A value that can be changed at runtime.

C: A value that can be evaluated at runtime and is stored as a constant in the class file.


Correct Response: 1

Explanation: A compile time constant in Java is a value that can be evaluated at compile time and is stored as a constant in the class file. Compile time constants are usually defined using the final keyword and are usually assigned a value at the time of declaration.





Q: Explain the difference between fail-fast and fail-safe iterators?


A: Fail-fast iterators throw a ConcurrentModificationException if the underlying collection is modified during iteration, while fail-safe iterators do not throw any exception and continue to work with the modified collection.

B: Fail-fast iterators do not throw any exception and continue to work with the modified collection, while fail-safe iterators throw a ConcurrentModificationException if the underlying collection is modified during iteration.

C: Fail-fast and fail-safe iterators both throw a ConcurrentModificationException if the underlying collection is modified during iteration.


Correct Response: 1

Explanation: Fail-fast iterators throw a ConcurrentModificationException if the underlying collection is modified during iteration, while fail-safe iterators do not throw any exception and continue to work with the modified collection. Fail-safe iterators are usually slower than fail-fast iterators and make a copy of the underlying collection before iterating it.





Q: You have a character array and a String. Which one is more secure to store sensitive data (like password, date of birth, etc.)?


A: A character array is more secure to store sensitive data as it can be cleared after use.

B: A String is more secure to store sensitive data as it is immutable.

C: Both a character array and a String are equally secure to store sensitive data.


Correct Response: 1

Explanation: A character array is more secure to store sensitive data as it can be cleared after use, while a String is immutable and its value cannot be changed after it is created. This means that if a sensitive data is stored in a String, it may remain in the memory even after it is no longer needed, making it more vulnerable to security breaches.





Q: Why do you use volatile keyword in Java?


A: To ensure that the value of a variable is always up-to-date and consistent across all threads.

B: To ensure that the value of a variable is only updated in one thread.

C: To ensure that the value of a variable is never updated.


Correct Response: 1

Explanation: The volatile keyword is used in Java to ensure that the value of a variable is always up-to-date and consistent across all threads. When a variable is declared as volatile, the JVM will ensure that every thread accesses the latest value of the variable, even if the value is updated by another thread. This makes volatile variables useful for synchronization and coordination between threads.





Q: What is the difference between poll() and remove() methods of Queue in Java?


A: The poll() method returns and removes the head of the queue or returns null if the queue is empty, while the remove() method returns and removes the head of the queue and throws NoSuchElementException if the queue is empty.

B: The poll() method returns and removes the head of the queue and throws NoSuchElementException if the queue is empty, while the remove() method returns and removes the head of the queue or returns null if the queue is empty.

C: Both the poll() method and the remove() method return and remove the head of the queue and throw NoSuchElementException if the queue is empty.


Correct Response: 1

Explanation: The poll() method returns and removes the head of the queue or returns null if the queue is empty, while the remove() method returns and removes the head of the queue and throws NoSuchElementException if the queue is empty. The poll() method is a safer alternative to remove() as it returns null instead of throwing an exception if the queue is empty.





Q: Can you catch an exception thrown by another thread in Java?


A: No, you cannot catch an exception thrown by another thread.

B: Yes, you can catch an exception thrown by another thread by using a try-catch block in the main thread.

C: Yes, you can catch an exception thrown by another thread by using a try-catch block in the other thread.


Correct Response: 2

Explanation: Yes, you can catch an exception thrown by another thread by using a try-catch block in the main thread. When an exception is thrown by a different thread, it can be caught and handled by the main thread, just like any other exception.





Q: How do you decide which type of Inner Class – Static or Non-Static to use in Java?


A: You should use a static inner class if you don't need to access the instance variables and methods of the outer class, while you should use a non-static inner class if you need to access the instance variables and methods of the outer class.

B: You should use a non-static inner class if you don't need to access the instance variables and methods of the outer class, while you should use a static inner class if you need to access the instance variables and methods of the outer class.

C: Both static inner class and non-static inner class can access the instance variables and methods of the outer class.


Correct Response: 1

Explanation: You should use a static inner class if you don't need to access the instance variables and methods of the outer class, while you should use a non-static inner class if you need to access the instance variables and methods of the outer class. A static inner class is not associated with an instance of the outer class and does not have access to its instance variables and methods. A non-static inner class, on the other hand, is associated with an instance of the outer class and has access to its instance variables and methods.





Q: What are the different types of Classloaders in Java?


A: Bootstrap, Extension, System, and Application Classloaders.

B: Bootstrap, Extension, System, Application, and Custom Classloaders.

C: Bootstrap, Extension, System, Application, and Dynamic Classloaders.

D: Bootstrap, Extension, System, and Dynamic Classloaders.


Correct Response: 1

Explanation: There are four types of Classloaders in Java: Bootstrap, Extension, System, and Application Classloaders. The Bootstrap Classloader loads the Java Core classes and is the parent of the Extension Classloader. The Extension Classloader loads the extension classes, and the System Classloader is used to load the application classes. The Application Classloader is used to load custom classes that are specific to the application.





Q: What are the situations in which you choose HashSet or TreeSet?


A: You should choose HashSet if you need fast access to the elements and don't care about the order of the elements, while you should choose TreeSet if you need the elements to be in a specific order.

B: You should choose TreeSet if you need fast access to the elements and don't care about the order of the elements, while you should choose HashSet if you need the elements to be in a specific order.

C: Both HashSet and TreeSet provide fast access to the elements.


Correct Response: 1

Explanation: You should choose HashSet if you need fast access to the elements and don't care about the order of the elements, while you should choose TreeSet if you need the elements to be in a specific order. HashSet uses a hash table to store the elements, which provides fast access to the elements but does not maintain the order of the elements. TreeSet uses a tree structure to store the elements and provides fast access to the elements while maintaining the order of the elements.





Q: What is the use of method references in Java?


A: Method references provide a way to refer to methods of objects or classes, making it easier to pass methods as arguments to other methods.

B: Method references provide a way to overload methods.

C: Method references provide a way to create new methods at runtime.


Correct Response: 1

Explanation: Method references provide a way to refer to methods of objects or classes, making it easier to pass methods as arguments to other methods. This can simplify code and make it more readable, as it eliminates the need to create anonymous inner classes to pass methods as arguments. Method references are used in conjunction with functional interfaces, which are interfaces with a single abstract method.





Q: Do you think Java Enums are more powerful than integer constants?


A: Yes, Java Enums are more powerful than integer constants as they provide type safety, additional methods, and the ability to add values at runtime.

B: No, Java Enums are not more powerful than integer constants as they are limited to a fixed set of values and cannot be changed at runtime.

C: Both Java Enums and integer constants are equally powerful.


Correct Response: 1

Explanation: Yes, Java Enums are more powerful than integer constants as they provide type safety, additional methods, and the ability to add values at runtime. Java Enums are a type-safe way to represent a fixed set of values, and they provide additional functionality that is not available with integer constants.





Q: Why do we use static initializers in Java?


A: To initialize static variables with default values.

B: To initialize static variables with non-default values.

C: To initialize instance variables with default values.

D: To initialize instance variables with non-default values.


Correct Response: 2

Explanation: To initialize static variables with non-default values. Static initializers are used to initialize static variables with values other than the default values. This is useful when the value of the static variable depends on some external factors and cannot be determined at compile time.





Q: Your client is complaining that your code is throwing NoClassDefFoundError or NoSuchMethodError, even though you are able to compile your code without error and method exists in your code. What could be the reason behind this?


A: The class or method being referenced is not in the classpath at runtime.

B: The class or method being referenced does not exist in the code.

C: The class or method being referenced is not accessible due to security restrictions.


Correct Response: 1

Explanation: The class or method being referenced is not in the classpath at runtime. The NoClassDefFoundError is thrown when the JVM cannot find a class that was previously available at compile time, while the NoSuchMethodError is thrown when a method that was previously available at compile time cannot be found. Both of these errors indicate that the class or method being referenced is not in the classpath at runtime.





Q: How can you check if a String is a number by using regular expression?


A: By using the pattern ^[0-9]+$.

B: By using the pattern [0-9]+.

C: By using the pattern ^[0-9]*$.

D: By using the pattern [0-9]*.


Correct Response: 1

Explanation: By using the pattern ^[0-9]+$. This regular expression pattern matches strings that consist of one or more digits and nothing else. This can be used to check if a string is a number.





Q: What is the difference between the expressions String s = "Temporary" and String s = new String("Temporary")? Which one is better and more efficient?


A: The first expression creates a new string in the string constant pool, while the second expression creates a new string object on the heap. The first expression is more efficient and is the recommended approach.

B: The first expression creates a new string object on the heap, while the second expression creates a new string in the string constant pool. The second expression is more efficient and is the recommended approach.

C: Both expressions create a new string in the string constant pool.

D: Both expressions create a new string object on the heap.


Correct Response: 1

Explanation: The first expression creates a new string in the string constant pool, while the second expression creates a new string object on the heap. The first expression is more efficient and is the recommended approach as it reuses an existing string if one with the same value already exists in the string constant pool, which saves memory and reduces the risk of memory leaks.





Q: In Java, can two equal objects have the different hash code?


A: No, two equal objects must have the same hash code.

B: Yes, two equal objects can have different hash codes.

C: It depends on the implementation of the hash code method.


Correct Response: 1

Explanation: No, two equal objects must have the same hash code. The hashCode() method is used to generate a unique identifier for an object, and if two objects are equal, they must have the same hash code. This is a requirement of the hashCode() method, which is defined in the Object class and is inherited by all objects in Java.





Q: How can we print an Array in Java?


A: By using the toString() method of the Arrays class.

B: By using a loop to iterate over the elements of the array and printing each element individually.

C: By using the println() method of the System class.

D: By using the print() method of the System class.


Correct Response: 2

Explanation: By using a loop to iterate over the elements of the array and printing each element individually. This can be done using a for loop or a for-each loop, depending on the desired behavior. The toString() method of the Arrays class can also be used to convert the array to a string representation, but it is typically more efficient to iterate over the elements of the array and print each element individually.





Q: Is it ok to use random numbers in the implementation of hashcode() method in Java?


A: No, it is not recommended to use random numbers in the implementation of the hashCode() method, as this can lead to collisions and reduce the effectiveness of hash-based data structures.

B: Yes, it is recommended to use random numbers in the implementation of the hashCode() method, as this helps to ensure that hash codes are unique and distribute well across the range of possible values.

C: It depends on the specific use case and requirements of the application.


Correct Response: 1

Explanation: No, it is not recommended to use random numbers in the implementation of the hashCode() method, as this can lead to collisions and reduce the effectiveness of hash-based data structures. The hashCode() method should generate a unique identifier for an object that is based on the state of the object and is deterministic, meaning that it always returns the same value for a given object.





Q: Between two types of dependency injections, constructor injection and setter dependency injection, which one is better?


A: Constructor injection is considered to be better as it is more secure, provides better encapsulation, and makes it easier to enforce the immutability of objects.

B: Setter dependency injection is considered to be better as it is more flexible, allows for easier testing, and makes it easier to change the dependencies of an object at runtime.

C: Both constructor injection and setter dependency injection have their own advantages and disadvantages, and the choice between them depends on the specific requirements of the application.


Correct Response: 1

Explanation: Constructor injection is considered to be better as it is more secure, provides better encapsulation, and makes it easier to enforce the immutability of objects. With constructor injection, dependencies are passed as parameters to the constructor, and the object is fully initialized when it is created. This makes it easier to ensure that objects are properly initialized and that their dependencies are not modified after they are created.





Q: What is the difference between DOM and SAX parser in Java?


A: DOM (Document Object Model) parser loads the entire XML document into memory and builds a tree-like structure, allowing for random access to elements in the document. SAX (Simple API for XML) parser reads the XML document sequentially and does not store the document in memory, allowing for faster processing of large documents.

B: DOM (Document Object Model) parser reads the XML document sequentially and does not store the document in memory, allowing for faster processing of large documents. SAX (Simple API for XML) parser loads the entire XML document into memory and builds a tree-like structure, allowing for random access to elements in the document.

C: Both DOM and SAX parser load the entire XML document into memory and build a tree-like structure.

D: Both DOM and SAX parser read the XML document sequentially and do not store the document in memory.


Correct Response: 1

Explanation: DOM (Document Object Model) parser loads the entire XML document into memory and builds a tree-like structure, allowing for random access to elements in the document. SAX (Simple API for XML) parser reads the XML document sequentially and does not store the document in memory, allowing for faster processing of large documents. The choice between the two depends on the specific requirements of the application, such as the amount of memory available and the desired level of access to elements in the document.





Q: Between Enumeration and Iterator, which one has better performance in Java?


A: Iterator has better performance as it provides more functionality and is more flexible than Enumeration.

B: Enumeration has better performance as it is a legacy interface and is optimized for use with legacy data structures.

C: Both Enumeration and Iterator have similar performance, and the choice between them depends on the specific requirements of the application.


Correct Response: 2

Explanation: Enumeration has better performance as it is a legacy interface and is optimized for use with legacy data structures. Enumeration is a legacy interface that was introduced in Java 1.0 and is optimized for use with legacy data structures such as Vector and Hashtable. Iterator is a more modern interface that was introduced in Java 1.2 and provides additional functionality, such as the ability to remove elements from a collection.





Q: What are the different ways to sort a collection in Java?


A: Bubble sort

B: Insertion sort

C: Selection sort

D: Collections.sort method


Correct Response: 4

Explanation: In Java, collections can be sorted using the built-in method Collections.sort, as well as various sorting algorithms such as bubble sort, insertion sort, and selection sort.





Q: Why Collection interface doesn’t extend Cloneable and Serializable interfaces?


A: Collection interface doesn't extend Cloneable and Serializable interfaces because they are not relevant to collections.

B: Collection interface doesn't extend Cloneable and Serializable interfaces because it would create an ambiguity.

C: Collection interface doesn't extend Cloneable and Serializable interfaces because it would increase the size of the interface.

D: Collection interface doesn't extend Cloneable and Serializable interfaces because it would reduce the functionality of the interface.


Correct Response: 1

Explanation: Collection interface is designed to provide a common set of methods for working with collections of objects. The Cloneable and Serializable interfaces are not relevant to collections and therefore, the Collection interface does not extend them.





Q: What is the difference between a process and a thread in Java?


A: A process is a single instance of a program, while a thread is a separate flow of execution within a process.

B: A process is a separate flow of execution within a program, while a thread is a single instance of a program.

C: A process and a thread are the same thing.


Correct Response: 1

Explanation: A process is an instance of a program that is executing on a computer. A thread is a separate flow of execution within a process. Multiple threads within a process can run simultaneously, allowing for parallel execution of code.





Q: What are the benefits of using an unordered array over an ordered array?


A: An unordered array is faster than an ordered array.

B: An unordered array is more flexible than an ordered array.

C: An unordered array takes up less memory than an ordered array.


Correct Response: 2

Explanation: An unordered array is more flexible than an ordered array because it does not impose any restrictions on the order of the elements. This allows for faster insertion and deletion of elements, as the elements do not need to be shifted to maintain the order.





Q: Between HashSet and TreeSet collections in Java, which one is better?


A: HashSet is better.

B: TreeSet is better.

C: Both HashSet and TreeSet are the same.


Correct Response: 3

Explanation: The choice between HashSet and TreeSet depends on the specific use case. HashSet provides faster access and insertion times, while TreeSet provides sorted elements and faster search times.





Q: When does JVM call the finalize() method?


A: When an object is about to be garbage collected.

B: When an object is first created.

C: When an object is referenced by another object.


Correct Response: 1

Explanation: JVM calls the finalize() method when an object is about to be garbage collected. This method can be overridden by subclasses to perform cleanup actions before the object is collected.





Q: When would you use Serial Garbage collector or Throughput Garbage collector in Java?


A: Use Serial Garbage collector when you have a single processor.

B: Use Throughput Garbage collector when you have multiple processors.

C: Use Serial Garbage collector when you have limited memory.


Correct Response: 2

Explanation: Use the Serial Garbage collector when you have a single processor and limited memory, and use the Throughput Garbage collector when you have multiple processors and a large amount of memory. The Throughput Garbage collector is designed to run in parallel with application threads, allowing for increased collection performance on multi-processor systems.





Q: In Java, if you set an object reference to null, will the Garbage Collector immediately free the memory held by that object?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: Setting an object reference to null does not immediately free the memory held by that object. The Garbage Collector runs periodically and frees memory when it determines that an object is no longer needed.





Q: How can you make an Object eligible for Garbage collection in Java?


A: By setting the object reference to null.

B: By invoking the System.gc() method.

C: By calling the object's finalize() method.

D: All of the above.


Correct Response: 1

Explanation: To make an object eligible for garbage collection in Java, you need to set all references to the object to null. Once there are no references to the object, it becomes eligible for garbage collection.





Q: When do you use Exception or Error in Java? What is the difference between these two?


A: Use Exceptions for expected error conditions and Errors for unexpected conditions.

B: Use Exceptions for unexpected error conditions and Errors for expected conditions.

C: Both Exceptions and Errors are used for expected conditions.

D: Both Exceptions and Errors are used for unexpected conditions.


Correct Response: 1

Explanation: Exceptions are used for expected error conditions, such as invalid user input or a missing file, while Errors are used for unexpected conditions, such as a stack overflow or an out-of-memory error.





Q: What is the advantage of PreparedStatement over Statement class in Java?


A: PreparedStatement is faster than Statement.

B: PreparedStatement is more flexible than Statement.

C: PreparedStatement provides better security than Statement.

D: All of the above.


Correct Response: 4

Explanation: PreparedStatement provides several advantages over the Statement class, including better performance, greater flexibility, and improved security. PreparedStatements are precompiled, allowing for faster execution, and they also support parameterized queries, which can help prevent SQL injection attacks.





Q: In Java, what is the difference between throw and throws keywords?


A: The throw keyword is used to throw an exception, while the throws keyword is used to declare that a method may throw an exception.

B: The throws keyword is used to throw an exception, while the throw keyword is used to declare that a method may throw an exception.

C: Both throw and throws are used to throw an exception.


Correct Response: 1

Explanation: The throw keyword is used to throw an exception, while the throws keyword is used to declare that a method may throw an exception. The throws keyword is used in the method signature to indicate that the method may throw a specific type of exception.





Q: What happens to the Exception object after the exception handling is done?


A: The Exception object is destroyed.

B: The Exception object is stored in memory for future reference.

C: The Exception object is passed to the calling method.


Correct Response: 1

Explanation: Once the exception handling is done, the Exception object is destroyed and the memory it occupied is made available for garbage collection.





Q: How do you find which client machine is sending request to your servlet in Java?


A: By using the getRemoteAddr() method of the HttpServletRequest object.

B: By using the getLocalAddr() method of the HttpServletRequest object.

C: By using the getInetAddress() method of the HttpServletRequest object.


Correct Response: 1

Explanation: To find the client machine that is sending a request to your servlet, you can use the getRemoteAddr() method of the HttpServletRequest object. This method returns the IP address of the client machine that is sending the request.





Q: What is the difference between a Cookie and a Session object in Java?


A: A Cookie is stored on the client machine, while a Session object is stored on the server.

B: A Session object is stored on the client machine, while a Cookie is stored on the server.

C: Both Cookies and Session objects are stored on the client machine.

D: Both Cookies and Session objects are stored on the server.


Correct Response: 1

Explanation: Cookies are small text files that are stored on the client machine, while Session objects are stored on the server and are used to maintain state across multiple requests from the same client. Cookies have a limited size and can be easily deleted by the user, while Session objects are more secure and persist until the user's session ends.





Q: Which protocol does Browser and Servlet use to communicate with each other?


A: HTTP

B: FTP

C: SMTP


Correct Response: 1

Explanation: Browsers and Servlets communicate with each other using the HTTP (HyperText Transfer Protocol) protocol. HTTP is a request-response based protocol that is used to transfer data over the internet.





Q: What is HTTP Tunneling?


A: HTTP Tunneling is a technique used to securely transfer data over an HTTP connection.

B: HTTP Tunneling is a technique used to transfer data over an insecure HTTP connection.

C: HTTP Tunneling is a technique used to transfer data over an FTP connection.


Correct Response: 1

Explanation: HTTP Tunneling is a technique used to securely transfer data over an HTTP connection by encapsulating the data within HTTP requests and responses. This allows for data to be transferred over an otherwise unsecured connection, providing an additional layer of security.





Q: Why do we use JSP instead of Servlet in Java?


A: JSP provides a simpler and more convenient way to generate dynamic content than Servlets.

B: JSP provides better performance than Servlets.

C: JSP provides better security than Servlets.


Correct Response: 1

Explanation: JSP (JavaServer Pages) provides a simpler and more convenient way to generate dynamic content than Servlets. JSP pages are easier to write and maintain than Servlets, as they allow for the separation of presentation and logic. JSP also provides better performance than Servlets, as JSP pages are compiled into Servlets at runtime and can be cached for faster execution.





Q: Is empty ‘.java’ file name a valid source file name in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, an empty file name is not a valid source file name in Java. Java requires that all source files have a unique and non-empty name.





Q: How do you implement Servlet Chaining in Java?


A: By forwarding the request from one Servlet to another Servlet.

B: By including the output of one Servlet in the response of another Servlet.

C: By calling the service() method of one Servlet from another Servlet.


Correct Response: 1

Explanation: Servlet chaining can be implemented in Java by forwarding the request from one Servlet to another Servlet. This allows for multiple Servlets to be combined to perform complex processing tasks.





Q: Can you instantiate this class?


A: Yes

B: No

C: It depends


Correct Response: 3

Explanation: The answer to this question depends on the specific class in question. Some classes in Java cannot be instantiated, such as abstract classes or classes with private constructors, while others can be instantiated.





Q: Why Java does not support operator overloading?


A: To maintain consistency and simplicity in the language.

B: To prevent code confusion and errors.

C: To reduce the complexity of the language.

D: All of the above.


Correct Response: 1

Explanation: Java does not support operator overloading to maintain consistency and simplicity in the language. Operator overloading can lead to code confusion and errors, and can make the language more complex to learn and use.





Q: Why String class is Immutable or Final in Java?


A: To ensure thread safety and security.

B: To improve performance and memory efficiency.

C: To prevent accidental modification of string objects.

D: All of the above.


Correct Response: 4

Explanation: The String class is immutable and final in Java to ensure thread safety and security, improve performance and memory efficiency, and prevent accidental modification of string objects. Once a String object is created, its value cannot be changed, which helps to prevent unintended consequences in a multithreaded environment.





Q: What is the difference between sendRedirect and forward methods?


A: sendRedirect sends the request to a new URL, while forward forwards the request to another resource within the same server.

B: sendRedirect forwards the request to another resource within the same server, while sendRedirect sends the request to a new URL.

C: Both sendRedirect and forward send the request to a new URL.


Correct Response: 1

Explanation: The sendRedirect method sends the request to a new URL, while the forward method forwards the request to another resource within the same server. The sendRedirect method generates a new HTTP request, while the forward method forwards the existing request to another resource.





Q: How do you fix your Serializable class, if it contains a member that is not serializable?


A: By marking the member as transient.

B: By marking the member as static.

C: By marking the member as final.


Correct Response: 1

Explanation: If a class contains a member that is not serializable, you can fix the class by marking the member as transient. This tells the serialization process to skip the member when serializing the object, and to leave it out of the resulting serialized data.





Q: What is the use of run time polymorphism in Java?


A: To allow objects of different classes to be treated as objects of a common class.

B: To allow objects of the same class to be treated as objects of different classes.

C: To allow objects of different classes to be treated as objects of a common interface.


Correct Response: 1

Explanation: The purpose of runtime polymorphism in Java is to allow objects of different classes to be treated as objects of a common class. This allows for dynamic method dispatch, where the method to be called is determined at runtime based on the actual type of the object.





Q: What are the rules of method overloading and method overriding in Java?


A: Overloaded methods must have the same name, while overridden methods must have different names.

B: Overloaded methods must have different names, while overridden methods must have the same name.

C: Overloaded methods must have the same name, return type, and number of arguments.

D: Overridden methods must have the same name, return type, and number of arguments.


Correct Response: 4

Explanation: In Java, overloaded methods must have the same name, but different argument lists, while overridden methods must have the same name, return type, and argument list as the method in the parent class. Overloading allows for multiple methods with the same name, but different signatures, to be defined in the same class, while overriding allows for a subclass to provide a new implementation for a method defined in its parent class.





Q: What is the difference between a class and an object in Java?


A: A class is a blueprint or template for creating objects, while an object is a instance of a class.

B: A class is a instance of an object, while an object is a blueprint or template for creating classes.

C: A class is a blueprint or template for creating methods, while an object is a instance of a method.


Correct Response: 1

Explanation: In Java, a class is a blueprint or template for creating objects, while an object is an instance of a class. A class defines the properties and behaviors of the objects that are created from it, while an object represents a specific instance of the class, with its own unique set of properties and behaviors.





Q: Can we create an abstract class that extends another abstract class?


A: Yes

B: No

C: It depends


Correct Response: 1

Explanation: Yes, in Java, an abstract class can extend another abstract class. This allows for the creation of a hierarchy of abstract classes, where each subclass adds additional behavior and functionality to the parent class.





Q: Why do you use Upcasting or Downcasting in Java ?


A: To allow objects of different classes to be treated as objects of a common class.

B: To allow objects of the same class to be treated as objects of different classes.

C: To change the type of an object at runtime.


Correct Response: 3

Explanation: Upcasting and downcasting in Java are used to change the type of an object at runtime. Upcasting refers to casting an object to a higher type in the class hierarchy, while downcasting refers to casting an object to a lower type in the class hierarchy. These casting operations allow for the creation of more flexible and dynamic object-oriented programs.





Q: What is the reason to organize classes and interfaces in a package in Java?


A: To avoid naming collisions with classes and interfaces from other sources.

B: To improve performance and memory efficiency.

C: To allow for better code organization and maintenance.

D: All of the above.


Correct Response: 1

Explanation: The reason to organize classes and interfaces in a package in Java is to avoid naming collisions with classes and interfaces from other sources. Packages provide a way to group related classes and interfaces into a single unit, making it easier to manage and organize code, and to prevent naming conflicts with other code libraries and packages.





Q: What is information hiding in Java?


A: Information hiding is the process of hiding the implementation details of a class or method, and exposing only the necessary information to the outside world.

B: Information hiding is the process of exposing the implementation details of a class or method to the outside world.

C: Information hiding is the process of hiding the necessary information of a class or method, and exposing only the implementation details to the outside world.


Correct Response: 1

Explanation: Information hiding is a fundamental principle of object-oriented programming that involves hiding the implementation details of a class or method, and exposing only the necessary information to the outside world. This helps to reduce the coupling between different parts of a program, making it easier to maintain and modify the code.





Q: Why does Java provide default constructor?


A: To allow objects to be created without explicitly calling a constructor.

B: To allow objects to be created by calling a constructor with no arguments.

C: To allow objects to be created by calling a constructor with arguments.


Correct Response: 1

Explanation: Java provides a default constructor to allow objects to be created without explicitly calling a constructor. The default constructor is automatically generated by the compiler if no other constructors are defined in the class. The default constructor provides a basic initialization for the object, and can be overridden by the programmer to provide custom initialization behavior.





Q: What is the difference between super and this keywords in Java?


A: The super keyword refers to the parent class, while the this keyword refers to the current object.

B: The super keyword refers to the current object, while the this keyword refers to the parent class.

C: The super keyword refers to the parent object, while the this keyword refers to the current object.


Correct Response: 1

Explanation: In Java, the super keyword refers to the parent class, while the this keyword refers to the current object. The super keyword is used to access methods and variables of the parent class, while the this keyword is used to refer to the current object, or to call another constructor within the same class.





Q: What is the reason to organize classes and interfaces in a package in Java?


A: To avoid naming collisions with classes and interfaces from other sources.

B: To improve performance and memory efficiency.

C: To allow for better code organization and maintenance.

D: All of the above.


Correct Response: 1

Explanation: The reason to organize classes and interfaces in a package in Java is to avoid naming collisions with classes and interfaces from other sources. Packages provide a way to group related classes and interfaces into a single unit, making it easier to manage and organize code, and to prevent naming conflicts with other code libraries and packages.





Q: What is information hiding in Java?


A: Information hiding is the process of hiding the implementation details of a class or method, and exposing only the necessary information to the outside world.

B: Information hiding is the process of exposing the implementation details of a class or method to the outside world.

C: Information hiding is the process of hiding the necessary information of a class or method, and exposing only the implementation details to the outside world.


Correct Response: 1

Explanation: Information hiding is a fundamental principle of object-oriented programming that involves hiding the implementation details of a class or method, and exposing only the necessary information to the outside world. This helps to reduce the coupling between different parts of a program, making it easier to maintain and modify the code.





Q: Why does Java provide default constructor?


A: To allow objects to be created without explicitly calling a constructor.

B: To allow objects to be created by calling a constructor with no arguments.

C: To allow objects to be created by calling a constructor with arguments.


Correct Response: 1

Explanation: Java provides a default constructor to allow objects to be created without explicitly calling a constructor. The default constructor is automatically generated by the compiler if no other constructors are defined in the class. The default constructor provides a basic initialization for the object, and can be overridden by the programmer to provide custom initialization behavior.





Q: What is the difference between super and this keywords in Java?


A: The super keyword refers to the parent class, while the this keyword refers to the current object.

B: The super keyword refers to the current object, while the this keyword refers to the parent class.

C: The super keyword refers to the parent object, while the this keyword refers to the current object.


Correct Response: 1

Explanation: In Java, the super keyword refers to the parent class, while the this keyword refers to the current object. The super keyword is used to access methods and variables of the parent class, while the this keyword is used to refer to the current object, or to call another constructor within the same class.





Q: What is the advantage of using Unicode characters in Java?


A: Unicode provides a standardized character set that supports multiple languages, making it easier to write internationalized code.

B: Unicode provides a larger character set than ASCII, allowing for more symbols and special characters.

C: Unicode provides faster character processing than ASCII.

D: All of the above.


Correct Response: 1

Explanation: The advantage of using Unicode characters in Java is that Unicode provides a standardized character set that supports multiple languages, making it easier to write internationalized code. This allows for programs to be written in a way that can be easily adapted for different language environments, without having to worry about the underlying character encoding.





Q: Can you override an overloaded method in Java?


A: Yes

B: No

C: It depends


Correct Response: 2

Explanation: No, you cannot override an overloaded method in Java. Overloading and overriding are two different concepts in Java, and an overloaded method is not considered to be the same as an overridden method. An overloaded method is a method with the same name as another method, but with a different signature, while an overridden method is a method that provides a new implementation for a method defined in a parent class.





Q: How can we change the heap size of a JVM?


A: By setting the -Xms and -Xmx parameters on the command line when starting the JVM.

B: By modifying the heap size property in the JVM configuration file.

C: By calling the setHeapSize() method on the JVM object.


Correct Response: 1

Explanation: The heap size of a JVM can be changed by setting the -Xms and -Xmx parameters on the command line when starting the JVM. These parameters specify the minimum and maximum heap size, respectively, and can be used to tune the memory usage of the JVM.





Q: Why should you define a default constructor in Java?


A: To initialize the object with default values.

B: To allow objects to be created without explicitly calling a constructor.

C: To provide a basic initialization for the object.

D: All of the above.


Correct Response: 4

Explanation: It is a good practice to define a default constructor in Java, as it allows objects to be created without explicitly calling a constructor. The default constructor provides a basic initialization for the object, and can be used to set default values for object properties. If no other constructors are defined in the class, the compiler will automatically generate a default constructor for the class.





Q: How will you make an Object Immutable in Java?


A: By making all fields of the object final and private.

B: By making all fields of the object public and mutable.

C: By making all fields of the object protected and mutable.


Correct Response: 1

Explanation: To make an object immutable in Java, you should make all fields of the object final and private. This ensures that the object cannot be modified once it has been created, and that its state cannot be changed by other parts of the program. In addition, it is a good practice to provide only getter methods for the object's fields, to prevent any unauthorized modification of the object's state.





Q: How can you prevent SQL Injection in Java Code?


A: By using parameterized queries instead of concatenating dynamic values into the SQL statement.

B: By using a stored procedure instead of direct SQL statements.

C: By using the escape() method to escape any special characters in the dynamic values.

D: All of the above.


Correct Response: 1

Explanation: One way to prevent SQL injection in Java code is by using parameterized queries instead of concatenating dynamic values into the SQL statement. Parameterized queries allow you to specify placeholders for dynamic values, which are then passed as separate parameters to the query. This helps to prevent SQL injection attacks by ensuring that the dynamic values are properly escaped and protected from malicious input.





Q: Which two methods should be always implemented by HashMap key Object?


A: equals()

B: hashCode()

C: toString()

D: compareTo()


Correct Response: 1, 2

Explanation: In Java, it is important to implement both the equals() and hashCode() methods in the key object used by a HashMap, as these methods are used to compare and hash the objects stored in the map. The equals() method should be implemented to provide a logical equality comparison between objects, while the hashCode() method should be implemented to provide a unique integer representation of the object's state. These methods are used by the HashMap to determine the correct position of an object in the map, and to perform efficient lookups and retrievals.





Q: Why an Object used as Key in HashMap should be Immutable?


A: Because an immutable object's hashcode does not change, which helps to maintain the consistency and stability of the map.

B: Because an immutable object's hashcode can change, which can lead to data loss or corruption in the map.

C: Because an immutable object can be easily shared between multiple threads, which helps to improve performance and concurrency.


Correct Response: 1

Explanation: An object used as a key in a HashMap should be immutable because an immutable object's hashcode does not change, which helps to maintain the consistency and stability of the map. If the hashcode of a key object changes while it is stored in the map, the map may not be able to correctly locate the object, which could result in data loss or corruption. Immutable objects also provide a predictable and stable hashcode, making it easier to implement efficient hash-based data structures such as HashMap.





Q: How can we share an object between multiple threads?


A: By using synchronized methods or blocks to control access to the shared object.

B: By using volatile variables to ensure that changes to the shared object are visible to all threads.

C: By using atomic variables to ensure that updates to the shared object are performed in a thread-safe manner.

D: All of the above.


Correct Response: 1

Explanation: One way to share an object between multiple threads is by using synchronized methods or blocks to control access to the shared object. Synchronized methods or blocks allow you to specify a critical section of code that can only be executed by one thread at a time, ensuring that the shared object is accessed in a thread-safe manner. Other techniques such as volatile variables and atomic variables can also be used to ensure that changes to the shared object are visible to all threads, and that updates to the shared object are performed in a thread-safe manner.





Q: How can you determine if your program has a deadlock?


A: By using a thread dump tool to inspect the state of the threads in your program.

B: By using a performance profiler to identify areas of contention in your program.

C: By setting breakpoints in your code and manually inspecting the state of the threads.

D: All of the above.


Correct Response: 1

Explanation: One way to determine if your program has a deadlock is by using a thread dump tool to inspect the state of the threads in your program. A thread dump is a snapshot of the current state of the threads in a program, and can be used to identify deadlocks, as well as other performance issues such as blocked threads and resource contention. Other techniques such as performance profiling and manual inspection of the code can also be used to identify deadlocks, but a thread dump is often the most effective way to quickly and accurately diagnose deadlock issues in a program.





Q: What are the implicit objects in JSP?


A: request, response, session, application, out, config, pageContext, page

B: request, response, session, out, pageContext, page

C: request, response, out, page

D: request, response, session, out


Correct Response: 1

Explanation: The implicit objects in JSP are request, response, session, application, out, config, pageContext, and page. These objects are automatically available in every JSP page, and provide access to various resources and services in the web application. For example, the request object provides access to incoming request data, such as form data and headers, while the response object provides access to the response that will be sent back to the client.





Q: How will you extend JSP code?


A: By using the extends directive in the JSP page.

B: By using inheritance in the underlying Java code.

C: By using the include directive in the JSP page.


Correct Response: 1

Explanation: To extend JSP code, you can use the extends directive in the JSP page. The extends directive allows you to define a common base JSP page, which can be extended by other JSP pages. The extending JSP pages can inherit the content of the base JSP page, and can add or override content as needed. This allows you to reuse common layout and functionality across multiple JSP pages, and to keep your code organized and maintainable.





Q: How will you handle runtime exceptions in JSP?


A: By using a try-catch block in the JSP code.

B: By using the errorPage attribute of the page directive.

C: By using the error-page element in the deployment descriptor.

D: All of the above.


Correct Response: 3

Explanation: One way to handle runtime exceptions in JSP is by using the error-page element in the deployment descriptor. The error-page element allows you to specify a JSP page or Servlet that should be used to handle errors that occur during the processing of a JSP page. This allows you to centralize error handling in your application, and to provide a consistent and user-friendly experience for your users. Other techniques such as using a try-catch block in the JSP code, or using the errorPage attribute of the page directive can also be used, but using the error-page element in the deployment descriptor is often the most flexible and effective approach.





Q: How will you prevent multiple submits of a page that come by clicking refresh button multiple times?


A: By using the POST-REDIRECT-GET pattern.

B: By using the double submit cookie pattern.

C: By using the synchronization token pattern.

D: All of the above.


Correct Response: 1

Explanation: One way to prevent multiple submits of a page that come from clicking the refresh button multiple times is by using the POST-REDIRECT-GET (PRG) pattern. The PRG pattern involves redirecting the user to a different page after a form submit, which allows the user to safely refresh the page without resubmitting the form. This pattern helps to ensure that form submissions are idempotent, meaning that they have the same effect whether they are performed once or multiple times, and helps to prevent data duplication or corruption caused by multiple form submissions.





Q: How will you implement a thread safe JSP page?


A: By using synchronized methods or blocks to control access to shared data.

B: By using the singleThreadModel interface to ensure that only one thread at a time can access the JSP page.

C: By using the isThreadSafe attribute of the page directive to specify whether the JSP page is thread-safe.


Correct Response: 1

Explanation: To implement a thread safe JSP page, you can use synchronized methods or blocks to control access to shared data. This allows you to ensure that only one thread at a time can access the shared data, which helps to prevent race conditions and data corruption. In addition, you can use the isThreadSafe attribute of the page directive to specify whether the JSP page is thread-safe, and to control how the JSP page is executed by the JSP container. Other techniques such as using the singleThreadModel interface can also be used, but they are not recommended, as they can lead to performance issues and scalability problems.





Q: How will you include a static file in a JSP page?


A: By using the include directive in the JSP page.

B: By using the jsp:include action in the JSP page.

C: By using the c:import tag in the JSP page.

D: All of the above.


Correct Response: 1

Explanation: To include a static file in a JSP page, you can use the include directive in the JSP page. The include directive allows you to include the contents of another file in the JSP page, which can be used to include common header and footer information, or to reuse content across multiple JSP pages. The jsp:include action and the c:import tag can also be used to include content in a JSP page, but the include directive is the most commonly used and straightforward way to include static files in a JSP page.





Q: What are the lifecycle methods of a JSP?


A: jspInit(), jspDestroy(), _jspService()

B: jspInit(), jspDestroy(), _jspService(), jspPageBegin(), jspPageEnd()

C: jspService(), jspDestroy(), _jspInit()

D: jspService(), jspInit(), jspDestroy()


Correct Response: 1

Explanation: The lifecycle methods of a JSP are jspInit(), jspDestroy(), and _jspService(). The jspInit() method is called when the JSP page is first initialized, and is used to perform any one-time setup that is required. The jspDestroy() method is called when the JSP page is about to be destroyed, and is used to perform any cleanup that is required. The _jspService() method is called for each request to the JSP page, and is used to generate the dynamic content that is sent back to the client.





Q: What are the advantages of using JSP in web architecture?


A: Easy to maintain, easy to debug, reusable code, platform independent

B: Reusable code, platform independent, easy to maintain, easy to debug

C: Reusable code, easy to maintain, easy to debug, platform independent

D: Platform independent, reusable code, easy to maintain, easy to debug


Correct Response: 3

Explanation: Some of the advantages of using JSP in web architecture are that it provides reusable code, easy to maintain, and easy to debug. JSP allows you to write dynamic content in a Java-like syntax, which makes it easier for Java developers to write web pages. Additionally, JSP is platform independent, which means that JSP pages can be deployed on any platform that supports a JSP container, such as Tomcat or Jetty. This makes JSP a flexible and scalable solution for building dynamic web applications.





Q: What is the advantage of JSP over Javascript?


A: JSP is easier to maintain and debug compared to Javascript.

B: JSP is faster and more efficient compared to Javascript.

C: JSP is more secure compared to Javascript.

D: JSP is easier to write compared to Javascript.


Correct Response: 1

Explanation: One advantage of JSP over Javascript is that JSP is easier to maintain and debug compared to Javascript. JSP provides a Java-like syntax for writing dynamic content, which is more familiar to Java developers and easier to understand than the syntax used by Javascript. Additionally, JSP provides a number of tools and technologies for debugging and testing JSP pages, which makes it easier to identify and fix problems with JSP pages.





Q: What is the Lifecycle of JSP?


A: Translation, Initialization, Request Processing, Destruction

B: Translation, Initialization, Execution, Destruction

C: Translation, Execution, Destruction, Request Processing

D: Translation, Initialization, Request Processing, Execution, Destruction


Correct Response: 4

Explanation: The lifecycle of a JSP is as follows: Translation, Initialization, Request Processing, and Destruction. During the Translation phase, the JSP container compiles the JSP page into a servlet class. During the Initialization phase, the JSP container creates an instance of the servlet class and calls the jspInit() method to perform any required setup. During the Request Processing phase, the JSP container handles incoming requests to the JSP page and calls the _jspService() method to generate the dynamic content that is sent back to the client. During the Destruction phase, the JSP container calls the jspDestroy() method to perform any required cleanup, and then destroys the servlet instance.





Q: What is a JSP expression?


A: A JSP expression is a piece of Java code that is evaluated and included in the output of the JSP page.

B: A JSP expression is a special tag that is used to include dynamic content in the JSP page.

C: A JSP expression is a JavaBean component that is used to store data in a JSP page.

D: A JSP expression is a piece of HTML code that is evaluated and included in the output of the JSP page.


Correct Response: 1

Explanation: A JSP expression is a piece of Java code that is evaluated and included in the output of the JSP page. JSP expressions are written within <%= and %> tags, and they can be used to include dynamic content in the JSP page. For example, you can use a JSP expression to include the value of a Java variable in the output of the JSP page. JSP expressions are a convenient and powerful way to include dynamic content in JSP pages, and they are a key feature of the JSP technology.





Q: What are the different types of directive tags in JSP?


A: page, include, taglib

B: page, taglib, jsp:include

C: page, jsp:include, jsp:taglib

D: page, include, jsp:taglib


Correct Response: 1

Explanation: The different types of directive tags in JSP are page, include, and taglib. The page directive is used to provide information about the JSP page, such as the content type, encoding, and error page. The include directive is used to include the contents of another file in the JSP page. The taglib directive is used to include a tag library in the JSP page, which provides a set of custom tags that can be used to generate dynamic content. These directive tags are an important part of the JSP technology, and they provide a way to control the behavior and structure of JSP pages.





Q: What is session attribute in JSP?


A: An object stored in the user's session.

B: An object stored in the JSP context.

C: An object stored in the servlet context.


Correct Response: 1

Explanation: A session attribute is an object stored in the user's session and can be accessed by multiple JSP pages during the life of a user's session. This allows data to be shared between multiple pages, making it easier to maintain state information.





Q: What are the different scopes of a JSP object?


A: Page

B: Request

C: Session

D: Application


Correct Response: 1, 2, 3

Explanation: JSP objects can have different scopes such as Page, Request, Session, and Application. Page scope means that the object is only available to the current JSP page, Request scope means that the object is available to all pages processing the current request, Session scope means that the object is available to all pages in the current user session, and Application scope means that the object is available to all pages in the current web application.





Q: What is pageContext in JSP?


A: An implicit object that provides access to various objects in the JSP context.

B: A JSP directive that sets the context for the current page.

C: A JSP action that sets the context for the current page.


Correct Response: 1

Explanation: The pageContext is an implicit object in JSP that provides access to various objects in the JSP context, such as request, response, session, application, and more. It is used to access these objects and their properties within the JSP page.





Q: What is the use of jsp:useBean in JSP?


A: To create and access JavaBeans components in a JSP page.

B: To access JavaScript components in a JSP page.

C: To create and access HTML components in a JSP page.


Correct Response: 1

Explanation: The jsp:useBean action is used to create and access JavaBeans components in a JSP page. JavaBeans are reusable components that can be used to store data and encapsulate business logic. By using jsp:useBean, you can access a JavaBean within a JSP page, set its properties, and call its methods.





Q: What is the difference between include Directive and include Action of JSP?


A: The include Directive is used to include static content, while the include Action is used to include dynamic content.

B: The include Directive is used to include dynamic content, while the include Action is used to include static content.

C: Both the include Directive and include Action are used to include static content.

D: Both the include Directive and include Action are used to include dynamic content.


Correct Response: 1

Explanation: The include Directive is used to include static content, such as HTML or JSP pages, in a JSP page. The included content is merged with the current page and is treated as part of the page. The include Action, on the other hand, is used to include dynamic content, such as the result of a servlet or JSP page, in a JSP page. The included content is executed and the result is inserted into the current page.





Q: How will you use other Java files of your application in JSP code?


A: By importing the Java files in the JSP code.

B: By including the Java files in the JSP code.

C: By executing the Java files in the JSP code.


Correct Response: 1

Explanation: You can use other Java files of your application in JSP code by importing them into the JSP page using the import statement. This allows you to use the classes and methods defined in the Java files in your JSP code.





Q: How will you use an existing class and extend it to use in the JSP?


A: By extending the class and creating a custom tag.

B: By importing the class and using its methods in the JSP code.

C: By executing the class and using its methods in the JSP code.


Correct Response: 1

Explanation: You can use an existing class in JSP by importing it into the JSP page using the import statement. If you want to extend the class and use it in the JSP, you can create a custom tag by extending the class and using the custom tag in the JSP code.





Q: Why _jspService method starts with _ symbol in JSP?


A: To indicate that it is a private method.

B: To indicate that it is a protected method.

C: To indicate that it is a public method.


Correct Response: 1

Explanation: The _jspService method starts with an underscore to indicate that it is a private method. This method is automatically generated by the JSP container and is used to handle HTTP requests for the JSP page.





Q: Why do we use tag library in JSP?


A: To encapsulate complex logic and reduce the amount of Java code in JSP pages.

B: To encapsulate simple logic and increase the amount of Java code in JSP pages.

C: To increase the amount of HTML code in JSP pages.


Correct Response: 1

Explanation: Tag libraries are used in JSP to encapsulate complex logic and reduce the amount of Java code in JSP pages. Tag libraries provide a way to define custom tags that can be used in JSP pages to perform specific actions. This makes it easier to write and maintain JSP pages, as well as improves the readability and maintainability of the code.





Q: What are the different types of tag library groups in JSTL?


A: Core

B: Formatting

C: XML

D: SQL


Correct Response: 1, 2, 3

Explanation: JSTL (JavaServer Pages Standard Tag Library) is divided into four tag library groups: Core, Formatting, XML, and SQL. The Core tag library provides basic functionality such as conditionals, iteration, and URL management, the Formatting tag library provides support for formatting and localization, the XML tag library provides support for processing XML data, and the SQL tag library provides support for interacting with databases.





Q: How will you pass information from one JSP to another JSP?


A: By using request attributes.

B: By using response attributes.

C: By using session attributes.


Correct Response: 1, 3

Explanation: Information can be passed from one JSP to another JSP using request or session attributes. Request attributes are stored in the request object and can be accessed by any JSP page processing the current request. Session attributes are stored in the user's session and can be accessed by any JSP page during the life of the user's session.





Q: How will you call a stored procedure from JSP?


A: By using a JDBC connection and calling the stored procedure from Java code.

B: By using a JPA connection and calling the stored procedure from Java code.

C: By using a JNDI connection and calling the stored procedure from Java code.


Correct Response: 1

Explanation: You can call a stored procedure from JSP by using a JDBC connection and calling the stored procedure from Java code. This involves creating a JDBC connection, preparing a call to the stored procedure, and executing the call. The result of the stored procedure can then be used in the JSP page.





Q: Can we override _jspService() method in JSP?


A: Yes

B: No

C: It depends on the JSP container.


Correct Response: 2

Explanation: No, you cannot override the _jspService method in JSP. This method is automatically generated by the JSP container and is used to handle HTTP requests for the JSP page. Attempting to override this method can result in unexpected behavior and is not recommended.





Q: What is a directive in JSP?


A: A JSP element that provides information to the JSP container.

B: A JSP element that provides information to the client.

C: A JSP element that provides information to the servlet container.


Correct Response: 1

Explanation: A directive in JSP is a JSP element that provides information to the JSP container. Directives are used to provide information about the JSP page, such as setting page-level attributes, importing classes, and including other resources.





Q: How will you implement Session tracking in JSP?


A: By using cookies.

B: By using the session object.

C: By using the request object.


Correct Response: 2

Explanation: You can implement session tracking in JSP by using the session object. The session object is associated with a user's session and is created the first time the user accesses a JSP page in a web application. Information can be stored in the session object and accessed by any JSP page during the life of the user's session.





Q: How do you debug code in JSP?


A: By using the print statement.

B: By using a debugger.

C: By using system out statements.


Correct Response: 2

Explanation: Debugging code in JSP can be done by using a debugger, such as the debugger in your development environment. A debugger allows you to step through your code line by line, inspect variables and objects, and set breakpoints to pause execution at specific points in your code. This makes it easier to identify and fix errors in your code.





Q: How will you implement error page in JSP?


A: By using the errorPage attribute in the page directive.

B: By using the errorPage attribute in the jsp directive.

C: By using the errorPage attribute in the servlet directive.


Correct Response: 1

Explanation: You can implement an error page in JSP by using the errorPage attribute in the page directive. The errorPage attribute specifies the URL of a JSP page that will be used to handle errors that occur in the current JSP page. If an error occurs, the user will be redirected to the specified error page, allowing you to provide a custom error message or take other appropriate action.





Q: How will you send XML data from a JSP?


A: By using the response object to set the content type and write the XML data to the response.

B: By using the request object to set the content type and write the XML data to the request.

C: By using the session object to set the content type and write the XML data to the session.


Correct Response: 1

Explanation: You can send XML data from a JSP by using the response object to set the content type to "text/xml" and write the XML data to the response. This allows you to send XML data from the server to the client, where it can be processed or displayed as needed.





Q: What happens when we request for a JSP page from web browser?


A: The JSP container compiles the JSP page into a servlet and executes the servlet.

B: The JSP page is executed directly by the web browser.

C: The JSP page is executed by the web server.


Correct Response: 1

Explanation: When a request for a JSP page is made from a web browser, the JSP container compiles the JSP page into a servlet and executes the servlet. The servlet generates the dynamic content for the JSP page, which is then sent back to the browser as a response. This allows the JSP page to provide dynamic content to the user.





Q: How will you implement Auto Refresh of page in JSP?


A: By using the meta refresh tag in the HTML header.

B: By using JavaScript to refresh the page.

C: By using the refresh attribute in the page directive.


Correct Response: 1

Explanation: You can implement auto refresh of a page in JSP by using the meta refresh tag in the HTML header. The meta refresh tag specifies the number of seconds to wait before refreshing the page, allowing you to create a page that automatically refreshes after a certain amount of time.





Q: What are the important status codes in HTTP?


A: 200 OK

B: 201 Created

C: 204 No Content

D: 400 Bad Request


Correct Response: 1, 2, 3, 4

Explanation: There are many status codes in HTTP, but some of the most important ones include 200 OK, which indicates that the request was successful, 201 Created, which indicates that a new resource was successfully created, 204 No Content, which indicates that the request was successful but there is no representation to return, and 400 Bad Request, which indicates that the request was malformed or invalid.





Q: What is the meaning of Accept attribute in HTTP header?


A: It specifies the content types that are acceptable for the response.

B: It specifies the content types that are required for the request.

C: It specifies the content types that are supported by the server.


Correct Response: 1

Explanation: The Accept attribute in the HTTP header specifies the content types that are acceptable for the response. This allows the client to indicate to the server which content types it is able to handle, and the server can use this information to return a response in an appropriate format.





Q: What is the difference between Expression and Scriptlet in JSP?


A: Expression is used to output the result of an expression to the response, while scriptlet is used to include a block of Java code in the JSP.

B: Expression is used to include a block of Java code in the JSP, while scriptlet is used to output the result of an expression to the response.

C: Expression is used to include a block of HTML code in the JSP, while scriptlet is used to include a block of JavaScript code in the JSP.


Correct Response: 1

Explanation: The difference between an expression and a scriptlet in JSP is that an expression is used to output the result of an expression to the response, while a scriptlet is used to include a block of Java code in the JSP. Expressions are used to dynamically generate content in a JSP page, while scriptlets allow you to include more complex logic and control structures in your JSP code.





Q: How will you delete a Cookie in JSP?


A: By setting the maximum age to 0.

B: By setting the value to null.

C: By setting the value to an empty string.


Correct Response: 1

Explanation: You can delete a cookie in JSP by setting its maximum age to 0. This sets the cookie's expiration date to a date in the past, causing the cookie to be deleted by the browser.





Q: How will you use a Cookie in JSP?


A: By using the addCookie method of the response object to create a new cookie, and the getCookies method of the request object to retrieve the cookie from the request.

B: By using the setCookie method of the response object to create a new cookie, and the getCookie method of the request object to retrieve the cookie from the request.

C: By using the addCookie method of the request object to create a new cookie, and the getCookies method of the response object to retrieve the cookie from the response.


Correct Response: 1

Explanation: You can use a cookie in JSP by using the addCookie method of the response object to create a new cookie, and the getCookies method of the request object to retrieve the cookie from the request. This allows you to store information on the client in the form of a cookie, and retrieve it later when the client makes another request to the server.





Q: What is the main difference between a Session and Cookie in JSP?


A: A session is stored on the server, while a cookie is stored on the client.

B: A session is encrypted, while a cookie is not.

C: A session is persisted across multiple requests, while a cookie is not.


Correct Response: 1

Explanation: The main difference between a session and a cookie in JSP is where the data is stored. A session is stored on the server, while a cookie is stored on the client. This means that sessions are more secure, but also consume server resources, while cookies are less secure but do not consume server resources.





Q: How will you prevent creation of session in JSP?


A: By setting the session attribute in the page directive to false.

B: By setting the session attribute in the jsp directive to false.

C: By setting the session attribute in the servlet directive to false.


Correct Response: 1

Explanation: You can prevent the creation of a session in JSP by setting the session attribute in the page directive to false. This attribute determines whether or not a session will be created for the JSP page. Setting it to false will prevent the creation of a session, even if one does not already exist.





Q: What is an output comment in JSP?


A: A comment that is included in the generated HTML response.

B: A comment that is included in the generated JSP source code.

C: A comment that is excluded from the generated HTML response.


Correct Response: 1

Explanation: An output comment in JSP is a comment that is included in the generated HTML response. Output comments are used to provide information or documentation about the JSP page that is visible to the end user, but are not included in the HTML source code.





Q: How will you prevent caching of HTML output by web browser in JSP?


A: By setting the appropriate HTTP headers in the response.

B: By setting the appropriate attributes in the page directive.

C: By setting the appropriate attributes in the jsp directive.


Correct Response: 1

Explanation: You can prevent caching of HTML output by a web browser in JSP by setting the appropriate HTTP headers in the response. This can be done by using the response object to set headers such as Cache-Control, Pragma, and Expires, to indicate that the content should not be cached.





Q: How will you redirect request to another page in browser in JSP code?


A: By using the sendRedirect method of the response object.

B: By using the forward method of the request object.

C: By using the redirect method of the response object.


Correct Response: 1

Explanation: You can redirect a request to another page in a browser in JSP code by using the sendRedirect method of the response object. The sendRedirect method causes the browser to issue a new request for the specified URL, allowing you to redirect the user to another page.





Q: What is the difference between sendRedirect and forward in a JSP?


A: sendRedirect causes the browser to issue a new request for the specified URL, while forward forwards the request to another resource, such as another JSP page or servlet, without the browser being aware.

B: sendRedirect forwards the request to another resource, such as another JSP page or servlet, without the browser being aware, while sendRedirect causes the browser to issue a new request for the specified URL.

C: sendRedirect causes the request to be processed by another JSP page, while forward causes the request to be processed by another servlet.


Correct Response: 1

Explanation: The difference between sendRedirect and forward in JSP is that sendRedirect causes the browser to issue a new request for the specified URL, while forward forwards the request to another resource, such as another JSP page or servlet, without the browser being aware. This means that the URL in the browser's address bar will not change when using forward, while it will change when using sendRedirect.





Q: What is the use of config implicit object in JSP?


A: To provide access to the ServletConfig object for the JSP page.

B: To provide access to the ServletContext object for the JSP page.

C: To provide access to the HttpServletRequest object for the JSP page.


Correct Response: 1

Explanation: The config implicit object in JSP provides access to the ServletConfig object for the JSP page. The ServletConfig object provides access to initialization parameters for the JSP page, such as parameters specified in the web.xml file. This allows you to configure your JSP pages using configuration information stored in the deployment descriptor.





Q: What is the purpose of RequestDispatcher?


A: To transfer control from one resource to another resource.

B: To process a request and generate a response.

C: To manage the lifecycle of a servlet.


Correct Response: 1

Explanation: The purpose of RequestDispatcher is to transfer control from one resource to another resource. This allows you to forward a request from one servlet or JSP page to another resource, such as another servlet, JSP page, or HTML file, without the client being aware. The RequestDispatcher can also be used to include the output of another resource in the response generated by the current resource.





Q: How can be read data from a Form in a JSP?


A: By using the getParameter method of the request object to retrieve the form data.

B: By using the getAttribute method of the request object to retrieve the form data.

C: By using the getParameterValues method of the request object to retrieve the form data.


Correct Response: 1

Explanation: You can read data from a form in a JSP by using the getParameter method of the request object to retrieve the form data. The getParameter method allows you to retrieve the value of a form field, based on its name, from the request object. You can use this method to read form data submitted by the user and process it in your JSP code.





Q: What is a filter in JSP?


A: A component that is used to perform pre-processing or post-processing on a request or response.

B: A component that is used to manage the lifecycle of a servlet.

C: A component that is used to generate a response.


Correct Response: 1

Explanation: A filter in JSP is a component that is used to perform pre-processing or post-processing on a request or response. Filters can be used to perform tasks such as logging, authentication, or data compression, before or after a request is processed by a servlet or JSP page. Filters are defined in the deployment descriptor and are applied to a set of URLs or servlets using URL patterns or servlet names.





Q: How can you upload a large file in JSP?


A: By using a servlet to handle the file upload and process the uploaded file.

B: By using a JSP page to handle the file upload and process the uploaded file.

C: By using a filter to handle the file upload and process the uploaded file.


Correct Response: 1

Explanation: You can upload a large file in JSP by using a servlet to handle the file upload and process the uploaded file. This allows you to handle the file upload process in a separate component, separate from your JSP pages, and allows you to take advantage of the full power of Java to process the uploaded file as needed. You can use a servlet to process the uploaded file and then pass the processed data back to a JSP page for presentation to the user.





Q: In which scenario, Container initializes multiple JSP/Servlet objects?


A: When multiple clients access the same JSP/Servlet simultaneously.

B: When the JSP/Servlet is configured with a load-on-startup value in the deployment descriptor.

C: When the JSP/Servlet is accessed for the first time and is not already loaded in memory.


Correct Response: 1

Explanation: The container initializes multiple JSP/Servlet objects when multiple clients access the same JSP/Servlet simultaneously. This is done to ensure that each client request is handled by a separate instance of the JSP/Servlet, allowing each request to be processed independently and concurrently.





Q: What is the purpose of JSP and how is it different from Servlets?


A: JSP is used to generate dynamic web pages, while Servlets are used to handle client requests and generate responses. JSP is simpler and easier to use than Servlets, but Servlets have more control over the request and response.

B: JSP is used to handle client requests and generate responses, while Servlets are used to generate dynamic web pages. JSP is simpler and easier to use than Servlets, but Servlets have more control over the request and response.

C: JSP is used to handle client requests, while Servlets are used to generate dynamic web pages and handle client requests. JSP is simpler and easier to use than Servlets, but Servlets have more control over the request and response.


Correct Response: 1

Explanation: The purpose of JSP is to generate dynamic web pages, while Servlets are used to handle client requests and generate responses. JSP is simpler and easier to use than Servlets, as it provides a higher-level, more abstract API for generating dynamic content. However, Servlets have more control over the request and response, as they are closer to the underlying HTTP protocol.





Q: What is the JSP expression language (EL) and how is it used?


A: The JSP expression language is a simple language used to access data stored in JavaBeans components and other objects, such as request and session attributes. It is used in JSP pages to insert dynamic content into the generated HTML response.

B: The JSP expression language is a complex language used to manipulate data stored in JavaBeans components and other objects, such as request and session attributes. It is used in JSP pages to insert dynamic content into the generated HTML response.

C: The JSP expression language is a simple language used to manipulate data stored in JavaBeans components and other objects, such as request and session attributes. It is used in JSP pages to insert dynamic content into the generated HTML response.


Correct Response: 1

Explanation: The JSP expression language (EL) is a simple language used to access data stored in JavaBeans components and other objects, such as request and session attributes. It is used in JSP pages to insert dynamic content into the generated HTML response, by evaluating expressions and converting the results to strings for inclusion in the response. The EL provides a concise and convenient way to access data stored in Java objects in your JSP pages.





Q: How can you use JSP custom tags in your application?


A: By creating a custom tag library and using the taglib directive in your JSP pages to reference the custom tags.

B: By using the JSTL core library in your JSP pages to access the custom tags.

C: By creating a custom tag handler class and using the tag directive in your JSP pages to reference the custom tags.


Correct Response: 1

Explanation: You can use JSP custom tags in your application by creating a custom tag library and using the taglib directive in your JSP pages to reference the custom tags. Custom tags are reusable components that encapsulate complex logic and presentation into simple, easy-to-use tags. By creating a custom tag library, you can encapsulate complex logic into reusable components that can be used across multiple JSP pages in your application.





Q: How will you access request parameters in JSP?


A: By using the getParameter method of the request object.

B: By using the getAttribute method of the request object.

C: By using the getParameterValues method of the request object.


Correct Response: 1

Explanation: You can access request parameters in JSP by using the getParameter method of the request object. The getParameter method allows you to retrieve the value of a request parameter, based on its name, from the request object. You can use this method to access data submitted by the user in a form or as part of a URL query string.





Q: What is the difference between request and session scope in JSP?


A: Request scope is limited to a single request-response cycle, while session scope is maintained for the life of the session and is available to all pages in a web application.

B: Request scope is maintained for the life of the session and is available to all pages in a web application, while session scope is limited to a single request-response cycle.

C: Request scope is limited to a single JSP page, while session scope is available to all JSP pages in a web application.


Correct Response: 1

Explanation: The difference between request and session scope in JSP is that request scope is limited to a single request-response cycle, while session scope is maintained for the life of the session and is available to all pages in a web application. Objects stored in request scope are accessible only within the current request-response cycle, while objects stored in session scope are accessible to all pages in a web application for the duration of the session.





Q: How can you use a Servlet in JSP to perform background processing?


A: By forwarding the request from a JSP page to a Servlet for processing and then returning the results to the JSP page for presentation.

B: By including the Servlet code in the JSP page and calling the Servlet's methods from the JSP code.

C: By using an asynchronous mechanism, such as AJAX, to send a request to the Servlet and process the results in the background.


Correct Response: 1

Explanation: You can use a Servlet in JSP to perform background processing by forwarding the request from a JSP page to a Servlet for processing and then returning the results to the JSP page for presentation. This allows you to separate the logic for processing the request and generating the response into separate components, and can help to improve the maintainability and modularity of your code.





Q: What is the use of JSTL in JSP and how do you use it?


A: JSTL is a standard tag library for JSP that provides a set of tags for common tasks, such as iteration, conditional processing, and URL management. You use JSTL by including the JSTL library in your JSP pages and using the taglib directive to reference the JSTL tags.

B: JSTL is a custom tag library for JSP that provides a set of tags for common tasks, such as iteration, conditional processing, and URL management. You use JSTL by including the JSTL library in your JSP pages and using the tag directive to reference the JSTL tags.

C: JSTL is a standard tag library for JSP that provides a set of tags for complex tasks, such as iteration, conditional processing, and URL management. You use JSTL by including the JSTL library in your JSP pages and using the taglib directive to reference the JSTL tags.


Correct Response: 1

Explanation: JSTL is a standard tag library for JSP that provides a set of tags for common tasks, such as iteration, conditional processing, and URL management. You use JSTL by including the JSTL library in your JSP pages and using the taglib directive to reference the JSTL tags. JSTL provides a convenient and concise way to perform common tasks in your JSP pages, and can help to improve the maintainability and readability of your code.





Q: What is the use of jspInit() and jspDestroy() methods in JSP?


A: The jspInit() method is called by the JSP container when the JSP page is initialized, while the jspDestroy() method is called by the JSP container when the JSP page is destroyed. These methods can be used to initialize and clean up resources used by the JSP page.

B: The jspInit() method is called by the JSP container when the JSP page is destroyed, while the jspDestroy() method is called by the JSP container when the JSP page is initialized. These methods can be used to initialize and clean up resources used by the JSP page.

C: The jspInit() and jspDestroy() methods are not used in JSP.


Correct Response: 1

Explanation: The jspInit() method is called by the JSP container when the JSP page is initialized, while the jspDestroy() method is called by the JSP container when the JSP page is destroyed. These methods can be used to initialize and clean up resources used by the JSP page, such as database connections, file handles, and other resources that need to be created and released during the lifetime of the JSP page.





Q: How can you use a Java Bean in JSP to store user data?


A: By creating a Java Bean class to represent the data, and using JSP tags, such as jsp:useBean, to access and manipulate the data in the JSP page.

B: By creating a Java Bean class to represent the data, and using JSP expressions, such as ${bean.property}, to access and manipulate the data in the JSP page.

C: By creating a Java Bean class to represent the data, and using Servlet API methods, such as getAttribute and setAttribute, to access and manipulate the data in the JSP page.


Correct Response: 1

Explanation: You can use a Java Bean in JSP to store user data by creating a Java Bean class to represent the data, and using JSP tags, such as jsp:useBean, to access and manipulate the data in the JSP page. Java Beans provide a convenient way to encapsulate data and logic into reusable components that can be used across multiple JSP pages. By using JSP tags, such as jsp:useBean, you can access and manipulate the data in the Java Bean from within your JSP pages.





Q: How can you display data in a table format in JSP?


A: By using HTML table tags, such as table, tr, td, and th, to define the table structure and using JSP code, such as scriptlets, expressions, and JSTL tags, to generate the data for the table.

B: By using JSP tags, such as jsp:table, jsp:row, jsp:cell, and jsp:header, to define the table structure and generate the data for the table.

C: By using JSP expressions, such as ${table}, ${row}, ${cell}, and ${header}, to define the table structure and generate the data for the table.


Correct Response: 1

Explanation: You can display data in a table format in JSP by using HTML table tags, such as table, tr, td, and th, to define the table structure and using JSP code, such as scriptlets, expressions, and JSTL tags, to generate the data for the table. This allows you to define the table structure in HTML and use JSP code to generate the data for the table dynamically, based on the data available at runtime.





Q: What is the difference between getAttribute() and getParameter() in JSP?


A: The getAttribute() method is used to retrieve an attribute from the request, while the getParameter() method is used to retrieve a parameter from the request. An attribute is a piece of data that is associated with the request, while a parameter is a value that is passed as part of the URL or as part of a form submission.

B: The getAttribute() method is used to retrieve a parameter from the request, while the getParameter() method is used to retrieve an attribute from the request. An attribute is a piece of data that is associated with the request, while a parameter is a value that is passed as part of the URL or as part of a form submission.

C: The getAttribute() and getParameter() methods are used interchangeably and serve the same purpose.


Correct Response: 1

Explanation: The getAttribute() method is used to retrieve an attribute from the request, while the getParameter() method is used to retrieve a parameter from the request. An attribute is a piece of data that is associated with the request and can be set using the setAttribute() method, while a parameter is a value that is passed as part of the URL or as part of a form submission and can be retrieved using the getParameter() method.





Q: What is the difference between a JSP and a JSF?


A: JSP (JavaServer Pages) is a technology for building dynamic web pages, while JSF (JavaServer Faces) is a framework for building component-based, event-driven web applications. JSP focuses on generating dynamic HTML content, while JSF provides a more comprehensive framework for building complex, interactive web applications.

B: JSP (JavaServer Pages) is a framework for building component-based, event-driven web applications, while JSF (JavaServer Faces) is a technology for building dynamic web pages. JSP provides a more comprehensive framework for building complex, interactive web applications, while JSF focuses on generating dynamic HTML content.

C: JSP (JavaServer Pages) and JSF (JavaServer Faces) are the same technology and serve the same purpose.


Correct Response: 1

Explanation: JSP (JavaServer Pages) is a technology for building dynamic web pages by embedding Java code in HTML pages, while JSF (JavaServer Faces) is a framework for building component-based, event-driven web applications. JSP provides a simple way to generate dynamic HTML content, while JSF provides a more comprehensive framework for building complex, interactive web applications with a rich set of components, event handling, and state management.





Q: When will you use Strategy Design Pattern in Java?


A: The Strategy Design Pattern is used when you want to define a family of algorithms, encapsulate each algorithm, and make them interchangeable. This allows you to change the algorithm used by your application at runtime, without affecting the client code that uses the algorithm.

B: The Strategy Design Pattern is used when you want to define a single algorithm and make it reusable across multiple parts of your application. This allows you to reuse the same algorithm in multiple places, without having to write the algorithm code multiple times.

C: The Strategy Design Pattern is not used in Java.


Correct Response: 1

Explanation: The Strategy Design Pattern is used when you want to define a family of algorithms, encapsulate each algorithm, and make them interchangeable. This allows you to change the algorithm used by your application at runtime, based on the needs of the application or the user, without affecting the client code that uses the algorithm. The Strategy Design Pattern is particularly useful when you have multiple algorithms that perform similar tasks and you want to allow the user or the application to choose between them.





Q: What is Observer design pattern?


A: A design pattern that allows objects to notify other objects about changes in their state.

B: A design pattern that allows objects to change their behavior based on the state.

C: A design pattern that allows objects to store their state.


Correct Response: 1

Explanation: Observer design pattern is a design pattern that allows objects to notify other objects about changes in their state. This pattern defines a one-to-many relationship between objects, where one object is the subject and the other objects are the observers.





Q: What are the examples of Observer design pattern in JDK?


A: java.util.Observable

B: java.util.EventListener

C: java.util.Observer

D: java.util.Listener


Correct Response: 1, 3

Explanation: java.util.Observable and java.util.Observer are examples of Observer design pattern in JDK. The Observable class is used to represent the subject, while the Observer interface is used to represent the observers.





Q: How Strategy design pattern is different from State design pattern in Java?


A: Strategy design pattern is used to change the behavior of an object dynamically, while State design pattern is used to change the state of an object dynamically.

B: Strategy design pattern is used to change the state of an object dynamically, while State design pattern is used to change the behavior of an object dynamically.

C: Both are the same.


Correct Response: 1

Explanation: Strategy design pattern is used to change the behavior of an object dynamically, while State design pattern is used to change the state of an object dynamically. The Strategy design pattern defines a set of algorithms and allows the client to choose one of them, while the State design pattern allows an object to change its behavior based on its internal state.





Q: Can you explain Decorator design pattern with an example in Java?


A: Yes

B: No

C: nan


Correct Response: 1

Explanation: The Decorator design pattern allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. For example, in Java, you can create a class for a basic beverage such as coffee, and then create decorator classes for adding condiments such as milk and sugar.





Q: What is a good scenario for using Composite design Pattern in Java?


A: When you want to represent part-whole hierarchies of objects.

B: When you want to represent a single object.

C: When you want to represent multiple objects.


Correct Response: 1

Explanation: Composite design pattern is used to represent part-whole hierarchies of objects. This pattern is useful when you want to treat a group of objects in the same way as a single instance of an object. For example, in a graphical user interface, you can use the Composite design pattern to represent a tree structure of objects, where each node can be either a leaf node or a composite node.





Q: Have you used Singleton design pattern in your Java project?


A: Yes

B: No

C: nan


Correct Response: 1

Explanation: As an AI language model, I don't have personal experiences, but the Singleton design pattern is a commonly used design pattern in Java projects. It is used to ensure that a class has only one instance, while providing a global point of access to this instance.





Q: What are the main uses of Singleton design pattern in Java project?


A: To ensure that a class has only one instance.

B: To provide a global point of access to this instance.

C: To control the number of objects created.

D: To provide a single point of control for the system.


Correct Response: 1, 2

Explanation: The main uses of the Singleton design pattern in Java projects are to ensure that a class has only one instance and to provide a global point of access to this instance. This design pattern is useful when you want to limit the number of instances of a class that can be created or when you want to provide a single point of control for the system.





Q: Why java.lang.Runtime is a Singleton in Java?


A: To ensure that there is only one instance of the java.lang.Runtime class.

B: To provide a global point of access to the instance of the java.lang.Runtime class.

C: Both A and B.


Correct Response: 3

Explanation: java.lang.Runtime is a Singleton in Java because it ensures that there is only one instance of the class and provides a global point of access to this instance. The java.lang.Runtime class provides access to the Java runtime system, and it is implemented as a Singleton to ensure that there is only one instance of the class and to provide a single point of control for the system.





Q: What is the way to implement a thread-safe Singleton design pattern in Java?


A: By using the synchronized keyword.

B: By using the volatile keyword.

C: By using double-checked locking.


Correct Response: 1

Explanation: There are several ways to implement a thread-safe Singleton design pattern in Java, including using the synchronized keyword or double-checked locking. Using the synchronized keyword ensures that only one thread can access the getInstance() method at a time, while double-checked locking optimizes the performance by only synchronizing the critical section of the code.





Q: What are the examples of Singleton design pattern in JDK?


A: java.lang.Runtime

B: java.awt.Desktop

C: java.lang.System

D: java.util.Calendar


Correct Response: 1, 3

Explanation: java.lang.Runtime and java.lang.System are examples of the Singleton design pattern in JDK. These classes provide access to the Java runtime system and are implemented as Singletons to ensure that there is only one instance of the class and to provide a single point of control for the system.





Q: What is Template Method design pattern in Java?


A: A design pattern that defines the skeleton of an algorithm and allows subclasses to provide the implementation.

B: A design pattern that allows objects to store their state.

C: A design pattern that allows objects to change their behavior based on the state.


Correct Response: 1

Explanation: The Template Method design pattern is a design pattern that defines the skeleton of an algorithm and allows subclasses to provide the implementation. This pattern is useful when you want to define the steps of an algorithm and allow subclasses to provide the implementation for one or more of the steps.





Q: What are the examples of Template method design pattern in JDK?


A: java.util.AbstractList

B: java.util.AbstractSet

C: java.util.AbstractMap

D: java.util.AbstractQueue


Correct Response: 1, 2

Explanation: java.util.AbstractList, java.util.AbstractSet, and java.util.AbstractMap are examples of the Template Method design pattern in JDK. These classes define the basic structure of their respective collections and allow subclasses to provide the implementation for one or more of the methods.





Q: Can you tell some examples of Factory Method design pattern implementation in Java?


A: java.util.Calendar#getInstance

B: java.util.ResourceBundle#getBundle

C: java.net.URL#openConnection

D: java.nio.charset.Charset#forName


Correct Response: 1, 2

Explanation: java.util.Calendar#getInstance and java.util.ResourceBundle#getBundle are examples of Factory Method design pattern implementation in Java. These methods provide a factory method to create objects, allowing the client to obtain objects without having to specify the exact class of the object that will be created.





Q: What is the benefit we get by using static factory method to create object?


A: Improved readability

B: Improved type safety

C: Improved flexibility

D: Improved maintainability


Correct Response: 1, 2, 3

Explanation: By using a static factory method to create objects, you can improve the readability, type safety, and flexibility of your code. Static factory methods can have descriptive names, making the code more readable, and they can return objects of a specific type, improving type safety. Additionally, static factory methods can be changed or overridden, making your code more flexible and maintainable.





Q: What are the examples of Builder design pattern in JDK?


A: java.lang.StringBuilder

B: java.nio.ByteBuffer#put

C: java.lang.StringBuffer

D: java.util.stream.Stream#builder


Correct Response: 1, 3

Explanation: java.lang.StringBuilder and java.lang.StringBuffer are examples of the Builder design pattern in JDK. These classes provide a flexible way to build strings by allowing the client to append characters to the string incrementally.





Q: What are the examples of Abstract Factory design pattern in JDK?


A: java.util.Calendar#getInstance

B: java.util.ResourceBundle#getBundle

C: java.awt.Toolkit#getDefaultToolkit

D: java.nio.charset.Charset#forName


Correct Response: 1, 3

Explanation: java.util.Calendar#getInstance and java.awt.Toolkit#getDefaultToolkit are examples of the Abstract Factory design pattern in JDK. These methods provide a factory method to create objects, allowing the client to obtain objects without having to specify the exact class of the object that will be created.





Q: What are the examples of Decorator design pattern in JDK?


A: java.io.BufferedReader

B: java.io.InputStreamReader

C: java.io.FilterInputStream

D: java.io.FilterOutputStream


Correct Response: 1, 3

Explanation: java.io.BufferedReader and java.io.FilterInputStream are examples of the Decorator design pattern in JDK. These classes provide a flexible way to add behavior to an existing class by wrapping the existing class with additional behavior.





Q: What are the examples of Proxy design pattern in JDK?


A: java.lang.reflect.Proxy

B: java.rmi.Remote

C: java.rmi.Naming

D: java.rmi.registry.Registry


Correct Response: 1, 2

Explanation: java.lang.reflect.Proxy and java.rmi.Remote are examples of the Proxy design pattern in JDK. These classes provide a way to create objects that act as proxies for other objects, allowing the client to interact with the original object indirectly.





Q: What are the examples of Chain of Responsibility design pattern in JDK?


A: java.util.logging.Logger

B: java.util.prefs.Preferences

C: java.awt.event.ActionEvent

D: java.awt.event.ActionListener


Correct Response: 1, 4

Explanation: java.util.logging.Logger and java.awt.event.ActionListener are examples of the Chain of Responsibility design pattern in JDK. These classes provide a way to chain objects together to handle a request, allowing multiple objects to handle the request in turn, without having to specify the exact object that will handle the request.





Q: What are the main uses of Command design pattern?


A: To encapsulate a request as an object.

B: To allow for deferred or undoable execution of operations.

C: To allow for loose coupling between the sender of a request and the receiver of a request.

D: To allow for the dynamic modification of request handling behavior.


Correct Response: 1, 2, 3

Explanation: The main uses of the Command design pattern are to encapsulate a request as an object, to allow for deferred or undoable execution of operations, and to allow for loose coupling between the sender of a request and the receiver of a request. By encapsulating a request as an object, you can dynamically modify the request handling behavior.





Q: What are the examples of Command design pattern in JDK?


A: java.lang.Runnable

B: java.util.concurrent.Callable

C: java.awt.event.ActionEvent

D: java.awt.event.ActionListener


Correct Response: 1, 2

Explanation: java.lang.Runnable and java.util.concurrent.Callable are examples of the Command design pattern in JDK. These classes provide a way to encapsulate a request as an object, allowing for deferred or undoable execution of operations.





Q: What are the examples of Interpreter design pattern in JDK?


A: java.text.Format

B: java.util.Formatter

C: java.text.MessageFormat

D: java.util.Scanner


Correct Response: 1, 2

Explanation: java.text.Format and java.util.Formatter are examples of the Interpreter design pattern in JDK. These classes provide a way to interpret a language or expression, allowing the client to provide input in a specific language and receive output in a specific format.





Q: What are the examples of Mediator design pattern in JDK?


A: java.util.Timer

B: java.util.concurrent.Executor

C: java.awt.EventQueue

D: java.util.concurrent.ScheduledExecutorService


Correct Response: 1, 4

Explanation: java.util.Timer and java.util.concurrent.ScheduledExecutorService are examples of the Mediator design pattern in JDK. These classes provide a way to centralize control of a group of objects, allowing multiple objects to communicate with each other through a single intermediary.





Q: What are the examples of Strategy design pattern in JDK?


A: java.util.Comparator

B: java.util.Collections#sort

C: java.util.Arrays#sort

D: java.util.List#sort


Correct Response: 1, 2

Explanation: java.util.Comparator and java.util.Collections#sort are examples of the Strategy design pattern in JDK. These classes provide a way to encapsulate a strategy or algorithm as an object, allowing the client to dynamically change the behavior of the algorithm.





Q: What are the examples of Visitor design pattern in JDK?


A: java.nio.file.FileVisitor

B: java.util.stream.Stream#map

C: java.util.Iterator

D: java.util.Enumeration


Correct Response: 1

Explanation: java.nio.file.FileVisitor is an example of the Visitor design pattern in JDK. This class provides a way to traverse a file system, allowing the client to provide the implementation for visiting files and directories.





Q: How Decorator design pattern is different from Proxy pattern?


A: Decorator pattern is used to add behavior to an existing class, while Proxy pattern is used to provide a surrogate or placeholder for another object to control access to it.

B: Decorator pattern is used to provide a surrogate or placeholder for another object to control access to it, while Proxy pattern is used to add behavior to an existing class.

C: Both Decorator and Proxy patterns are used to add behavior to an existing class.

D: Neither Decorator nor Proxy patterns are used to add behavior to an existing class.


Correct Response: 1

Explanation: The Decorator pattern is used to add behavior to an existing class, while the Proxy pattern is used to provide a surrogate or placeholder for another object to control access to it. The Decorator pattern allows you to add behavior to an object dynamically, while the Proxy pattern allows you to control access to an object by providing a substitute object.





Q: What are the different scenarios to use Setter and Constructor based injection in Dependency Injection (DI) design pattern?


A: Use setter-based injection when you need to add or remove dependencies dynamically, and use constructor-based injection when you have mandatory dependencies.

B: Use setter-based injection when you have mandatory dependencies, and use constructor-based injection when you need to add or remove dependencies dynamically.

C: Both setter-based and constructor-based injections have the same use cases and can be used interchangeably.

D: Neither setter-based nor constructor-based injections are used in Dependency Injection.


Correct Response: 1

Explanation: Use setter-based injection when you need to add or remove dependencies dynamically, and use constructor-based injection when you have mandatory dependencies. Setter-based injection is useful when you need to add or remove dependencies at runtime, while constructor-based injection is useful when you have mandatory dependencies that must be provided when the object is created.





Q: What are the different scenarios for using Proxy design pattern?


A: To control access to an object.

B: To add behavior to an existing class.

C: To provide a surrogate or placeholder for another object.

D: To convert the interface of one class into another interface that the client expects.


Correct Response: 1, 3

Explanation: The different scenarios for using the Proxy design pattern are to control access to an object and to provide a surrogate or placeholder for another object. By using a Proxy, you can control access to an object by intercepting requests and adding behavior to them before they reach the original object.





Q: What is the main difference between Adapter and Proxy design pattern?


A: The main difference between the Adapter and Proxy design pattern is that the Adapter pattern is used to convert the interface of one class into another interface that the client expects, while the Proxy pattern is used to provide a surrogate or placeholder for another object to control access to it.

B: The main difference between the Adapter and Proxy design pattern is that the Adapter pattern is used to provide a surrogate or placeholder for another object to control access to it, while the Proxy pattern is used to convert the interface of one class into another interface that the client expects.

C: There is no difference between the Adapter and Proxy design pattern.


Correct Response: 1

Explanation: The main difference between the Adapter and Proxy design pattern is that the Adapter pattern is used to convert the interface of one class into another interface that the client expects, while the Proxy pattern is used to provide a surrogate or placeholder for another object to control access to it. The Adapter pattern allows you to adapt the interface of one class to another interface, while the Proxy pattern allows you to control access to an object.





Q: When will you use Adapter design pattern in Java?


A: Use the Adapter design pattern when you need to convert the interface of one class into another interface that the client expects.

B: Use the Adapter design pattern when you need to provide a surrogate or placeholder for another object to control access to it.

C: Use the Adapter design pattern when you need to add behavior to an existing class.

D: Use the Adapter design pattern when there is no need to change the interface of a class.


Correct Response: 1

Explanation: Use the Adapter design pattern when you need to convert the interface of one class into another interface that the client expects. The Adapter pattern allows you to adapt the interface of one class to another interface, making it easier for the client to use the class.





Q: What are the examples of Adapter design pattern in JDK?


A: java.util.Arrays#asList

B: java.io.InputStreamReader

C: java.io.OutputStreamWriter

D: java.util.Collections#list


Correct Response: 1, 2

Explanation: java.util.Arrays#asList and java.io.InputStreamReader are examples of the Adapter design pattern in JDK. These classes provide a way to adapt the interface of one class to another interface, making it easier for the client to use the class.





Q: What is the difference between Factory and Abstract Factory design pattern?


A: The difference between the Factory and Abstract Factory design pattern is that the Factory pattern is used to create objects without exposing the creation logic to the client, while the Abstract Factory pattern is used to create families of related or dependent objects without specifying their concrete classes.

B: The difference between the Factory and Abstract Factory design pattern is that the Factory pattern is used to create families of related or dependent objects without specifying their concrete classes, while the Abstract Factory pattern is used to create objects without exposing the creation logic to the client.

C: There is no difference between the Factory and Abstract Factory design pattern.


Correct Response: 1

Explanation: The difference between the Factory and Abstract Factory design pattern is that the Factory pattern is used to create objects without exposing the creation logic to the client, while the Abstract Factory pattern is used to create families of related or dependent objects without specifying their concrete classes. The Factory pattern allows you to create objects by calling a factory method, while the Abstract Factory pattern allows you to create families of related objects through an abstract factory interface.





Q: What is Open/closed design principle in Software engineering?


A: The Open/closed design principle states that a class or module should be open for extension but closed for modification. This means that the class or module should be designed in such a way that it can be extended to add new functionality, but its existing behavior should not be modified.

B: The Open/closed design principle states that a class or module should be open for modification but closed for extension. This means that the class or module should be designed in such a way that its existing behavior can be modified, but it should not be possible to extend it to add new functionality.

C: The Open/closed design principle does not apply to software engineering.


Correct Response: 1

Explanation: The Open/closed design principle states that a class or module should be open for extension but closed for modification. This means that the class or module should be designed in such a way that it can be extended to add new functionality, but its existing behavior should not be modified. This helps to promote maintainability and flexibility in software design.





Q: What is SOLID design principle?


A: SOLID is an acronym that stands for the five principles of object-oriented design: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.

B: SOLID is an acronym that stands for the five principles of software engineering: Systematic, Organized, Logical, Innovative, and Detail-oriented.

C: SOLID is an acronym that stands for the five principles of database design: Structured, Optimized, Logical, Innovative, and Detail-oriented.


Correct Response: 1

Explanation: SOLID is an acronym that stands for the five principles of object-oriented design: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion. These principles provide guidelines for designing maintainable and scalable software systems.





Q: What is Builder design pattern?


A: The Builder design pattern is a creational design pattern that provides a way to create complex objects step by step using a builder object. The builder object provides a flexible way to create objects, allowing the client to control the construction process and produce different representations of the same object.

B: The Builder design pattern is a behavioral design pattern that provides a way to manage communication between objects in a complex system.

C: The Builder design pattern is a structural design pattern that provides a way to compose objects into tree structures to represent part-whole hierarchies.


Correct Response: 1

Explanation: The Builder design pattern is a creational design pattern that provides a way to create complex objects step by step using a builder object. The builder object provides a flexible way to create objects, allowing the client to control the construction process and produce different representations of the same object.





Q: What are the different categories of Design Patterns used in Object Oriented Design?


A: Creational

B: Structural

C: Behavioral

D: Data Access


Correct Response: 1, 2, 3

Explanation: There are three main categories of Design Patterns used in Object Oriented Design: Creational, Structural, and Behavioral. Creational patterns provide ways to create objects, structural patterns provide ways to compose objects into larger structures, and behavioral patterns provide ways to manage communication between objects in a system.





Q: What is the design pattern suitable to access elements of a Collection?


A: The design pattern suitable to access elements of a Collection is the Iterator design pattern.

B: The design pattern suitable to access elements of a Collection is the Factory design pattern.

C: The design pattern suitable to access elements of a Collection is the Singleton design pattern.

D: The design pattern suitable to access elements of a Collection is the Observer design pattern.


Correct Response: 1

Explanation: The design pattern suitable to access elements of a Collection is the Iterator design pattern. The Iterator design pattern provides a way to access the elements of a Collection one by one without exposing the underlying implementation.





Q: How can we implement Producer Consumer design pattern in Java?


A: The Producer Consumer design pattern can be implemented in Java using the BlockingQueue interface and the put() and take() methods. The Producer adds elements to the BlockingQueue using the put() method, and the Consumer removes elements from the BlockingQueue using the take() method.

B: The Producer Consumer design pattern can be implemented in Java using the synchronized keyword and wait() and notify() methods. The Producer adds elements to a shared queue and notifies the Consumer, and the Consumer removes elements from the shared queue and waits for the Producer to add more elements.

C: The Producer Consumer design pattern cannot be implemented in Java.


Correct Response: 1

Explanation: The Producer Consumer design pattern can be implemented in Java using the BlockingQueue interface and the put() and take() methods. The BlockingQueue interface provides thread-safe methods for adding and removing elements from a queue, making it a good choice for implementing the Producer Consumer design pattern.





Q: What design pattern is suitable to add new features to an existing object?


A: The design pattern suitable to add new features to an existing object is the Decorator design pattern.

B: The design pattern suitable to add new features to an existing object is the Factory design pattern.

C: The design pattern suitable to add new features to an existing object is the Singleton design pattern.

D: The design pattern suitable to add new features to an existing object is the Observer design pattern.


Correct Response: 1

Explanation: The design pattern suitable to add new features to an existing object is the Decorator design pattern. The Decorator design pattern provides a way to add new features to an existing object by wrapping it in a decorator object. This allows you to add new features to an object without modifying its existing behavior.





Q: Which design pattern can be used when to decouple abstraction from the implementation?


A: The design pattern that can be used to decouple abstraction from the implementation is the Bridge design pattern.

B: The design pattern that can be used to decouple abstraction from the implementation is the Factory design pattern.

C: The design pattern that can be used to decouple abstraction from the implementation is the Singleton design pattern.

D: The design pattern that can be used to decouple abstraction from the implementation is the Observer design pattern.


Correct Response: 1

Explanation: The design pattern that can be used to decouple abstraction from the implementation is the Bridge design pattern. The Bridge design pattern provides a way to decouple an abstraction from its implementation, allowing the two to vary independently.





Q: Which is the design pattern used in Android applications?


A: Model-View-Controller (MVC)

B: Model-View-Presenter (MVP)

C: Model-View-ViewModel (MVVM)

D: Singleton


Correct Response: 1, 2, 3

Explanation: Android applications use various design patterns, including Model-View-Controller (MVC), Model-View-Presenter (MVP), and Model-View-ViewModel (MVVM). These design patterns provide a way to separate the presentation and business logic of an application, making it easier to develop, test, and maintain the application.





Q: How can we prevent users from creating more than one instance of singleton object by using clone() method?


A: We can prevent users from creating more than one instance of singleton object by using the clone() method by throwing a CloneNotSupportedException in the clone() method of the Singleton class.

B: We can prevent users from creating more than one instance of singleton object by using the clone() method by making the clone() method private in the Singleton class.

C: We can prevent users from creating more than one instance of singleton object by using the clone() method by making the Singleton class final.


Correct Response: 1

Explanation: We can prevent users from creating more than one instance of singleton object by using the clone() method by throwing a CloneNotSupportedException in the clone() method of the Singleton class. This will prevent users from cloning the singleton object, ensuring that there is only one instance of the object in the system.





Q: What is the use of Interceptor design pattern?


A: The use of the Interceptor design pattern is to provide a way to add behavior to existing objects dynamically. The interceptor objects are created to intercept requests and perform additional actions before or after the request is handled.

B: The use of the Interceptor design pattern is to provide a way to manage communication between objects in a complex system.

C: The use of the Interceptor design pattern is to provide a way to create complex objects step by step using a builder object.


Correct Response: 1

Explanation: The use of the Interceptor design pattern is to provide a way to add behavior to existing objects dynamically. The interceptor objects are created to intercept requests and perform additional actions before or after the request is handled. This allows you to add behavior to objects without modifying their existing behavior.





Q: What are the Architectural patterns that you have used?


A: Some of the architectural patterns that I have used include Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), and Microservices. These patterns provide a way to separate the presentation and business logic of an application, making it easier to develop, test, and maintain the application.

B: Some of the architectural patterns that I have used include Singleton, Factory, and Observer. These patterns provide a way to create objects, manage communication between objects, and add behavior to objects dynamically.

C: nan


Correct Response: 1

Explanation: Some of the architectural patterns that I have used include Model-View-Controller (MVC), Model-View-Presenter (MVP), Model-View-ViewModel (MVVM), and Microservices. These patterns provide a way to separate the presentation and business logic of an application, making it easier to develop, test, and maintain the application.





Q: What are the popular uses of Façade design pattern?


A: The popular uses of the Façade design pattern include providing a simple and unified interface to a complex system, hiding the implementation details of the system, and decoupling the client from the implementation.

B: The popular uses of the Façade design pattern include providing a way to manage communication between objects in a complex system, providing a way to create complex objects step by step using a builder object, and providing a way to add behavior to existing objects dynamically.

C: nan


Correct Response: 1

Explanation: The popular uses of the Façade design pattern include providing a simple and unified interface to a complex system, hiding the implementation details of the system, and decoupling the client from the implementation. The Façade design pattern provides a single, simplified interface to a complex system, making it easier to use and maintain.





Q: What is the difference between Builder design pattern and Factory design pattern?


A: The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to create complex objects step by step using a builder object, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created.

B: The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to manage communication between objects in a complex system, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created.

C: The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to add behavior to existing objects dynamically, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created.


Correct Response: 1

Explanation: The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to create complex objects step by step using a builder object, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created. The Builder design pattern allows you to create complex objects by constructing them step by step, while the Factory design pattern provides a way to create objects by calling a factory method and providing the necessary information for the object to be created.





Q: What is Memento design pattern?


A: The Memento design pattern provides a way to capture and restore an object's internal state without violating encapsulation. The Memento pattern is used to provide a way to undo and redo actions by saving the state of an object before it is changed and restoring it when necessary.

B: The Memento design pattern provides a way to create objects without specifying the exact class of object that will be created.

C: The Memento design pattern provides a way to manage communication between objects in a complex system.


Correct Response: 1

Explanation: The Memento design pattern provides a way to capture and restore an object's internal state without violating encapsulation. The Memento pattern is used to provide a way to undo and redo actions by saving the state of an object before it is changed and restoring it when necessary. The Memento design pattern allows you to save and restore the state of an object without violating its encapsulation.





Q: What is an AntiPattern?


A: An AntiPattern is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive. AntiPatterns are often used in software development and can be seen as the opposite of design patterns, which provide solutions to common problems.

B: An AntiPattern is a design pattern that is used in software development to provide a solution to a common problem.

C: An AntiPattern is a programming language that is used in software development to provide a solution to a common problem.


Correct Response: 1

Explanation: An AntiPattern is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive. AntiPatterns are often used in software development and can be seen as the opposite of design patterns, which provide solutions to common problems. AntiPatterns are used to describe poor or ineffective solutions to common problems in software development.





Q: What is a Data Access Object (DAO) design pattern?


A: The Data Access Object (DAO) design pattern is a software design pattern that provides an abstract interface to some type of database or other persistence mechanism. It provides a way to separate the low-level data accessing API or operations from the high-level business services.

B: The Data Access Object (DAO) design pattern is a software design pattern that provides a way to manage communication between objects in a complex system.

C: The Data Access Object (DAO) design pattern is a software design pattern that provides a way to create complex objects step by step using a builder object.


Correct Response: 1

Explanation: The Data Access Object (DAO) design pattern is a software design pattern that provides an abstract interface to some type of database or other persistence mechanism. It provides a way to separate the low-level data accessing API or operations from the high-level business services. This allows the application to be easily refactored as the persistence mechanism evolves, without changing the high-level business services.





Q: What is the purpose of the Strategy design pattern in Java?


A: The purpose of the Strategy design pattern in Java is to provide a way to define a family of algorithms, encapsulate each one as an object, and make them interchangeable. The Strategy design pattern allows the algorithms to vary independently from clients that use them.

B: The purpose of the Strategy design pattern in Java is to provide a way to create objects without specifying the exact class of object that will be created.

C: The purpose of the Strategy design pattern in Java is to provide a way to manage communication between objects in a complex system.


Correct Response: 1

Explanation: The purpose of the Strategy design pattern in Java is to provide a way to define a family of algorithms, encapsulate each one as an object, and make them interchangeable. The Strategy design pattern allows the algorithms to vary independently from clients that use them. This allows the algorithms to be easily swapped in and out as needed, making the code more flexible and maintainable.





Q: What is the difference between the Observer design pattern and the Publish-Subscribe pattern?


A: The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is a one-to-many relationship between objects, where one object is the subject and the others are observers, while the Publish-Subscribe pattern is a one-to-many relationship between objects, where the objects publish messages and other objects subscribe to receive those messages.

B: The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is a one-to-one relationship between objects, while the Publish-Subscribe pattern is a one-to-many relationship between objects.

C: The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is used in software development to provide a solution to a common problem, while the Publish-Subscribe pattern is used in software development to provide a way to create objects without specifying the exact class of object that will be created.


Correct Response: 1

Explanation: The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is a one-to-many relationship between objects, where one object is the subject and the others are observers, while the Publish-Subscribe pattern is a one-to-many relationship between objects, where the objects publish messages and other objects subscribe to receive those messages. In the Observer pattern, the subject notifies its observers of changes to its state, while in the Publish-Subscribe pattern, objects publish messages and other objects subscribe to receive those messages.





Q: What is an example of the State design pattern in Java?


A: An example of the State design pattern in Java is the behavior of a state machine, where the behavior changes depending on the current state of the machine. For example, a state machine that represents a traffic light, where the behavior changes depending on the current state of the light (red, yellow, green).

B: An example of the State design pattern in Java is the behavior of a shopping cart, where the behavior changes depending on the items in the cart.

C: An example of the State design pattern in Java is the behavior of a game character, where the behavior changes depending on the current state of the character (idle, walking, running, jumping, etc.).


Correct Response: 1, 2, 3

Explanation: All of the options are examples of the State design pattern in Java. The State design pattern allows you to change the behavior of an object based on its current state. In each of the examples given, the behavior changes based on the current state of the object.





Q: What are the advantages of using the Decorator design pattern in Java?


A: Allows for the dynamic addition of responsibilities to objects.

B: Avoids the need for creating subclasses for each combination of responsibilities.

C: Increases the maintainability of the code.

D: All of the above.


Correct Response: 4

Explanation: The Decorator design pattern in Java provides several advantages such as the dynamic addition of responsibilities to objects, avoiding the need for creating subclasses for each combination of responsibilities, and increasing the maintainability of the code.





Q: What is the difference between the Singleton and Prototype design patterns in Java?


A: Singleton pattern creates a single instance of an object while Prototype pattern creates multiple instances of an object.

B: Singleton pattern creates multiple instances of an object while Prototype pattern creates a single instance of an object.

C: Both Singleton and Prototype patterns create multiple instances of an object.


Correct Response: 1

Explanation: The Singleton design pattern in Java ensures that a class has only one instance, while the Prototype design pattern provides a mechanism to create multiple instances of an object by cloning the original object.





Q: What is the difference between the Template Method and Factory Method design patterns in Java?


A: Template Method defines the steps to be executed in a method, while Factory Method creates objects.

B: Factory Method defines the steps to be executed in a method, while Template Method creates objects.

C: Both Template Method and Factory Method create objects.


Correct Response: 1

Explanation: The Template Method design pattern in Java defines the steps to be executed in a method and allows subclasses to provide the implementation for one or more steps. The Factory Method design pattern in Java creates objects by defining a method for creating objects.





Q: What is the difference between the Chain of Responsibility, Command, and Mediator design patterns in Java?


A: Chain of Responsibility passes a request sequentially along a dynamic chain of receivers, Command establishes unidirectional connections between senders and receivers of requests, and Mediator allows communication between objects through a mediator object.

B: Command passes a request sequentially along a dynamic chain of receivers, Chain of Responsibility establishes unidirectional connections between senders and receivers of requests, and Mediator allows communication between objects through a mediator object.

C: Mediator passes a request sequentially along a dynamic chain of receivers, Command establishes unidirectional connections between senders and receivers of requests, and Chain of Responsibility allows communication between objects through a mediator object.


Correct Response: 1

Explanation: The Chain of Responsibility, Command, and Mediator design patterns in Java provide different ways of connecting senders and receivers of requests. The Chain of Responsibility pattern passes a request sequentially along a dynamic chain of receivers, the Command pattern establishes unidirectional connections between senders and receivers of requests, and the Mediator pattern allows communication between objects through a mediator object.





Q: What are the benefits of using the Abstract Factory design pattern in Java?


A: Allows for the creation of objects without specifying their concrete classes.

B: Increases the maintainability of the code.

C: Avoids tight coupling between objects.

D: All of the above.


Correct Response: 4

Explanation: The Abstract Factory design pattern in Java provides several benefits such as allowing for the creation of objects without specifying their concrete classes, increasing the maintainability of the code, and avoiding tight coupling between objects.





Q: What is the difference between the Visitor and Interpreter design patterns in Java?


A: Visitor pattern separates algorithms from the objects on which they operate, while Interpreter pattern defines a grammar for executing a language.

B: Interpreter pattern separates algorithms from the objects on which they operate, while Visitor pattern defines a grammar for executing a language.

C: Both Visitor and Interpreter patterns define a grammar for executing a language.


Correct Response: 1

Explanation: The Visitor design pattern in Java separates algorithms from the objects on which they operate, allowing for the addition of new algorithms without modifying the objects. The Interpreter design pattern in Java defines a grammar for executing a language and provides an interpreter to execute the language.





Q: What is the purpose of the Dependency Injection design pattern in Java?


A: To provide objects with their dependencies.

B: To create objects without specifying their concrete classes.

C: To allow communication between objects through a mediator object.


Correct Response: 1

Explanation: The Dependency Injection design pattern in Java provides objects with their dependencies, allowing for the separation of the concerns of creating and managing dependencies from the concern of using them. This increases the maintainability and testability of the code.





Q: What are the benefits of using the Façade design pattern in Java?


A: Provides a simplified interface to a complex system.

B: Increases the maintainability of the code.

C: Avoids tight coupling between objects.

D: All of the above.


Correct Response: 4

Explanation: The Façade design pattern in Java provides several benefits such as providing a simplified interface to a complex system, increasing the maintainability of the code, and avoiding tight coupling between objects.





Q: What is the difference between the Memento and Prototype design patterns in Java?


A: Memento pattern saves and restores the state of an object, while Prototype pattern creates objects by cloning the original object.

B: Prototype pattern saves and restores the state of an object, while Memento pattern creates objects by cloning the original object.

C: Both Memento and Prototype patterns save and restore the state of an object.


Correct Response: 1

Explanation: The Memento design pattern in Java saves and restores the state of an object, allowing for the undo/redo functionality. The Prototype design pattern in Java creates objects by cloning the original object, allowing for the creation of objects without specifying their concrete classes.





Q: What is an example of an AntiPattern in software design?


A: The Singleton pattern.

B: The God Object pattern.

C: The Factory Method pattern.


Correct Response: 2

Explanation: The God Object AntiPattern in software design is an example of an AntiPattern. This AntiPattern occurs when a single object becomes responsible for too many tasks, making the code difficult to maintain and understand.





Q: What is Spring framework?


A: A Java-based open-source framework for building web applications.

B: A JavaScript-based open-source framework for building web applications.

C: A Python-based open-source framework for building web applications.


Correct Response: 1

Explanation: Spring framework is a Java-based open-source framework for building web applications. It provides a comprehensive set of features for building and managing enterprise-level applications.





Q: What are the benefits of Spring framework in software development?


A: Provides a simplified programming model.

B: Increases the maintainability of the code.

C: Supports the separation of concerns.

D: All of the above.


Correct Response: 4

Explanation: Spring framework provides several benefits in software development such as providing a simplified programming model, increasing the maintainability of the code, and supporting the separation of concerns.





Q: What are the modules in Core Container of Spring framework?


A: Spring Core

B: Spring Beans

C: Spring Context

D: All of the above.


Correct Response: 4

Explanation: The Core Container of Spring framework includes the following modules: Spring Core, Spring Beans, and Spring Context. These modules provide the core functionality of the framework, including the management of beans and their dependencies, and the application context.





Q: What are the modules in Data Access/Integration layer of Spring framework?


A: Spring JDBC

B: Spring ORM

C: Spring Transaction

D: All of the above.


Correct Response: 4

Explanation: The Data Access/Integration layer of Spring framework includes the following modules: Spring JDBC, Spring ORM, and Spring Transaction. These modules provide support for data access and integration with relational databases and other data sources.





Q: What are the modules in Web layer of Spring framework?


A: Spring MVC

B: Spring WebFlux

C: Spring Web Services

D: All of the above.


Correct Response: 1,2

Explanation: The Web layer of Spring framework includes the following modules: Spring MVC and Spring WebFlux. These modules provide support for building web applications and handling HTTP requests.





Q: What is the main use of Core Container module in Spring framework?


A: To provide the core functionality of the framework.

B: To provide support for data access and integration with relational databases.

C: To provide support for building web applications and handling HTTP requests.


Correct Response: 1

Explanation: The Core Container module of Spring framework provides the core functionality of the framework, including the management of beans and their dependencies, and the application context.





Q: What kind of testing can be done in Spring Test Module?


A: Unit Testing

B: Integration Testing

C: Mock Testing

D: All of the above.


Correct Response: 4

Explanation: The Spring Test module provides support for testing Spring-based applications, including Unit Testing, Integration Testing, and Mock Testing. This allows for the testing of different aspects of the application and helps to ensure its reliability and stability.





Q: What is the use of BeanFactory in Spring framework?


A: To manage the creation and configuration of beans.

B: To provide support for data access and integration with relational databases.

C: To provide support for building web applications and handling HTTP requests.


Correct Response: 1

Explanation: BeanFactory in Spring framework is used to manage the creation and configuration of beans. It provides a factory for creating and managing the lifecycle of beans, allowing for the separation of the concerns of creating and managing beans from the concern of using them.





Q: Which is the most popular implementation of BeanFactory in Spring?


A: XmlBeanFactory

B: ApplicationContext

C: ConfigurableListableBeanFactory


Correct Response: 2

Explanation: The most popular implementation of BeanFactory in Spring is ApplicationContext. It provides a more complete and advanced factory pattern implementation, including the ability to support internationalization, event publication, and more.





Q: What is XMLBeanFactory in Spring framework?


A: A deprecated implementation of BeanFactory.

B: A popular implementation of BeanFactory.

C: A module for data access and integration with relational databases.


Correct Response: 1

Explanation: XMLBeanFactory is a deprecated implementation of BeanFactory in Spring framework. It was used for creating and managing the lifecycle of beans, but has since been replaced by ApplicationContext.





Q: What are the uses of AOP module in Spring framework?


A: Logging

B: Transaction Management

C: Security

D: All of the above.


Correct Response: 4

Explanation: The AOP module in Spring framework provides support for aspect-oriented programming, allowing for the separation of cross-cutting concerns such as logging, transaction management, and security from the business logic of the application.





Q: What are the benefits of JDBC abstraction layer module in Spring framework?


A: Simplifies the use of JDBC.

B: Increases the maintainability of the code.

C: Avoids tight coupling between objects.

D: All of the above.


Correct Response: 4

Explanation: The JDBC abstraction layer module in Spring framework provides several benefits such as simplifying the use of JDBC, increasing the maintainability of the code, and avoiding tight coupling between objects.





Q: How does Spring support Object Relational Mapping (ORM) integration?


A: Through its ORM module.

B: Through its JDBC module.

C: Through its AOP module.


Correct Response: 1

Explanation: Spring supports Object Relational Mapping (ORM) integration through its ORM module. This module provides support for integrating with popular ORM frameworks such as Hibernate, JPA, and iBatis.





Q: How does Web module work in Spring framework?


A: By providing support for building web applications and handling HTTP requests.

B: By providing support for data access and integration with relational databases.

C: By providing support for aspect-oriented programming.


Correct Response: 1

Explanation: The Web module in Spring framework provides support for building web applications and handling HTTP requests. This includes support for the Spring MVC and Spring WebFlux frameworks.





Q: What are the main uses of Spring MVC module?


A: Building web applications.

B: Handling HTTP requests.

C: Implementing Model-View-Controller (MVC) architecture.

D: All of the above.


Correct Response: 4

Explanation: The main uses of the Spring MVC module in Spring framework are building web applications, handling HTTP requests, and implementing Model-View-Controller (MVC) architecture. This allows for the separation of the concerns of the data model, user interface, and control logic.





Q: What is the purpose of Spring configuration file?


A: To specify the configuration of the beans and their dependencies.

B: To specify the data access and integration with relational databases.

C: To specify the implementation of aspect-oriented programming.


Correct Response: 1

Explanation: The Spring configuration file is used to specify the configuration of the beans and their dependencies in Spring framework. This allows for the separation of the concerns of creating and managing beans from the concern of using them.





Q: What is the purpose of Spring IoC container?


A: To manage the creation and configuration of beans.

B: To provide support for data access and integration with relational databases.

C: To provide support for building web applications and handling HTTP requests.


Correct Response: 1

Explanation: The purpose of the Spring IoC container is to manage the creation and configuration of beans. It provides a factory for creating and managing the lifecycle of beans, allowing for the separation of the concerns of creating and managing beans from the concern of using them.





Q: What is the main benefit of Inversion of Control (IOC) principle?


A: Increases the maintainability of the code.

B: Avoids tight coupling between objects.

C: Supports the separation of concerns.


Correct Response: 2

Explanation: The main benefit of the Inversion of Control (IOC) principle is that it avoids tight coupling between objects. By allowing objects to be managed by an external entity, such as the Spring IoC container, the dependencies between objects can be managed more effectively, making the code more maintainable.





Q: Does IOC containers support Eager Instantiation or Lazy loading of beans?


A: Both Eager Instantiation and Lazy loading of beans.

B: Eager Instantiation of beans.

C: Lazy loading of beans.


Correct Response: 1

Explanation: IOC containers, such as the Spring IoC container, support both Eager Instantiation and Lazy loading of beans. Eager Instantiation means that the bean is instantiated as soon as the container is created, while Lazy loading means that the bean is instantiated only when it is first accessed.





Q: What are the benefits of ApplicationContext in Spring?


A: Provides a more complete and advanced factory pattern implementation.

B: Supports internationalization.

C: Supports event publication.

D: All of the above.


Correct Response: 4

Explanation: The benefits of ApplicationContext in Spring include providing a more complete and advanced factory pattern implementation, supporting internationalization, and supporting event publication. This allows for the creation and management of beans in a more flexible and advanced manner.





Q: How will you implement ApplicationContext in Spring framework?


A: By using ClassPathXmlApplicationContext or FileSystemXmlApplicationContext.

B: By using BeanFactory.

C: By using XmlBeanFactory.


Correct Response: 1

Explanation: ApplicationContext can be implemented in Spring framework by using ClassPathXmlApplicationContext or FileSystemXmlApplicationContext. These classes provide implementations of the ApplicationContext interface and are used for loading the configuration metadata from XML files.





Q: Explain the difference between ApplicationContext and BeanFactory in Spring?


A: ApplicationContext provides more advanced features than BeanFactory.

B: BeanFactory provides more advanced features than ApplicationContext.

C: Both provide the same features.


Correct Response: 1

Explanation: The main difference between ApplicationContext and BeanFactory in Spring is that ApplicationContext provides more advanced features than BeanFactory. ApplicationContext includes all the features of BeanFactory, but also includes additional features such as support for internationalization, event publication, and more.





Q: Between ApplicationContext and BeanFactory which one is preferable to use in Spring?


A: ApplicationContext is preferable to use.

B: BeanFactory is preferable to use.

C: Both are equally preferable to use.


Correct Response: 1

Explanation: In general, ApplicationContext is preferable to use over BeanFactory in Spring. This is because ApplicationContext provides more advanced features, including support for internationalization, event publication, and more.





Q: What are the main components of a typical Spring based application?


A: Beans.

B: Configuration metadata.

C: ApplicationContext.

D: All of the above.


Correct Response: 4

Explanation: The main components of a typical Spring based application include Beans, Configuration metadata, and ApplicationContext. These components work together to provide a comprehensive and flexible framework for building and managing enterprise-level applications.





Q: Explain Dependency Injection (DI) concept in Spring framework?


A: Dependency Injection (DI) is a design pattern in which the dependencies of an object are managed by an external entity, such as the Spring IoC container.

B: Dependency Injection (DI) is a design pattern in which the dependencies of an object are managed by the object itself.

C: Dependency Injection (DI) is a database management tool.


Correct Response: 1

Explanation: Dependency Injection (DI) is a design pattern in which the dependencies of an object are managed by an external entity, such as the Spring IoC container. This allows for the separation of the concerns of creating and managing objects from the concern of using them, making the code more maintainable and flexible.





Q: What are the different roles in Dependency Injection (DI)?


A: The client.

B: The service.

C: The injector.

D: All of the above.


Correct Response: 4

Explanation: The different roles in Dependency Injection (DI) are the client, the service, and the injector. The client is the object that requires the services, the service is the object that provides the services, and the injector is the entity responsible for injecting the services into the client.





Q: Spring framework provides what kinds of Dependency Injection mechanism?


A: Constructor-based DI.

B: Setter-based DI.

C: Method-based DI.

D: All of the above.


Correct Response: 4

Explanation: Spring framework provides several types of Dependency Injection mechanisms, including Constructor-based DI, Setter-based DI, and Method-based DI. This allows for the injection of dependencies into objects in a flexible and configurable manner.





Q: In Spring framework, which Dependency Injection is better? Constructor-based DI or Setter-based DI?


A: Both are equally good.

B: Constructor-based DI is better.

C: Setter-based DI is better.


Correct Response: 1

Explanation: Both Constructor-based DI and Setter-based DI are equally good and have their own advantages and disadvantages. The choice between them depends on the specific requirements of the application and the preferences of the developers.





Q: What are the advantages of Dependency Injection (DI)?


A: Increases the maintainability of the code.

B: Avoids tight coupling between objects.

C: Supports the separation of concerns.

D: All of the above.


Correct Response: 4

Explanation: The advantages of Dependency Injection (DI) include increasing the maintainability of the code, avoiding tight coupling between objects, and supporting the separation of concerns. This makes the code more flexible and easier to change and test.





Q: What are the disadvantages of Dependency Injection (DI)?


A: Increases the complexity of the code.

B: Decreases the performance of the code.

C: Makes the code harder to understand.

D: All of the above.


Correct Response: 1

Explanation: The disadvantages of Dependency Injection (DI) include increasing the complexity of the code, decreasing the performance of the code, and making the code harder to understand. This can make the code more difficult to maintain and debug.





Q: What is a Spring Bean?


A: An object managed by the Spring IoC container.

B: A database management tool.

C: A web development framework.


Correct Response: 1

Explanation: A Spring Bean is an object that is managed by the Spring IoC container. The Spring IoC container is responsible for creating and managing the lifecycle of beans, allowing for the separation of the concerns of creating and managing objects from the concern of using them.





Q: What does the definition of a Spring Bean contain?


A: The class of the bean.

B: The properties of the bean.

C: The dependencies of the bean.

D: All of the above.


Correct Response: 4

Explanation: The definition of a Spring Bean typically contains information about the class of the bean, the properties of the bean, and the dependencies of the bean. This information is used by the Spring IoC container to create and manage the lifecycle of the bean.





Q: What are the different ways to provide configuration metadata to a Spring Container?


A: XML configuration files.

B: Annotation-based configuration.

C: Java-based configuration.

D: All of the above.


Correct Response: 4

Explanation: There are several ways to provide configuration metadata to a Spring Container, including XML configuration files, Annotation-based configuration, and Java-based configuration. This allows for a flexible and configurable approach to managing the configuration of a Spring-based application.





Q: What are the different scopes of a Bean supported by Spring?


A: Singleton.

B: Prototype.

C: Request.

D: All of the above.


Correct Response: 4

Explanation: The different scopes of a Bean supported by Spring include Singleton, Prototype, and Request. These scopes determine the lifecycle and scope of the beans within the Spring IoC container, allowing for the management of beans in a flexible and configurable manner.





Q: How will you define the scope of a bean in Spring?


A: By using @Scope annotation.

B: By using XML configuration.

C: By using Java configuration.


Correct Response: 1

Explanation: The scope of a bean in Spring can be defined by using the @Scope annotation. This annotation allows for the configuration of the scope of a bean, determining its lifecycle and scope within the Spring IoC container.





Q: Is it safe to assume that a Singleton bean is thread safe in Spring Framework?


A: No, it is not safe to assume that a Singleton bean is thread safe in Spring Framework.

B: Yes, it is safe to assume that a Singleton bean is thread safe in Spring Framework.

C: It depends on the implementation of the bean.


Correct Response: 1

Explanation: No, it is not safe to assume that a Singleton bean is thread safe in Spring Framework. Although a Singleton bean is only created once within the Spring IoC container, it can still be accessed and modified by multiple threads, leading to potential concurrency issues. Therefore, it is important to ensure the thread safety of Singleton beans in a Spring-based application.





Q: What are the design-patterns used in Spring framework?


A: Dependency Injection.

B: Singleton.

C: Factory Method.

D: All of the above.


Correct Response: 4

Explanation: The design patterns used in Spring framework include Dependency Injection, Singleton, and Factory Method. These design patterns allow for the creation and management of objects in a flexible and configurable manner, making the code more maintainable and flexible.





Q: What is the lifecycle of a Bean in Spring framework?


A: The lifecycle of a Bean in Spring framework refers to the sequence of events that occur from the creation of a Bean to its destruction.

B: The lifecycle of a Bean in Spring framework refers to the sequence of database transactions that occur.

C: The lifecycle of a Bean in Spring framework refers to the sequence of web requests that occur.


Correct Response: 1

Explanation: The lifecycle of a Bean in Spring framework refers to the sequence of events that occur from the creation of a Bean to its destruction. This includes the initialization, destruction, and destruction of a Bean, as well as any other events that may occur during its lifetime within the Spring IoC container.





Q: What are the two main groups of methods in a Bean’s lifecycle?


A: Initialization methods and destruction methods.

B: Creation methods and destruction methods.

C: Configuration methods and destruction methods.


Correct Response: 1

Explanation: The two main groups of methods in a Bean's lifecycle are Initialization methods and Destruction methods. These methods are used to manage the lifecycle of a Bean within the Spring IoC container, allowing for the configuration and management of the Bean in a flexible and configurable manner.





Q: Can we override main lifecycle methods of a Bean in Spring?


A: Yes, we can override the main lifecycle methods of a Bean in Spring.

B: No, we cannot override the main lifecycle methods of a Bean in Spring.

C: It depends on the implementation of the Bean.


Correct Response: 1

Explanation: Yes, we can override the main lifecycle methods of a Bean in Spring. This allows for the customization of the lifecycle of a Bean within the Spring IoC container, making the code more flexible and configurable.





Q: What are Inner beans in Spring?


A: Inner beans in Spring are beans that are defined within the scope of another bean.

B: Inner beans in Spring are beans that are defined outside of the scope of the application.

C: Inner beans in Spring are beans that are defined within the scope of the application.


Correct Response: 1

Explanation: Inner beans in Spring are beans that are defined within the scope of another bean. This allows for the creation of nested objects within the Spring IoC container, making the code more flexible and configurable.





Q: How can we inject a Java Collection in Spring framework?


A: We can inject a Java Collection in Spring framework by using the Collection and Map interface.

B: We can inject a Java Collection in Spring framework by using the List and Set interface.

C: We can inject a Java Collection in Spring framework by using the Map and Set interface.


Correct Response: 1

Explanation: We can inject a Java Collection in Spring framework by using the Collection and Map interface. This allows for the creation and management of collections of objects within the Spring IoC container, making the code more flexible and configurable.





Q: What is Bean wiring in Spring?


A: Bean wiring in Spring refers to the process of connecting the dependencies between beans within the Spring IoC container.

B: Bean wiring in Spring refers to the process of creating beans within the Spring IoC container.

C: Bean wiring in Spring refers to the process of destroying beans within the Spring IoC container.


Correct Response: 1

Explanation: Bean wiring in Spring refers to the process of connecting the dependencies between beans within the Spring IoC container. This allows for the separation of the concerns of creating and managing objects from the concern of using them, making the code more flexible and configurable.





Q: What is Autowiring in Spring?


A: Autowiring in Spring refers to the process of automatically wiring beans together based on their types.

B: Autowiring in Spring refers to the process of manually wiring beans together based on their types.

C: Autowiring in Spring refers to the process of automatically wiring beans together based on their names.


Correct Response: 1

Explanation: Autowiring in Spring refers to the process of automatically wiring beans together based on their types. This allows for the automatic resolution of dependencies between beans, making the code more flexible and configurable.





Q: What are the different modes of Autowiring supported by Spring?


A: byType.

B: byName.

C: Constructor.

D: All of the above.


Correct Response: 4

Explanation: The different modes of Autowiring supported by Spring include byType, byName, and Constructor. These modes determine how the dependencies between beans are resolved, allowing for the automatic wiring of beans in a flexible and configurable manner.





Q: What are the cases in which Autowiring may not work in Spring framework?


A: When two or more beans of the same type are defined.

B: When no unique bean of the required type is found.

C: When there are multiple candidate beans but none of them have explicitly been marked as the primary bean.

D: All of the above.


Correct Response: 4

Explanation: Autowiring may not work in Spring framework in cases where two or more beans of the same type are defined, when no unique bean of the required type is found, and when there are multiple candidate beans but none of them have explicitly been marked as the primary bean. These scenarios can lead to ambiguity in the resolution of dependencies between beans, making it necessary to use other methods of wiring beans together.





Q: Is it allowed to inject null or empty String values in Spring?


A: Yes, it is allowed to inject null or empty String values in Spring.

B: No, it is not allowed to inject null or empty String values in Spring.

C: It depends on the implementation of the Bean.


Correct Response: 1

Explanation: Yes, it is allowed to inject null or empty String values in Spring. However, it is important to note that this may lead to issues in the application if the Bean depends on the injected value being non-null or non-empty.





Q: What is a Java-based Configuration in Spring?


A: Java-based Configuration in Spring refers to the configuration of the Spring IoC container using Java code, rather than XML or other configuration files.

B: Java-based Configuration in Spring refers to the configuration of the Spring IoC container using XML or other configuration files.

C: Java-based Configuration in Spring refers to the configuration of the Java virtual machine.


Correct Response: 1

Explanation: Java-based Configuration in Spring refers to the configuration of the Spring IoC container using Java code, rather than XML or other configuration files. This allows for a more flexible and configurable approach to managing the configuration of a Spring-based application.





Q: What is the purpose of @Configuration annotation?


A: The purpose of the @Configuration annotation in Spring is to indicate that a class should be considered a source of bean definitions.

B: The purpose of the @Configuration annotation in Spring is to indicate that a class should not be considered a source of bean definitions.

C: The purpose of the @Configuration annotation in Spring is to indicate that a class is a bean.


Correct Response: 1

Explanation: The purpose of the @Configuration annotation in Spring is to indicate that a class should be considered a source of bean definitions. This allows for the configuration of the Spring IoC container using Java code, rather than XML or other configuration files.





Q: What is the difference between Full @Configuration and 'lite' @Beans mode?


A: The difference between Full @Configuration and 'lite' @Beans mode is that Full @Configuration provides full support for defining bean definitions in a class, while 'lite' @Beans mode provides a lighter weight alternative.

B: The difference between Full @Configuration and 'lite' @Beans mode is that Full @Configuration provides limited support for defining bean definitions in a class, while 'lite' @Beans mode provides full support.

C: There is no difference between Full @Configuration and 'lite' @Beans mode.


Correct Response: 1

Explanation: The difference between Full @Configuration and 'lite' @Beans mode is that Full @Configuration provides full support for defining bean definitions in a class, while 'lite' @Beans mode provides a lighter weight alternative. 'lite' @Beans mode is typically used for simple use cases, while Full @Configuration is used for more complex configurations.





Q: In Spring framework, what is Annotation-based container configuration?


A: Annotation-based container configuration in Spring refers to the configuration of the Spring IoC container using annotations, rather than XML or other configuration files.

B: Annotation-based container configuration in Spring refers to the configuration of the Spring IoC container using XML or other configuration files.

C: Annotation-based container configuration in Spring refers to the configuration of annotations within the code.


Correct Response: 1

Explanation: Annotation-based container configuration in Spring refers to the configuration of the Spring IoC container using annotations, rather than XML or other configuration files. This allows for a more flexible and configurable approach to managing the configuration of a Spring-based application.





Q: How will you switch on Annotation based wiring in Spring?


A: In order to switch on Annotation based wiring in Spring, we need to add the <context:annotation-config /> element to our application context XML configuration file.

B: In order to switch on Annotation based wiring in Spring, we need to remove the <context:annotation-config /> element from our application context XML configuration file.

C: In order to switch on Annotation based wiring in Spring, we need to use a different configuration file that supports Annotation based wiring.


Correct Response: 1

Explanation: In order to switch on Annotation based wiring in Spring, we need to add the <context:annotation-config /> element to our application context XML configuration file. This allows for the use of annotations for configuring the Spring IoC container, rather than using XML or other configuration





Q: What is @Autowired annotation?


A: The @Autowired annotation in Spring is used to automatically wire a Bean with its dependencies.

B: The @Autowired annotation in Spring is used to prevent a Bean from being automatically wired with its dependencies.

C: The @Autowired annotation in Spring is used to manually wire a Bean with its dependencies.


Correct Response: 1

Explanation: The @Autowired annotation in Spring is used to automatically wire a Bean with its dependencies. This allows for the resolution of dependencies between Beans in a flexible and configurable manner, making it easier to manage the configuration of a Spring-based application.





Q: What is @Required annotation?


A: The @Required annotation in Spring is used to indicate that a Bean property must be wired with a dependency, otherwise an error will be thrown.

B: The @Required annotation in Spring is used to indicate that a Bean property must not be wired with a dependency, otherwise an error will be thrown.

C: The @Required annotation in Spring is used to manually wire a Bean property with a dependency.


Correct Response: 1

Explanation: The @Required annotation in Spring is used to indicate that a Bean property must be wired with a dependency, otherwise an error will be thrown. This allows for the enforcement of mandatory dependencies between Beans, helping to ensure that the configuration of a Spring-based application is consistent and complete.





Q: What are the two ways to enable RequiredAnnotationBeanPostProcessor in Spring?


A: By including the <context:annotation-config /> element in the application context XML configuration file.

B: By including the <context:required-annotation /> element in the application context XML configuration file.

C: By adding the @Autowired annotation to the Bean property.

D: All of the above.


Correct Response: 1, 2

Explanation: The two ways to enable RequiredAnnotationBeanPostProcessor in Spring are by including the <context:annotation-config /> element in the application context XML configuration file, and by including the <context:required-annotation /> element in the application context XML configuration file. These elements allow for the enforcement of mandatory dependencies between Beans, helping to ensure that the configuration of a Spring-based application is consistent and complete.





Q: What is @Qualifier annotation in Spring?


A: The @Qualifier annotation in Spring is used to resolve any ambiguity in the resolution of dependencies between Beans.

B: The @Qualifier annotation in Spring is used to create ambiguity in the resolution of dependencies between Beans.

C: The @Qualifier annotation in Spring is used to manually wire a Bean with its dependencies.


Correct Response: 1

Explanation: The @Qualifier annotation in Spring is used to resolve any ambiguity in the resolution of dependencies between Beans. This allows for the specification of which Bean should be used for a particular dependency, making it easier to manage the configuration of a Spring-based application.





Q: How Spring framework makes JDBC coding easier for developers?


A: Spring framework makes JDBC coding easier for developers by providing a higher level of abstraction and reducing the amount of code that needs to be written to perform common database operations.

B: Spring framework makes JDBC coding harder for developers by providing a lower level of abstraction and increasing the amount of code that needs to be written to perform common database operations.

C: Spring framework has no effect on the difficulty of JDBC coding for developers.


Correct Response: 1

Explanation: Spring framework makes JDBC coding easier for developers by providing a higher level of abstraction and reducing the amount of code that needs to be written to perform common database operations. This allows for a more streamlined and efficient approach to database programming, while also making it easier to manage the configuration of a Spring-based application.





Q: What is the purpose of JdbcTemplate?


A: The purpose of JdbcTemplate in Spring is to provide a higher level of abstraction for performing common database operations, making it easier for developers to write JDBC code.

B: The purpose of JdbcTemplate in Spring is to provide a lower level of abstraction for performing common database operations, making it harder for developers to write JDBC code.

C: The purpose of JdbcTemplate in Spring is to provide a different approach to performing common database operations, making it harder for developers to write JDBC code.


Correct Response: 1

Explanation: The purpose of JdbcTemplate in Spring is to provide a higher level of abstraction for performing common database operations, making it easier for developers to write JDBC code. JdbcTemplate eliminates the need for repetitive, low-level code, allowing developers to focus on the logic of their application rather than the details of database programming.





Q: What are the benefits of using Spring DAO?


A: The benefits of using Spring DAO include improved abstraction, reduced code complexity, and increased efficiency in database programming.

B: The benefits of using Spring DAO include increased code complexity, reduced abstraction, and decreased efficiency in database programming.

C: The benefits of using Spring DAO are not related to abstraction, code complexity, or efficiency in database programming.


Correct Response: 1

Explanation: The benefits of using Spring DAO include improved abstraction, reduced code complexity, and increased efficiency in database programming. Spring DAO provides a higher level of abstraction for performing common database operations, allowing developers to focus on the logic of their application rather than the details of database programming.





Q: What are the different ways to use Hibernate in Spring?


A: By using the HibernateTemplate class.

B: By using the HibernateDaoSupport class.

C: By integrating Hibernate directly into the Spring IoC container.

D: All of the above.


Correct Response: 1, 2, 3

Explanation: There are multiple ways to use Hibernate in Spring, including using the HibernateTemplate class, using the HibernateDaoSupport class, and integrating Hibernate directly into the Spring IoC container. Each of these approaches offers a different level of abstraction and flexibility, allowing developers to choose the best solution for their particular needs.





Q: What types of Object Relational Mapping (ORM) are supported by Spring?


A: Hibernate

B: JPA

C: iBATIS

D: All of the above.


Correct Response: 4

Explanation: The types of Object Relational Mapping (ORM) supported by Spring include Hibernate, JPA, and iBATIS. Spring provides a flexible and configurable approach to ORM, allowing developers to choose the best solution for their particular needs.





Q: How will you integrate Spring and Hibernate by using HibernateDaoSupport?


A: To integrate Spring and Hibernate by using HibernateDaoSupport, you need to extend the HibernateDaoSupport class in your DAO implementation and configure the Hibernate SessionFactory in the Spring IoC container.

B: To integrate Spring and Hibernate by using HibernateDaoSupport, you need to extend the HibernateDaoSupport class in your DAO implementation and configure the Hibernate SessionFactory outside of the Spring IoC container.

C: To integrate Spring and Hibernate by using HibernateDaoSupport, you need to extend a different class in your DAO implementation and configure the Hibernate SessionFactory in the Spring IoC container.


Correct Response: 1

Explanation: To integrate Spring and Hibernate by using HibernateDaoSupport, you need to extend the HibernateDaoSupport class in your DAO implementation and configure the Hibernate SessionFactory in the Spring IoC container. This approach provides a higher level of abstraction for performing common database operations and makes it easier to manage the configuration of a Spring-based application.





Q: What are the different types of the Transaction Management supported by Spring framework?


A: Programmatic Transaction Management

B: Declarative Transaction Management

C: Both Programmatic and Declarative Transaction Management


Correct Response: 3

Explanation: The different types of Transaction Management supported by Spring framework include both Programmatic Transaction Management and Declarative Transaction Management. This allows for a flexible and configurable approach to Transaction Management, making it easier to manage the configuration of a Spring-based application.





Q: What are the benefits provided by Spring Framework’s Transaction Management?


A: Improved abstraction and reduced code complexity.

B: Increased efficiency and flexibility in managing transactions.

C: The ability to use either programmatic or declarative approaches to Transaction Management.

D: All of the above.


Correct Response: 4

Explanation: The benefits provided by Spring Framework’s Transaction Management include improved abstraction and reduced code complexity, increased efficiency and flexibility in managing transactions, and the ability to use either programmatic or declarative approaches to Transaction Management. This allows for a more streamlined and efficient approach to database programming, while also making it easier to manage the configuration of a Spring-based application.





Q: Given a choice between declarative and programmatic Transaction Management, which method will you choose?


A: It depends on the specific requirements and constraints of your application.

B: Declarative Transaction Management is always better.

C: Programmatic Transaction Management is always better.


Correct Response: 1

Explanation: Given a choice between declarative and programmatic Transaction Management, the method you choose depends on the specific requirements and constraints of your application. Both methods have their own advantages and disadvantages, and the best choice will depend on the particular needs of your application.





Q: What is Aspect Oriented Programming (AOP)?


A: Aspect Oriented Programming (AOP) is a programming paradigm that allows developers to modularize and encapsulate cross-cutting concerns in a more organized and efficient way.

B: Aspect Oriented Programming (AOP) is a programming paradigm that makes it harder to modularize and encapsulate cross-cutting concerns.

C: Aspect Oriented Programming (AOP) is not a programming paradigm.


Correct Response: 1

Explanation: Aspect Oriented Programming (AOP) is a programming paradigm that allows developers to modularize and encapsulate cross-cutting concerns in a more organized and efficient way. AOP provides a flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.





Q: What is an Aspect in Spring?


A: An Aspect in Spring is a modularized unit of cross-cutting concerns, such as logging, security, and transaction management, that can be encapsulated and encapsulated using AOP techniques.

B: An Aspect in Spring is a unit of cross-cutting concerns that cannot be encapsulated using AOP techniques.

C: An Aspect in Spring is not related to cross-cutting concerns.


Correct Response: 1

Explanation: An Aspect in Spring is a modularized unit of cross-cutting concerns, such as logging, security, and transaction management, that can be encapsulated and encapsulated using AOP techniques. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: In Spring AOP, what is the main difference between a Concern and a Cross cutting concern?


A: A Concern is a specific aspect of an application that can be modularized and encapsulated using AOP techniques, while a Cross cutting concern is a concern that cuts across multiple aspects of an application and affects multiple parts of the system.

B: A Concern is a concern that cuts across multiple aspects of an application and affects multiple parts of the system, while a Cross cutting concern is a specific aspect of an application that can be modularized and encapsulated using AOP techniques.

C: There is no difference between a Concern and a Cross cutting concern in Spring AOP.


Correct Response: 1

Explanation: A Concern is a specific aspect of an application that can be modularized and encapsulated using AOP techniques, while a Cross cutting concern is a concern that cuts across multiple aspects of an application and affects multiple parts of the system. This distinction allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: What is a Joinpoint in Spring AOP?


A: A Joinpoint in Spring AOP is a specific point in the execution of a program, such as a method call or an exception, where an Aspect can be applied.

B: A Joinpoint in Spring AOP is a point in the execution of a program where an Aspect cannot be applied.

C: A Joinpoint in Spring AOP is not related to the execution of a program.


Correct Response: 1

Explanation: A Joinpoint in Spring AOP is a specific point in the execution of a program, such as a method call or an exception, where an Aspect can be applied. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: What is an Advice in Spring AOP?


A: An Advice in Spring AOP is a piece of code that is executed at a specific Joinpoint.

B: An Advice in Spring AOP is not executed at any Joinpoint.

C: An Advice in Spring AOP is not related to Joinpoints.


Correct Response: 1

Explanation: An Advice in Spring AOP is a piece of code that is executed at a specific Joinpoint. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: What is a Pointcut in Spring AOP?


A: A Pointcut in Spring AOP is a predicate that defines a set of Joinpoints, allowing the Aspect to be applied to a specific subset of the program.

B: A Pointcut in Spring AOP is not related to Joinpoints.

C: A Pointcut in Spring AOP does not define a set of Joinpoints.


Correct Response: 1

Explanation: A Pointcut in Spring AOP is a predicate that defines a set of Joinpoints, allowing the Aspect to be applied to a specific subset of the program. This allows for a more flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.





Q: What is an Introduction in Spring AOP?


A: An Introduction in Spring AOP is a way to add new methods or fields to an existing class, allowing for additional functionality to be added to existing objects.

B: An Introduction in Spring AOP is not related to adding new methods or fields to an existing class.

C: An Introduction in Spring AOP is a way to remove methods or fields from an existing class.


Correct Response: 1

Explanation: An Introduction in Spring AOP is a way to add new methods or fields to an existing class, allowing for additional functionality to be added to existing objects. This allows for a more flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.





Q: What is a Target object in Spring AOP?


A: A Target object in Spring AOP is the object being advised by one or more Aspects.

B: A Target object in Spring AOP is not related to being advised by one or more Aspects.

C: A Target object in Spring AOP is the object advising one or more Aspects.


Correct Response: 1

Explanation: A Target object in Spring AOP is the object being advised by one or more Aspects. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: What is a Proxy in Spring AOP?


A: A Proxy in Spring AOP is an object that is created by the AOP framework to represent the Target object, allowing for Aspects to be applied.

B: A Proxy in Spring AOP is not related to the Target object or Aspects.

C: A Proxy in Spring AOP is an object that represents the AOP framework, not the Target object.


Correct Response: 1

Explanation: A Proxy in Spring AOP is an object that is created by the AOP framework to represent the Target object, allowing for Aspects to be applied. This allows for a more flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.





Q: What are the different types of AutoProxy creators in Spring?


A: BeanNameAutoProxyCreator

B: DefaultAdvisorAutoProxyCreator

C: AnnotationAwareAspectJAutoProxyCreator

D: All of the above.


Correct Response: 4

Explanation: The different types of AutoProxy creators in Spring include BeanNameAutoProxyCreator, DefaultAdvisorAutoProxyCreator, and AnnotationAwareAspectJAutoProxyCreator. These different types of AutoProxy creators allow for a flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.





Q: What is Weaving in Spring AOP?


A: Weaving in Spring AOP is the process of linking Aspects to Target objects to create a Proxy, allowing for Aspects to be applied at runtime.

B: Weaving in Spring AOP is not related to linking Aspects to Target objects or creating a Proxy.

C: Weaving in Spring AOP is the process of removing Aspects from Target objects.


Correct Response: 1

Explanation: Weaving in Spring AOP is the process of linking Aspects to Target objects to create a Proxy,





Q: In Spring AOP, Weaving is done at compile time or run time?


A: Weaving in Spring AOP is done at runtime.

B: Weaving in Spring AOP is done at compile time.

C: Weaving in Spring AOP is not related to compile time or runtime.


Correct Response: 1

Explanation: Weaving in Spring AOP is done at runtime. This allows for a more flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.





Q: What is XML Schema-based Aspect implementation?


A: XML Schema-based Aspect implementation is a way to define Aspects and their configuration in a Spring AOP application using XML.

B: XML Schema-based Aspect implementation is not related to defining Aspects and their configuration in a Spring AOP application.

C: XML Schema-based Aspect implementation is a way to define Aspects and their configuration in a non-Spring AOP application.


Correct Response: 1

Explanation: XML Schema-based Aspect implementation is a way to define Aspects and their configuration in a Spring AOP application using XML. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: What is Annotation-based aspect implementation in Spring AOP?


A: Annotation-based aspect implementation in Spring AOP is a way to define Aspects and their configuration in a Spring AOP application using annotations.

B: Annotation-based aspect implementation in Spring AOP is not related to defining Aspects and their configuration in a Spring AOP application.

C: Annotation-based aspect implementation in Spring AOP is a way to define Aspects and their configuration in a non-Spring AOP application.


Correct Response: 1

Explanation: Annotation-based aspect implementation in Spring AOP is a way to define Aspects and their configuration in a Spring AOP application using annotations. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: How does Spring MVC framework work?


A: Spring MVC framework works by providing a flexible and configurable architecture for building web applications, using a Model-View-Controller (MVC) design pattern.

B: Spring MVC framework does not work by providing a flexible and configurable architecture for building web applications.

C: Spring MVC framework works by providing a rigid and non-configurable architecture for building web applications.


Correct Response: 1

Explanation: Spring MVC framework works by providing a flexible and configurable architecture for building web applications, using a Model-View-Controller (MVC) design pattern. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.





Q: What is DispatcherServlet?


A: DispatcherServlet is the main entry point for all web requests in a Spring MVC application.

B: DispatcherServlet is not the main entry point for all web requests in a Spring MVC application.

C: DispatcherServlet is an optional component in a Spring MVC application.


Correct Response: 1

Explanation: DispatcherServlet is the main entry point for all web requests in a Spring MVC application. It is responsible for routing incoming requests to the appropriate controller for processing, and then returning the results to the client.





Q: Can we have more than one DispatcherServlet in Spring MVC?


A: Yes, we can have more than one DispatcherServlet in a Spring MVC application.

B: No, we cannot have more than one DispatcherServlet in a Spring MVC application.

C: DispatcherServlet is an optional component in a Spring MVC application.


Correct Response: 1

Explanation: Yes, we can have more than one DispatcherServlet in a Spring MVC application. This can be useful when we need to handle multiple types of requests, such as web requests and RESTful requests, in a single application.





Q: What is WebApplicationContext in Spring MVC?


A: WebApplicationContext is a sub-interface of ApplicationContext, specifically designed to support web applications in Spring MVC.

B: WebApplicationContext is not a sub-interface of ApplicationContext, and is not specifically designed to support web applications in Spring MVC.

C: WebApplicationContext is an optional component in a Spring MVC application.


Correct Response: 1

Explanation: WebApplicationContext is a sub-interface of ApplicationContext, specifically designed to support web applications in Spring MVC. It provides access to the context-specific information, such as the ServletContext and the HttpServletRequest.





Q: What is Controller in Spring MVC framework?


A: Controller is a component in the Spring MVC framework that is responsible for processing incoming web requests and returning the appropriate response to the client.

B: Controller is not a component in the Spring MVC framework and is not responsible for processing incoming web requests and returning the appropriate response to the client.

C: Controller is an optional component in a Spring MVC application.


Correct Response: 1

Explanation: Controller is a component in the Spring MVC framework that is responsible for processing incoming web requests and returning the appropriate response to the client. It acts as an intermediary between the DispatcherServlet and the Model and View components, handling all of the request processing and response generation.





Q: What is @RequestMapping annotation in Spring?


A: @RequestMapping is a type-level annotation in Spring MVC that is used to map a specific request URL to a specific controller method for processing.

B: @RequestMapping is not a type-level annotation in Spring MVC and is not used to map a specific request URL to a specific controller method for processing.

C: @RequestMapping is an optional annotation in Spring MVC.


Correct Response: 1

Explanation: @RequestMapping is a type-level annotation in Spring MVC that is used to map a specific request URL to a specific controller method for processing. It is used to specify the URL pattern that a specific controller method will handle, and to configure other properties of the request handling process, such as the request method type or the response format.





Q: What are the main features of Spring MVC?


A: Model-View-Controller (MVC) design pattern

B: Support for RESTful web services

C: Built-in support for data validation

D: Built-in support for data binding


Correct Response: 1, 2, 3, 4

Explanation: All of the options are main features of Spring MVC. Model-View-Controller (MVC) design pattern provides a clear separation of responsibilities between the components of the application, support for RESTful web services allows for easy creation of RESTful web services, built-in support for data validation enables data validation before the request is processed, and built-in support for data binding automatically maps request data to objects, making it easier to work with complex data structures.





Q: What is the difference between a Singleton and Prototype bean in Spring?


A: A Singleton bean is a bean that is instantiated only once per application context, whereas a Prototype bean is a bean that is instantiated each time it is requested.

B: A Singleton bean is a bean that is instantiated each time it is requested, whereas a Prototype bean is a bean that is instantiated only once per application context.

C: A Singleton bean and a Prototype bean are the same thing in Spring.


Correct Response: 1

Explanation: A Singleton bean is a bean that is instantiated only once per application context, whereas a Prototype bean is a bean that is instantiated each time it is requested. This means that a Singleton bean is shared across all components in the application, while a Prototype bean is unique to each component that requests it.





Q: How will you decide which scope- Prototype or Singleton to use for a bean in Spring?


A: The choice of scope for a bean in Spring should be based on the specific requirements of the application. For example, if a bean is required to be unique to each component that requests it, then a Prototype scope should be used. If the bean is required to be shared across all components in the application, then a Singleton scope should be used.

B: The choice of scope for a bean in Spring should not be based on the specific requirements of the application, but rather on other factors.

C: The choice of scope for a bean in Spring should always be Singleton.


Correct Response: 1

Explanation: The choice of scope for a bean in Spring should be based on the specific requirements of the application. For example, if a bean is required to be unique





Q: What is the difference between Setter and Constructor based Dependency Injection (DI) in Spring framework?


A: Setter based Dependency Injection (DI) involves injecting dependencies into a bean using setter methods, while Constructor based DI involves injecting dependencies using a constructor.

B: Setter based Dependency Injection (DI) involves injecting dependencies using a constructor, while Constructor based DI involves injecting dependencies into a bean using setter methods.

C: Setter based Dependency Injection (DI) and Constructor based DI are the same thing in Spring.


Correct Response: 1

Explanation: Setter based Dependency Injection (DI) involves injecting dependencies into a bean using setter methods, while Constructor based DI involves injecting dependencies using a constructor. Both Setter based DI and Constructor based DI are supported by Spring, and the choice between them should be based on the specific requirements of the application.





Q: What are the drawbacks of Setter based Dependency Injection (DI) in Spring?


A: It is less readable than Constructor based DI.

B: It is less maintainable than Constructor based DI.

C: It is less testable than Constructor based DI.

D: It is less flexible than Constructor based DI.


Correct Response: 1, 2, 3

Explanation: All of the options are drawbacks of Setter based Dependency Injection (DI) in Spring. Setter based DI can be less readable, less maintainable, less testable, and less flexible than Constructor based DI.





Q: What are the differences between Dependency Injection (DI) and Factory Pattern?


A: The Dependency Injection (DI) pattern involves injecting dependencies into an object, while the Factory pattern involves creating objects without specifying the exact class of object that will be created.

B: The Dependency Injection (DI) pattern involves creating objects without specifying the exact class of object that will be created, while the Factory pattern involves injecting dependencies into an object.

C: The Dependency Injection (DI) pattern and the Factory pattern are the same thing.


Correct Response: 1

Explanation: The Dependency Injection (DI) pattern involves injecting dependencies into an object, while the Factory pattern involves creating objects without specifying the exact class of object that will be created. The Factory pattern is a creational design pattern, while Dependency Injection is a design pattern used for achieving loose coupling between components.





Q: In Spring framework, what is the difference between FileSystemResource and ClassPathResource?


A: FileSystemResource is used to represent a resource that is stored in the file system, while ClassPathResource is used to represent a resource that is stored in the classpath.

B: FileSystemResource is used to represent a resource that is stored in the classpath, while ClassPathResource is used to represent a resource that is stored in the file system.

C: FileSystemResource and ClassPathResource are the same thing in Spring.


Correct Response: 1

Explanation: FileSystemResource is used to represent a resource that is stored in the file system, while ClassPathResource is used to represent a resource that is stored in the classpath. Both FileSystemResource and ClassPathResource are used to represent external resources that can be loaded into the application context in Spring.





Q: Name some popular Spring framework annotations that you use in your project?


A: @Autowired

B: @Controller

C: @Service

D: @Repository


Correct Response: 1, 2, 3, 4

Explanation: All of the options are popular Spring framework annotations. @Autowired is used for dependency injection, @Controller is used to define a controller class in Spring MVC, @Service is used to define a service class, and @Repository is used to define a data access object.





Q: How can you upload a file in Spring MVC Application?


A: By using the MultipartResolver interface

B: By using the Servlet API

C: By using the HttpServletRequest object

D: By using the ModelAndView object


Correct Response: 1

Explanation: You can upload a file in a Spring MVC application by using the MultipartResolver interface. The MultipartResolver is responsible for handling file uploads in a Spring MVC application.





Q: What are the different types of events provided by Spring framework?


A: ContextRefreshedEvent

B: RequestHandledEvent

C: ContextStartedEvent

D: ContextStoppedEvent


Correct Response: 1, 3, 4

Explanation: All of the options are types of events provided by Spring framework. ContextRefreshedEvent is fired when the ApplicationContext is initialized or refreshed, ContextStartedEvent is fired when the ApplicationContext is started, and ContextStoppedEvent is fired when the ApplicationContext is stopped.





Q: What is the difference between DispatcherServlet and ContextLoaderListener in Spring?


A: DispatcherServlet is used for handling web requests and ContextLoaderListener is used for loading the application context

B: DispatcherServlet is used for loading the application context and ContextLoaderListener is used for handling web requests

C: Both are used for handling web requests

D: Both are used for loading the application context


Correct Response: 1

Explanation: DispatcherServlet is used for handling web requests and mapping them to appropriate controllers in a Spring MVC application. ContextLoaderListener, on the other hand, is used for loading the application context in a web application and making it available to all servlets and filters in the application.





Q: How will you handle exceptions in Spring MVC Framework?


A: By using the @ExceptionHandler annotation

B: By using the @ControllerAdvice annotation

C: By using a try-catch block

D: By using the @ResponseStatus annotation


Correct Response: 1, 2

Explanation: You can handle exceptions in a Spring MVC application by using the @ExceptionHandler and @ControllerAdvice annotations. The @ExceptionHandler annotation is used to define a method for handling a specific exception, and the @ControllerAdvice annotation is used to define a class for handling exceptions globally.





Q: What are the best practices of Spring Framework?


A: Use annotations instead of XML configuration

B: Use Dependency Injection (DI) for loosely coupled architecture

C: Use Aspect Oriented Programming (AOP) for modularizing cross-cutting concerns

D: Use a layered architecture


Correct Response: 1, 2, 3

Explanation: All of the options are considered best practices in Spring framework. Using annotations instead of XML configuration makes the code more concise and readable. Using Dependency Injection (DI) helps create a loosely coupled architecture. Using Aspect Oriented Programming (AOP) helps modularize cross-cutting concerns.





Q: What is Spring Boot?


A: A Java-based framework used for building stand-alone, production-grade applications

B: A JavaScript-based framework used for building web applications

C: A Python-based framework used for building machine learning applications

D: A Ruby-based framework used for building web applications


Correct Response: 1

Explanation: Spring Boot is a Java-based framework used for building stand-alone, production-grade applications. It provides a quick and easy way to develop, test, and deploy applications with minimal configuration.





Q: What is the purpose of Spring Boot Starter POMs?


A: To provide a convenient way to include a collection of dependencies in a project

B: To provide a convenient way to exclude a collection of dependencies in a project

C: To provide a convenient way to manage dependencies in a project

D: To provide a convenient way to exclude dependencies from a project


Correct Response: 1

Explanation: The purpose of Spring Boot Starter POMs is to provide a convenient way to include a collection of dependencies in a project. Starter POMs are pre-configured POM files that include a set of dependencies for a particular task, such as web development or data access.





Q: What are the advantages of using Spring Boot?


A: Easy to develop and deploy applications

B: Minimal configuration required

C: Built-in support for popular libraries

D: Auto-configuration of applications


Correct Response: 1, 2, 3, 4

Explanation: All of the options are advantages of using Spring Boot. Spring Boot makes it easy to develop and deploy applications with minimal configuration. It also has built-in support for popular libraries and provides auto-configuration of applications.





Q: How does Spring Boot make it easier to develop and deploy Spring applications?


A: By providing a quick and easy way to develop, test, and deploy applications with minimal configuration

B: By providing a complex and time-consuming way to develop, test, and deploy applications with extensive configuration

C: By providing a way to develop applications with a limited set of features

D: By providing a way to develop applications with a limited set of libraries


Correct Response: 1

Explanation: Spring Boot makes it easier to develop and deploy Spring applications by providing a quick and easy way to develop, test, and deploy applications with minimal configuration. It provides a set of pre-configured options and tools that make it easier to get started with a new project.





Q: What is the difference between Spring Boot and the traditional way of developing Spring applications?


A: Spring Boot provides a quick and easy way to develop, test, and deploy applications with minimal configuration, while the traditional way requires extensive configuration and more manual setup

B: Spring Boot provides a complex and time-consuming way to develop, test, and deploy applications with extensive configuration, while the traditional way is more straightforward and requires less setup

C: Both approaches are the same in terms of development, testing, and deployment

D: Both approaches require extensive configuration and more manual setup


Correct Response: 1

Explanation: The difference between Spring Boot and the traditional way of developing Spring applications is that Spring Boot provides a quick and easy way to develop, test, and deploy applications with minimal configuration, while the traditional way requires extensive configuration and more manual setup. Spring Boot provides a set of pre-configured options and tools that make it easier to get started with a new project.





Q: What is the difference between @SpringBootApplication and @EnableAutoConfiguration annotations in Spring Boot?


A: @SpringBootApplication is a convenience annotation that includes @Configuration, @EnableAutoConfiguration, and @ComponentScan, while @EnableAutoConfiguration enables the automatic configuration of a Spring application

B: @SpringBootApplication is a configuration annotation that enables the automatic configuration of a Spring application, while @EnableAutoConfiguration is a convenience annotation that includes @Configuration, @EnableAutoConfiguration, and @ComponentScan

C: Both annotations are used for the same purpose

D: Both annotations are not used in Spring Boot


Correct Response: 1

Explanation: The difference between the @SpringBootApplication and @EnableAutoConfiguration annotations in Spring Boot is that @SpringBootApplication is a convenience annotation that includes @Configuration, @EnableAutoConfiguration, and @ComponentScan, while @EnableAutoConfiguration enables the automatic configuration of a Spring application. @SpringBootApplication makes it easier to get started with a new project by including a set of commonly used annotations in one place.





Q: How does Spring Boot handle configuration properties?


A: Spring Boot uses the application.properties or application.yml file to manage configuration properties

B: Spring Boot uses environment variables to manage configuration properties

C: Spring Boot uses Java system properties to manage configuration properties

D: Spring Boot uses a database to manage configuration properties


Correct Response: 1

Explanation: Spring Boot uses the application.properties or application.yml file to manage configuration properties. This file can be used to specify configuration options for a Spring Boot application, such as database connection details, server port, and other properties.





Q: What is the purpose of spring-boot-starter-web dependency in Spring Boot?


A: To provide a set of libraries and tools for developing web applications in Spring Boot

B: To provide a set of libraries and tools for developing desktop applications in Spring Boot

C: To provide a set of libraries and tools for developing mobile applications in Spring Boot

D: To provide a set of libraries and tools for developing web services in Spring Boot


Correct Response: 1

Explanation: The purpose of the spring-boot-starter-web dependency in Spring Boot is to provide a set of libraries and tools for developing web applications in Spring Boot. This dependency includes a number of commonly used libraries for building web applications, such as Spring MVC and Tomcat.





Q: What is the difference between @RestController and @Controller annotations in Spring Boot?


A: @RestController is used for creating RESTful web services, while @Controller is used for creating web applications

B: @RestController is used for creating web applications, while @Controller is used for creating RESTful web services

C: Both annotations are used for the same purpose

D: Both annotations are not used in Spring Boot


Correct Response: 1

Explanation: The difference between the @RestController and @Controller annotations in Spring Boot is that @RestController is used for creating RESTful web services, while @Controller is used for creating web applications. @RestController is a specialized version of the @Controller annotation that is used to build RESTful web services.





Q: How does Spring Boot handle security?


A: Spring Boot provides a number of options for securing applications, including basic authentication, OAuth2, and others

B: Spring Boot does not provide any security features

C: Spring Boot uses environment variables for security

D: Spring Boot uses system properties for security


Correct Response: 1

Explanation: Spring Boot provides a number of options for securing applications, including basic authentication, OAuth2, and others. These options can be easily configured in a Spring Boot application to ensure that sensitive data is protected.





Q: What is the difference between Spring Boot and Spring MVC?


A: Spring Boot is a framework for building applications with the Spring framework, while Spring MVC is a module for building web applications in the Spring framework

B: Spring Boot is a module for building web applications in the Spring framework, while Spring MVC is a framework for building applications with the Spring framework

C: Both Spring Boot and Spring MVC are used for the same purpose

D: Both Spring Boot and Spring MVC are not related to each other


Correct Response: 1

Explanation: The difference between Spring Boot and Spring MVC is that Spring Boot is a framework for building applications with the Spring framework, while Spring MVC is a module for building web applications in the Spring framework. Spring Boot provides a number of features and tools for building and deploying applications with the Spring framework, while Spring MVC is focused on building web applications.





Q: What is the purpose of Spring Initializer in Spring Boot?


A: The purpose of Spring Initializer is to provide a quick and easy way to create a new Spring Boot application

B: The purpose of Spring Initializer is to provide a way to manage existing Spring Boot applications

C: The purpose of Spring Initializer is to provide a way to test Spring Boot applications

D: The purpose of Spring Initializer is to provide a way to deploy Spring Boot applications


Correct Response: 1

Explanation: The purpose of Spring Initializer is to provide a quick and easy way to create a new Spring Boot application. Spring Initializer is a web-based tool that allows developers to select the dependencies they need for a project and generate a basic project structure with the required files and configurations.





Q: What is the difference between Spring Boot CLI and Spring Tool Suite (STS)?


A: Spring Boot CLI is a command-line tool for building and running Spring Boot applications, while Spring Tool Suite (STS) is an integrated development environment (IDE) for building Spring applications

B: Spring Boot CLI is an integrated development environment (IDE) for building Spring applications, while Spring Tool Suite (STS) is a command-line tool for building and running Spring Boot applications

C: Both Spring Boot CLI and Spring Tool Suite (STS) are used for the same purpose

D: Both Spring Boot CLI and Spring Tool Suite (STS) are not related to each other


Correct Response: 1

Explanation: The difference between Spring Boot CLI and Spring Tool Suite (STS) is that Spring Boot CLI is a command-line tool for building and running Spring Boot applications, while Spring Tool Suite (STS) is an integrated development environment (IDE) for building Spring applications. Spring Boot CLI provides a simple and convenient way to build and run Spring Boot applications from the command line, while Spring Tool Suite (STS) provides a more comprehensive development environment with features such as code highlighting, debugging, and project management.





Q: What is the difference between an embedded container and a WAR deployment in Spring Boot?


A: An embedded container runs within the application process, while a WAR deployment runs in a separate application server process

B: An embedded container runs in a separate application server process, while a WAR deployment runs within the application process

C: Both options are incorrect

D: Both options are correct


Correct Response: 1

Explanation: The difference between an embedded container and a WAR deployment in Spring Boot is that an embedded container runs within the application process, while a WAR deployment runs in a separate application server process. An embedded container provides a simple and convenient way to run a Spring Boot application, while a WAR deployment provides a more flexible and scalable deployment option for larger and more complex applications.





Q: What are the common use cases for using Spring Boot?


A: Common use cases for using Spring Boot include building and deploying simple, standalone applications; building and deploying microservices; and building and deploying web applications

B: Common use cases for using Spring Boot include building and deploying large enterprise applications; building and deploying desktop applications; and building and deploying mobile applications

C: Both options are incorrect

D: Both options are correct


Correct Response: 1

Explanation: Common use cases for using Spring Boot include building and deploying simple, standalone applications; building and deploying microservices; and building and deploying web applications. Spring Boot provides a number of features and tools that make it easier to build and deploy these types of applications with the Spring framework.





Q: How does Spring Boot handle database configuration and connection management?


A: Spring Boot provides a number of options for configuring and managing database connections, including automatically configuring a connection based on the properties in the application.properties file, manually configuring a connection using JPA or JDBC, and using connection pooling for better performance

B: Spring Boot does not provide any options for configuring and managing database connections

C: Spring Boot uses environment variables for database configuration and connection management

D: Spring Boot uses system properties for database configuration and connection management


Correct Response: 1

Explanation: Spring Boot provides a number of options for configuring and managing database connections, including automatically configuring a connection based on the properties in the application.properties file, manually configuring a connection using JPA or JDBC, and using connection pooling for better performance. These options allow developers to easily integrate a database into a Spring Boot application and manage the connection between the application and the database.





Q: What is Hibernate framework?


A: Hibernate is a Java-based open-source framework for persisting data in relational databases

B: Hibernate is a database management system

C: Hibernate is a web development framework

D: Hibernate is a mobile application development framework


Correct Response: 1

Explanation: Hibernate is a Java-based open-source framework for persisting data in relational databases. It provides a number of tools and features for mapping between objects and relational database tables, performing database operations, and managing transactions.





Q: What is an Object Relational Mapping (ORM)?


A: Object Relational Mapping (ORM) is a technique for mapping data between an object-oriented representation of data and a relational database representation of data

B: Object Relational Mapping (ORM) is a technique for storing data in a relational database

C: Object Relational Mapping (ORM) is a technique for retrieving data from a relational database

D: Object Relational Mapping (ORM) is a technique for querying a relational database


Correct Response: 1

Explanation: Object Relational Mapping (ORM) is a technique for mapping data between an object-oriented representation of data and a relational database representation of data. ORM frameworks like Hibernate provide a way to map objects to database tables, manage database connections, and perform database operations using objects, instead of writing SQL code.





Q: What is the purpose of Configuration Interface in Hibernate?


A: The Configuration interface in Hibernate is used to configure the Hibernate framework and provide information about the relational database and mapping files that Hibernate should use

B: The Configuration interface in Hibernate is used to perform database operations

C: The Configuration interface in Hibernate is used to define objects and relationships between objects

D: The Configuration interface in Hibernate is used to generate SQL code


Correct Response: 1

Explanation: The Configuration interface in Hibernate is used to configure the Hibernate framework and provide information about the relational database and mapping files that Hibernate should use. This interface is used to set up the Hibernate environment and provide the necessary information for Hibernate to connect to the relational database and perform its operations.





Q: What is Object Relational Impedance Mismatch?


A: Object Relational Impedance Mismatch is the difference in the data structures and concepts used in object-oriented programming and relational databases

B: Object Relational Impedance Mismatch is the difficulty in mapping between relational databases and object-oriented programming languages

C: Object Relational Impedance Mismatch is the difference in the data structures and concepts used in relational databases and object-oriented programming

D: Object Relational Impedance Mismatch is the difficulty in mapping between object-oriented programming languages and relational databases


Correct Response: 1

Explanation: Object Relational Impedance Mismatch is the difference in the data structures and concepts used in object-oriented programming and relational databases. This mismatch can make it difficult to persist data in a relational database using an object-oriented programming language, as the data structures and concepts used in the two environments are often quite different.





Q: What are the main problems of Object Relational Impedance Mismatch?


A: Difficulty in mapping object-oriented features to relational databases.

B: Incompatibility between the data types of the two systems.

C: Lack of inheritance and polymorphism support in relational databases.

D: All of the above.


Correct Response: 4

Explanation: Object-Relational Impedance Mismatch refers to the difficulties encountered when trying to map the object-oriented features of a program to the relational databases used to store the data. These difficulties arise from differences in the data types, lack of inheritance and polymorphism support in relational databases, and other factors.





Q: What are the key characteristics of Hibernate?


A: Object/Relational mapping

B: Lightweight

C: Efficient

D: All of the above.


Correct Response: 4

Explanation: Hibernate is a popular Java-based framework for Object/Relational mapping. It is lightweight and efficient, making it a popular choice for developers working with databases.





Q: Can you tell us about the core interfaces of Hibernate framework?


A: SessionFactory

B: Session

C: Configuration

D: Transaction


Correct Response: 1, 2

Explanation: The two core interfaces in Hibernate are SessionFactory and Session. SessionFactory is responsible for creating sessions, while Session is used to interact with the database and perform CRUD operations.





Q: How will you map the columns of a DB table to the properties of a Java class in Hibernate?


A: Using annotations.

B: Using XML mapping files.

C: Both annotations and XML mapping files.


Correct Response: 3

Explanation: In Hibernate, the columns of a DB table can be mapped to the properties of a Java class using either annotations or XML mapping files. Both options are available, giving developers the flexibility to choose the method that works best for their specific use case.





Q: Does Hibernate make it mandatory for a mapping file to have .hbm.xml extension?


A: Yes

B: No

C: It depends on the version of Hibernate being used.


Correct Response: 2

Explanation: No, Hibernate does not make it mandatory for a mapping file to have the .hbm.xml extension. The extension is simply a convention that is commonly used, but other extensions such as .xml or .hbm are also acceptable.





Q: What are the steps for creating a SessionFactory in Hibernate?


A: Create a Configuration object.

B: Add the required mapping files.

C: Build a SessionFactory from the Configuration object.

D: All of the above.


Correct Response: 4

Explanation: To create a SessionFactory in Hibernate, you need to perform the following steps: create a Configuration object, add the required mapping files, and build a SessionFactory from the Configuration object. The SessionFactory is used to create sessions, which are used to interact with the database.





Q: Why do we use POJO in Hibernate?


A: POJO stands for Plain Old Java Object and is used as a simple, plain Java object that can be easily manipulated.

B: POJO stands for Persistent Object Java Object and is used to persist data in a database.

C: POJO stands for Programmed Object Java Object and is used to manipulate data in a program.


Correct Response: 1

Explanation: POJO stands for Plain Old Java Object and is used as a simple, plain Java object that can be easily manipulated. In Hibernate, POJOs are used to represent the data that will be stored in the database, making it easier to manipulate the data and perform CRUD operations.





Q: What is Hibernate Query Language (HQL)?


A: A database query language used in Hibernate.

B: A programming language used in Hibernate.

C: A data retrieval language used in Hibernate.


Correct Response: 1

Explanation: Hibernate Query Language (HQL) is a database query language used in Hibernate to perform database operations. HQL uses an object-oriented syntax that is similar to SQL, but operates on objects rather than tables. This makes it easier to perform complex database operations in Hibernate.





Q: How will you call a stored procedure in Hibernate?


A: By using the createSQLQuery method of the Session object.

B: By using the createQuery method of the Session object.

C: By using the createCriteria method of the Session object.


Correct Response: 1

Explanation: To call a stored procedure in Hibernate, you can use the createSQLQuery method of the Session object. This method allows you to execute native SQL statements, including calls to stored procedures.





Q: What is Criteria API in Hibernate?


A: A programmatic approach to performing database operations in Hibernate.

B: A declarative approach to performing database operations in Hibernate.

C: A graphical approach to performing database operations in Hibernate.


Correct Response: 1

Explanation: Criteria API in Hibernate is a programmatic approach to performing database operations. It allows you to create dynamic and flexible queries by building query objects programmatically, rather than using HQL or native SQL.





Q: Why do we use HibernateTemplate?


A: To simplify the process of working with Hibernate and reduce the amount of code required.

B: To increase the complexity of working with Hibernate and increase the amount of code required.

C: To provide a graphical interface for working with Hibernate.


Correct Response: 1

Explanation: HibernateTemplate is used to simplify the process of working with Hibernate and reduce the amount of code required. It provides a convenient and efficient way to perform common database operations, such as saving and retrieving objects, by abstracting the underlying Hibernate APIs.





Q: How can you see SQL code generated by Hibernate on console?


A: By setting the show_sql property to true in the Configuration object.

B: By setting the print_sql property to true in the Configuration object.

C: By setting the debug_sql property to true in the Configuration object.


Correct Response: 1

Explanation: To see the SQL code generated by Hibernate on the console, you need to set the show_sql property to true in the Configuration object. This will cause Hibernate to log all of the SQL statements that it generates, allowing you to see the exact SQL code that is being executed.





Q: What are the different types of collections supported by Hibernate?


A: Set

B: List

C: Map

D: Array


Correct Response: 1, 2, 3

Explanation: Hibernate supports several different types of collections, including Set, List, and Map. These collections allow you to store multiple values in a single property, making it easier to manage related data.





Q: What is the difference between session.save() and session.saveOrUpdate() methods in Hibernate?


A: session.save() method is used to save a new object, while session.saveOrUpdate() method is used to save an object or update an existing object.

B: session.save() method is used to save an object or update an existing object, while session.saveOrUpdate() method is used to save a new object.

C: Both methods are used to save a new object.

D: Both methods are used to update an existing object.


Correct Response: 1

Explanation: The session.save() method is used to save a new object, while the session.saveOrUpdate() method is used to save an object or update an existing object. If the object being saved already exists in the database, the saveOrUpdate() method will update the existing record, while the save() method will throw an exception.





Q: What are the advantages of Hibernate framework over JDBC?


A: Object/Relational mapping

B: Reduced amount of code required

C: Improved performance

D: All of the above.


Correct Response: 4

Explanation: Hibernate offers several advantages over JDBC, including improved Object/Relational mapping, reduced amount of code required, and improved performance. Hibernate also provides a higher level of abstraction, making it easier to perform database operations, and offers better support for caching and transactions.





Q: How can we get statistics of a SessionFactory in Hibernate?


A: By calling the getStatistics() method of the SessionFactory object.

B: By calling the getSession() method of the SessionFactory object.

C: By calling the getConnection() method of the SessionFactory object.


Correct Response: 1

Explanation: To get statistics of a SessionFactory in Hibernate, you can call the getStatistics() method of the SessionFactory object. This method returns an instance of the Statistics interface, which provides information about the performance and usage of the SessionFactory.





Q: What is the Transient state of an object in Hibernate?


A: An object in the Transient state is an object that has been created, but is not associated with a session.

B: An object in the Transient state is an object that has been associated with a session, but has not yet been saved.

C: An object in the Transient state is an object that has been saved, but has not yet been updated.


Correct Response: 1

Explanation: An object in the Transient state is an object that has been created, but is not associated with a session. Once an object is associated with a session, it will be in the Persistent state and changes made to the object will be saved to the database when the transaction is committed.





Q: What is the Detached state of an object in Hibernate?


A: An object in the Detached state is an object that was previously associated with a session, but has been detached from it.

B: An object in the Detached state is an object that is associated with a session, but has not yet been saved.

C: An object in the Detached state is an object that has been saved, but has not yet been updated.


Correct Response: 1

Explanation: An object in the Detached state is an object that was previously associated with a session, but has been detached from it. Once an object is detached, changes made to the object will not be saved to the database unless the object is reattached to a session.





Q: What is the use of Dirty Checking in Hibernate?


A: Dirty Checking is a mechanism used in Hibernate to track changes made to an object and automatically persist those changes to the database.

B: Dirty Checking is a mechanism used in Hibernate to prevent changes from being made to an object.

C: Dirty Checking is a mechanism used in Hibernate to manually persist changes to an object to the database.


Correct Response: 1

Explanation: Dirty Checking is a mechanism used in Hibernate to track changes made to an object and automatically persist those changes to the database. This makes it easier to manage data, as changes can be made to an object without having to manually persist them to the database.





Q: What is the purpose of Callback interface in Hibernate?


A: The Callback interface in Hibernate is used to receive notifications from Hibernate about the state of an object, such as when it is loaded, saved, or deleted.

B: The Callback interface in Hibernate is used to send notifications to Hibernate about the state of an object.

C: The Callback interface in Hibernate is used to manually manage the state of an object.


Correct Response: 1

Explanation: The Callback interface in Hibernate is used to receive notifications from Hibernate about the state of an object, such as when it is loaded, saved, or deleted. This allows you to perform custom actions, such as logging or auditing, in response to these events.





Q: What are the different ORM levels in Hibernate?


A: Light Object Mapping

B: Medium Object Mapping

C: Full Object Mapping


Correct Response: 3

Explanation: Hibernate supports Full Object Mapping, which means that it provides a complete mapping of an object-oriented model to a relational database. This allows you to work with objects in your code, rather than directly with the database, and provides a high level of abstraction and ease of use.





Q: What are the different ways to configure a Hibernate application?


A: XML configuration file

B: Properties file

C: Annotations

D: All of the above.


Correct Response: 4

Explanation: There are several different ways to configure a Hibernate application, including using an XML configuration file, a properties file, and annotations. Each method has its own advantages and disadvantages, and the choice of configuration method will depend on the specific needs of your application.





Q: What is Query Cache in Hibernate?


A: Query Cache is a mechanism used in Hibernate to cache the results of database queries in memory, improving performance.

B: Query Cache is a mechanism used in Hibernate to prevent changes from being made to the results of database queries.

C: Query Cache is a mechanism used in Hibernate to manually manage the results of database queries.


Correct Response: 1

Explanation: Query Cache is a mechanism used in Hibernate to cache the results of database queries in memory, improving performance. This allows Hibernate to return the cached results for a query, rather than executing the query again and retrieving the results from the database.





Q: What are the different types of Association mappings supported by Hibernate?


A: One-to-One

B: One-to-Many

C: Many-to-One

D: All of the above.


Correct Response: 4

Explanation: Hibernate supports several different types of Association mappings, including One-to-One, One-to-Many, and Many-to-One. These mappings allow you to define relationships between entities, such as a one-to-many relationship between a customer and their orders.





Q: What are the different types of Unidirectional Association mappings in Hibernate?


A: One-to-One

B: One-to-Many

C: Many-to-One

D: All of the above.


Correct Response: 2, 3

Explanation: In Hibernate, there are two types of Unidirectional Association mappings: One-to-Many and Many-to-One. In a unidirectional association, the relationship is only defined in one direction, meaning that changes made to the relationship from one side will not be reflected on the other side.





Q: What is Unit of Work design pattern?


A: Unit of Work is a design pattern used in Hibernate to manage the persistence of objects to the database.

B: Unit of Work is a design pattern used to manage the creation and destruction of objects in an application.

C: Unit of Work is a design pattern used to manage the execution of database queries.


Correct Response: 1

Explanation: Unit of Work is a design pattern used in Hibernate to manage the persistence of objects to the database. It provides a mechanism for tracking changes made to objects, and for persisting those changes to the database in a single transaction.





Q: In Hibernate, how can an object go in Detached state?


A: An object can go in the Detached state in Hibernate when it is closed or disconnected from the current session.

B: An object can go in the Detached state in Hibernate when it is associated with a different session.

C: An object can go in the Detached state in Hibernate when it is saved to the database.


Correct Response: 1

Explanation: An object can go in the Detached state in Hibernate when it is closed or disconnected from the current session. Once an object is detached, changes made to the object will not be saved to the database unless the object is reattached to a session.





Q: How will you order the results returned by a Criteria in Hibernate?


A: You can order the results returned by a Criteria in Hibernate by calling the addOrder() method of the Criteria object and passing in an Order object.

B: You can order the results returned by a Criteria in Hibernate by calling the setOrder() method of the Criteria object.

C: You can order the results returned by a Criteria in Hibernate by calling the sort() method of the Criteria object.


Correct Response: 1

Explanation: You can order the results returned by a Criteria in Hibernate by calling the addOrder() method of the Criteria object and passing in an Order object. This allows you to specify the sort order for the results, such as ascending or descending order based on a specific property of the objects being queried.





Q: How does Example criterion work in Hibernate?


A: The Example criterion in Hibernate is used to create a query based on an example object. The query will return all objects that match the properties of the example object.

B: The Example criterion in Hibernate is used to create a query based on a set of properties of an example object. The query will return all objects that match the specified properties.

C: The Example criterion in Hibernate is used to create a query based on a set of conditions. The query will return all objects that match the conditions.


Correct Response: 1

Explanation: The Example criterion in Hibernate is used to create a query based on an example object. The query will return all objects that match the properties of the example object. This provides a convenient way to query for objects with specific properties, without having to manually specify each property in the query.





Q: How does Transaction management work in Hibernate?


A: Transaction management in Hibernate works by using the transaction API provided by the underlying database management system.

B: Transaction management in Hibernate works by using the transaction API provided by the Hibernate framework.

C: Transaction management in Hibernate works by manually managing transactions in code.


Correct Response: 2

Explanation: Transaction management in Hibernate works by using the transaction API provided by the Hibernate framework. This allows you to define a transaction, perform database operations within the transaction, and either commit or rollback the transaction based on the outcome of the operations.





Q: How can we mark an entity/collection as immutable in Hibernate?


A: You can mark an entity/collection as immutable in Hibernate by using the @Immutable annotation.

B: You can mark an entity/collection as immutable in Hibernate by using the @Mutable annotation.

C: You can mark an entity/collection as immutable in Hibernate by using the @ReadOnly annotation.


Correct Response: 1

Explanation: You can mark an entity/collection as immutable in Hibernate by using the @Immutable annotation. This indicates to Hibernate that the entity/collection should not be updated, and can improve performance by allowing Hibernate to make certain optimizations.





Q: What are the different options to retrieve an object from database in Hibernate?


A: get() method

B: load() method

C: find() method

D: All of the above.


Correct Response: 4

Explanation: There are several different options to retrieve an object from the database in Hibernate, including the get() method, the load() method, and the find() method. Each method has its own advantages and disadvantages, and the choice of method will depend on the specific needs of your application.





Q: How can we auto-generate primary key in Hibernate?


A: You can auto-generate the primary key in Hibernate by using a database-generated key, such as an auto-incrementing column.

B: You can auto-generate the primary key in Hibernate by using a Hibernate-generated key, such as a UUID.

C: You can auto-generate the primary key in Hibernate by using a custom generator class.


Correct Response: 1, 2

Explanation: You can auto-generate the primary key in Hibernate by using a database-generated key, such as an auto-incrementing column, or a Hibernate-generated key, such as a UUID. This allows you to automatically generate unique keys for each object, without having to manually set the key in code.





Q: How will you re-attach an object in Detached state in Hibernate?


A: You can re-attach an object in Detached state in Hibernate by calling the update() method of the Session object, passing in the detached object.

B: You can re-attach an object in Detached state in Hibernate by calling the saveOrUpdate() method of the Session object, passing in the detached object.

C: You can re-attach an object in Detached state in Hibernate by calling the merge() method of the Session object, passing in the detached object.


Correct Response: 3

Explanation: You can re-attach an object in Detached state in Hibernate by calling the merge() method of the Session object, passing in the detached object. This allows you to persist changes made to the detached object back to the database.





Q: What is the first level of cache in Hibernate?


A: The first level of cache in Hibernate is the Session cache.

B: The first level of cache in Hibernate is the SessionFactory cache.

C: The first level of cache in Hibernate is the EntityManager cache.


Correct Response: 1

Explanation: The first level of cache in Hibernate is the Session cache. This cache is associated with a single Hibernate session and holds data that has been retrieved from the database.





Q: What are the different second level caches available in Hibernate?


A: EHCache

B: Hazelcast

C: Infinispan

D: All of the above.


Correct Response: 4

Explanation: There are several different second level caches available in Hibernate, including EHCache, Hazelcast, and Infinispan. Each cache has its own advantages and disadvantages, and the choice of cache will depend on the specific needs of your application.





Q: Which is the default transaction factory in Hibernate?


A: The default transaction factory in Hibernate is the JDBCTransactionFactory.

B: The default transaction factory in Hibernate is the JTATransactionFactory.

C: The default transaction factory in Hibernate is the JpaTransactionFactory.


Correct Response: 1

Explanation: The default transaction factory in Hibernate is the JDBCTransactionFactory. This transaction factory uses the JDBC API to manage transactions, and is appropriate for use with traditional relational databases.





Q: What are the options to disable second level cache in Hibernate?


A: Set the cache usage to “read-only”.

B: Set the cache usage to “nonstrict-read-write”.

C: Disable the cache at the configuration level.

D: All of the above.


Correct Response: 4

Explanation: There are several options to disable the second level cache in Hibernate, including setting the cache usage to “read-only”, setting the cache usage to “nonstrict-read-write”, and disabling the cache at the configuration level. The choice of option will depend on the specific needs of your application.





Q: What are the different fetching strategies in Hibernate?


A: Eager fetching

B: Lazy fetching

C: Batch fetching

D: All of the above.


Correct Response: 4

Explanation: There are several different fetching strategies in Hibernate, including eager fetching, lazy fetching, and batch fetching. Each fetching strategy has its own advantages and disadvantages, and the choice of strategy will depend on the specific needs of your application.





Q: What is the difference between Immediate fetching and Lazy collection fetching?


A: Immediate fetching retrieves the collection when the parent object is loaded, while lazy collection fetching retrieves the collection only when it is accessed.

B: Immediate fetching retrieves the collection only when it is accessed, while lazy collection fetching retrieves the collection when the parent object is loaded.

C: Immediate fetching and lazy collection fetching are the same thing.


Correct Response: 1

Explanation: Immediate fetching retrieves the collection when the parent object is loaded, while lazy collection fetching retrieves the collection only when it is accessed. This allows you to optimize performance by deferring the retrieval of collections until they are actually needed.





Q: What is ‘Extra lazy fetching’ in Hibernate?


A: Extra lazy fetching is a fetching strategy in Hibernate that retrieves collection elements one at a time, as they are accessed.

B: Extra lazy fetching is a fetching strategy in Hibernate that retrieves all collection elements at once.

C: Extra lazy fetching is a fetching strategy in Hibernate that retrieves only a portion of the collection elements at a time.


Correct Response: 1

Explanation: Extra lazy fetching is a fetching strategy in Hibernate that retrieves collection elements one at a time, as they are accessed. This provides the ultimate in flexibility and performance optimization, as you only retrieve the collection elements that are actually needed.





Q: How can we check is a collection is initialized or not under Lazy Initialization strategy?


A: You can check if a collection is initialized or not under Lazy Initialization strategy by calling the isInitialized() method of the Hibernate PersistentCollection interface.

B: You can check if a collection is initialized or not under Lazy Initialization strategy by calling the isLoaded() method of the Hibernate PersistentCollection interface.

C: You can check if a collection is initialized or not under Lazy Initialization strategy by calling the isEmpty() method of the Hibernate PersistentCollection interface.


Correct Response: 1

Explanation: You can check if a collection is initialized or not under Lazy Initialization strategy by calling the isInitialized() method of the Hibernate PersistentCollection interface. This allows you to determine if the collection has been loaded from the database, or if it is still in a lazy state.





Q: What are the different strategies for cache mapping in Hibernate?


A: Read-only

B: Read-write

C: Nonstrict-read-write

D: All of the above.


Correct Response: 4

Explanation: There are several different strategies for cache mapping in Hibernate, including read-only, read-write, and nonstrict-read-write. Each strategy has its own advantages and disadvantages, and the choice of strategy will depend on the specific needs of your application.





Q: What is the difference between a Set and a Bag in Hibernate?


A: A Set is a collection that does not allow duplicates and is ordered, while a Bag is a collection that allows duplicates and is unordered.

B: A Set is a collection that allows duplicates and is ordered, while a Bag is a collection that does not allow duplicates and is unordered.

C: A Set and a Bag are the same thing in Hibernate.


Correct Response: 1

Explanation: A Set is a collection that does not allow duplicates and is ordered, while a Bag is a collection that allows duplicates and is unordered. This allows you to choose the appropriate collection type based on the specific needs of your application.





Q: How can we monitor the performance of Hibernate in an application?


A: You can monitor the performance of Hibernate in an application by using performance profiling tools, such as JProfiler or YourKit.

B: You can monitor the performance of Hibernate in an application by using performance monitoring tools, such as JConsole or VisualVM.

C: You can monitor the performance of Hibernate in an application by logging the SQL statements generated by Hibernate.

D: All of the above.


Correct Response: 4

Explanation: You can monitor the performance of Hibernate in an application by using performance profiling tools, such as JProfiler or YourKit, performance monitoring tools, such as JConsole or VisualVM, or by logging the SQL statements generated by Hibernate. This allows you to identify and resolve performance bottlenecks in your Hibernate-based application.





Q: How can we check if an Object is in Persistent, Detached or Transient state in Hibernate?


A: You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the isConnected() method of the Session object.

B: You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the isDirty() method of the Session object.

C: You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the contains() method of the Session object, passing in the object.


Correct Response: 3

Explanation: You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the contains() method of the Session object, passing in the object. This method returns true if the object is in Persistent state, false if it is in Detached state, and throws an exception if it is in Transient state.





Q: What is ‘the inverse side of association’ in a mapping?


A: The inverse side of an association in a mapping refers to the side of the association that is not responsible for maintaining the relationship.

B: The inverse side of an association in a mapping refers to the side of the association that is responsible for maintaining the relationship.

C: The inverse side of an association in a mapping refers to the side of the association that is not part of the relationship.


Correct Response: 1

Explanation: The inverse side of an association in a mapping refers to the side of the association that is not responsible for maintaining the relationship. This allows you to specify which side of the association should be responsible for maintaining the relationship, which can help to reduce the risk of data inconsistencies and improve performance.





Q: What is ORM metadata?


A: ORM metadata refers to the data about the data that is stored in a relational database.

B: ORM metadata refers to the data about the mapping between Java objects and relational database tables that is used by an Object-Relational Mapping (ORM) framework like Hibernate.

C: ORM metadata refers to the data about the relational database itself.


Correct Response: 2

Explanation: ORM metadata refers to the data about the mapping between Java objects and relational database tables that is used by an Object-Relational Mapping (ORM) framework like Hibernate. This metadata includes information about the tables, columns, relationships, and other mapping details that are used to map Java objects to relational database tables.





Q: What is the difference between load() and get() method in Hibernate?


A: The load() method in Hibernate returns a proxy object that is not initialized until the data is actually accessed, while the get() method immediately retrieves the data from the database.

B: The load() method in Hibernate immediately retrieves the data from the database, while the get() method returns a proxy object that is not initialized until the data is actually accessed.

C: The load() and get() methods are the same thing in Hibernate.


Correct Response: 1

Explanation: The load() method in Hibernate returns a proxy object that is not initialized until the data is actually accessed, while the get() method immediately retrieves the data from the database. This allows you to choose the appropriate method based on the specific needs of your application.





Q: When should we use get() method or load() method in Hibernate?


A: You should use the get() method in Hibernate when you need to retrieve data from the database immediately, while you should use the load() method when you are not sure if you need the data, or if you want to delay the retrieval of the data until it is actually needed.

B: You should use the get() method in Hibernate when you are not sure if you need the data, or if you want to delay the retrieval of the data until it is actually needed, while you should use the load() method when you need to retrieve data from the database immediately.

C: Both the get() method and the load() method are used in the same way in Hibernate.


Correct Response: 1

Explanation: You should use the get() method in Hibernate when you need to retrieve data from the database immediately, while you should use the load() method when you are not sure if you need the data, or if you want to delay the retrieval of the data until it is actually needed.





Q: What is a derived property in Hibernate?


A: A derived property in Hibernate is a property that is calculated based on the values of other properties, rather than being stored in the database.

B: A derived property in Hibernate is a property that is stored in the database, but is calculated based on the values of other properties when it is retrieved.

C: A derived property in Hibernate is a property that is not part of the mapping between Java objects and relational database tables.


Correct Response: 1

Explanation: A derived property in Hibernate is a property that is calculated based on the values of other properties, rather than being stored in the database. This allows you to calculate the value of a property on the fly, without having to store it in the database.





Q: How can we use Named Query in Hibernate?


A: We can use Named Query in Hibernate by defining a named query in the Hibernate mapping file, and then calling the createNamedQuery() method of the Session object, passing in the name of the query.

B: We can use Named Query in Hibernate by defining a named query in the Hibernate mapping file, and then calling the createSQLQuery() method of the Session object, passing in the name of the query.

C: We can use Named Query in Hibernate by calling the createQuery() method of the Session object, passing in the name of the query.


Correct Response: 1

Explanation: We can use Named Query in Hibernate by defining a named query in the Hibernate mapping file, and then calling the createNamedQuery() method of the Session object, passing in the name of the query. Named queries are a way to pre-define a query in Hibernate, so that you can reuse the same query in multiple places in your application.





Q: What are the two locking strategies in Hibernate?


A: The two locking strategies in Hibernate are optimistic locking and pessimistic locking.

B: The two locking strategies in Hibernate are pessimistic locking and pessimistic eager locking.

C: The two locking strategies in Hibernate are optimistic locking and pessimistic eager locking.


Correct Response: 1

Explanation: The two locking strategies in Hibernate are optimistic locking and pessimistic locking. Optimistic locking is a strategy where multiple transactions can access the same data at the same time, and the first transaction to commit wins, while pessimistic locking is a strategy where a transaction locks the data it is accessing, preventing other transactions from accessing the same data until the first transaction is finished.





Q: What is the use of version number in Hibernate?


A: The version number in Hibernate is used to enforce optimistic locking, by checking that the version number of an object has not changed since it was last retrieved from the database.

B: The version number in Hibernate is used to enforce pessimistic locking, by checking that the version number of an object has not changed since it was last retrieved from the database.

C: The version number in Hibernate is used to keep track of the number of times an object has been updated in the database.


Correct Response: 1

Explanation: The version number in Hibernate is used to enforce optimistic locking, by checking that the version number of an object has not changed since it was last retrieved from the database. If the version number has changed, it means that another transaction has updated the data in the meantime, and the current transaction must be rolled back.





Q: What is the use of session.lock() method in Hibernate?


A: The session.lock() method in Hibernate is used to lock an object, preventing other transactions from accessing the same data until the current transaction is finished.

B: The session.lock() method in Hibernate is used to refresh an object, retrieving the latest data from the database.

C: The session.lock() method in Hibernate is used to persist an object, saving it to the database.


Correct Response: 1

Explanation: The session.lock() method in Hibernate is used to lock an object, preventing other transactions from accessing the same data until the current transaction is finished. This method is useful when you need to enforce pessimistic locking in your application.





Q: What inheritance mapping strategies are supported by Hibernate?


A: Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per subclass, and table per concrete class.

B: Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per superclass, and table per abstract class.

C: Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per interface, and table per implementation.


Correct Response: 1

Explanation: Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per subclass, and table per concrete class. These strategies determine how the data for a class hierarchy is stored in the relational database, and each strategy has its own advantages and disadvantages.





Q: What is the difference between session.persist() and session.save() methods in Hibernate?


A: The difference between session.persist() and session.save() methods in Hibernate is that the persist() method adds an object to the persistence context, but does not immediately save it to the database, while the save() method immediately saves the object to the database.

B: The difference between session.persist() and session.save() methods in Hibernate is that the persist() method immediately saves the object to the database, while the save() method adds an object to the persistence context, but does not immediately save it to the database.

C: The session.persist() and session.save() methods are the same thing in Hibernate.


Correct Response: 1

Explanation: The difference between session.persist() and session.save() methods in Hibernate is that the persist() method adds an object to the persistence context, but does not immediately save it to the database, while the save() method immediately saves the object to the database. This allows you to control the timing of when an object is saved to the database, depending on the needs of your application.





Q: What is the difference between session.update() and session.merge() methods in Hibernate?


A: The difference between session.update() and session.merge() methods in Hibernate is that the update() method updates an object that is already in the persistence context, while the merge() method updates an object that is not in the persistence context.

B: The difference between session.update() and session.merge() methods in Hibernate is that the update() method updates an object that is not in the persistence context, while the merge() method updates an object that is already in the persistence context.

C: The session.update() and session.merge() methods are the same thing in Hibernate.


Correct Response: 1

Explanation: The difference between session.update() and session.merge() methods in Hibernate is that the update() method updates an object that is already in the persistence context, while the merge() method updates an object that is not in the persistence context. The merge() method first retrieves a copy of the object from the database, and then updates the copy with the changes from the detached object.





Q: How can we perform batch processing in Hibernate?


A: We can perform batch processing in Hibernate by enabling the Hibernate batch processing feature, and then executing multiple updates or inserts in a single transaction.

B: We can perform batch processing in Hibernate by using the session.flush() method, which flushes all pending updates and inserts to the database.

C: We can perform batch processing in Hibernate by using the session.clear() method, which clears the persistence context, forcing Hibernate to execute all pending updates and inserts.


Correct Response: 1

Explanation: We can perform batch processing in Hibernate by enabling the Hibernate batch processing feature, and then executing multiple updates or inserts in a single transaction. This allows Hibernate to batch multiple updates or inserts into a single database call, improving the performance of your application.





Q: What is the use of session.refresh() method in Hibernate?


A: The session.refresh() method in Hibernate is used to refresh an object, retrieving the latest data from the database.

B: The session.refresh() method in Hibernate is used to lock an object, preventing other transactions from accessing the same data until the current transaction is finished.

C: The session.refresh() method in Hibernate is used to persist an object, saving it to the database.


Correct Response: 1

Explanation: The session.refresh() method in Hibernate is used to refresh an object, retrieving the latest data from the database. This method updates the values of the object with the latest data from the database, discarding any changes that have been made to the object since it was last retrieved from the database.





Q: What is the use of session.evict() method in Hibernate?


A: The session.evict() method in Hibernate is used to remove an object from the persistence context, making it eligible for garbage collection.

B: The session.evict() method in Hibernate is used to refresh an object, retrieving the latest data from the database.

C: The session.evict() method in Hibernate is used to persist an object, saving it to the database.


Correct Response: 1

Explanation: The session.evict() method in Hibernate is used to remove an object from the persistence context, making it eligible for garbage collection. This method is useful when you need to remove an object from the persistence context, but do not want to delete it from the database.





Q: What is the difference between session.clear() and session.flush() methods in Hibernate?


A: The difference between session.clear() and session.flush() methods in Hibernate is that the clear() method clears the persistence context, discarding all changes to objects, while the flush() method flushes all pending updates and inserts to the database.

B: The difference between session.clear() and session.flush() methods in Hibernate is that the clear() method flushes all pending updates and inserts to the database, while the flush() method clears the persistence context, discarding all changes to objects.

C: The session.clear() and session.flush() methods are the same thing in Hibernate.


Correct Response: 1

Explanation: The difference between session.clear() and session.flush() methods in Hibernate is that the clear() method clears the persistence context, discarding all changes to objects, while the flush() method flushes all pending updates and inserts to the database. The clear() method is useful when you need to clear the persistence context, for example, to free up memory, while the flush() method is useful when you need to execute all pending database operations immediately.





Q: What are the different types of transaction propagation in Hibernate?


A: Hibernate supports the following transaction propagation types: required, requires new, nested, mandatory, and not supported.

B: Hibernate supports the following transaction propagation types: required, requires new, nested, mandatory, and supports.

C: Hibernate supports the following transaction propagation types: required, requires old, nested, mandatory, and not supported.


Correct Response: 1

Explanation: Hibernate supports the following transaction propagation types: required, requires new, nested, mandatory, and not supported. These transaction propagation types determine how transactions are propagated from one method to another, and each type has its own behavior with regards to transactions.





Q: What is the difference between session.flush() and session.clear() methods in Hibernate?


A: The difference between session.flush() and session.clear() methods in Hibernate is that the flush() method flushes all pending updates and inserts to the database, while the clear() method clears the persistence context, discarding all changes to objects.

B: The difference between session.flush() and session.clear() methods in Hibernate is that the flush() method clears the persistence context, discarding all changes to objects, while the clear() method flushes all pending updates and inserts to the database.

C: The session.flush() and session.clear() methods are the same thing in Hibernate.


Correct Response: 1

Explanation: The difference between session.flush() and session.clear() methods in Hibernate is that the flush() method flushes all pending updates and inserts to the database, while the clear() method clears the persistence context, discarding all changes to objects. The flush() method is useful when you need to execute all pending database operations immediately, while the clear() method is useful when you need to clear the persistence context, for example, to free up memory.





Q: What is the use of session.replicate() method in Hibernate?


A: The session.replicate() method in Hibernate is used to replicate an object from one database to another, making a copy of the object in the second database.

B: The session.replicate() method in Hibernate is used to persist an object, saving it to the database.

C: The session.replicate() method in Hibernate is used to remove an object from the persistence context, making it eligible for garbage collection.


Correct Response: 1

Explanation: The session.replicate() method in Hibernate is used to replicate an object from one database to another, making a copy of the object in the second database. This method is useful when you need to replicate data between databases, for example, for backup or disaster recovery purposes.





Q: What is Maven?


A: Maven is a build automation tool used primarily for Java projects.

B: Maven is a version control system used primarily for Java projects.

C: Maven is a programming language used primarily for Java projects.


Correct Response: 1

Explanation: Maven is a build automation tool used primarily for Java projects. It provides a comprehensive and consistent approach to building and managing projects, making it easier to build, manage, and deploy software.





Q: What are the main features of Maven?


A: The main features of Maven include project management, build automation, dependency management, and documentation.

B: The main features of Maven include version control, project management, and testing.

C: The main features of Maven include project management, build automation, and deployment.


Correct Response: 1, 2

Explanation: The main features of Maven include project management, build automation, dependency management, and documentation. Maven provides a comprehensive and consistent approach to building and managing projects, helping to automate tasks such as building, testing, and deploying software.





Q: What areas of a Project can you manage by using Maven?


A: You can manage the following areas of a project using Maven: builds, dependencies, documentation, and testing.

B: You can manage the following areas of a project using Maven: builds, dependencies, and deployment.

C: You can manage the following areas of a project using Maven: version control, builds, and testing.


Correct Response: 1, 2

Explanation: You can manage the following areas of a project using Maven: builds, dependencies, documentation, and testing. Maven provides a comprehensive and consistent approach to building and managing projects, helping to automate tasks such as building, testing, and deploying software.





Q: What are the main advantages of Maven?


A: The main advantages of Maven include consistency, comprehensiveness, and automation of builds and project management tasks.

B: The main advantages of Maven include speed, simplicity, and scalability of builds and project management tasks.

C: The main advantages of Maven include efficiency, ease of use, and flexibility of builds and project management tasks.


Correct Response: 1, 2

Explanation: The main advantages of Maven include consistency, comprehensiveness, and automation of builds and project management tasks. Maven provides a comprehensive and consistent approach to building and managing projects, helping to automate tasks such as building, testing, and deploying software.





Q: Why do we say “Maven uses convention over configuration”?


A: We say “Maven uses convention over configuration” because Maven relies on a set of standard conventions and project structures, reducing the need for explicit configuration and making it easier to get started with a new project.

B: We say “Maven uses convention over configuration” because Maven provides a comprehensive set of configuration options, allowing for maximum customization and flexibility.

C: We say “Maven uses convention over configuration” because Maven provides a simple and straightforward build process, with minimal configuration required.


Correct Response: 1

Explanation: We say “Maven uses convention over configuration” because Maven relies on a set of standard conventions and project structures, reducing the need for explicit configuration and making it easier to get started with a new project. This approach allows developers to focus on writing code, rather than worrying about build and project configuration.





Q: What are the responsibilities of a Build tool like Maven?


A: The responsibilities of a build tool like Maven include project management, build automation, dependency management, and documentation.

B: The responsibilities of a build tool like Maven include version control, project management, and testing.

C: The responsibilities of a build tool like Maven include project management, build automation, and deployment.


Correct Response: 1, 2

Explanation: The responsibilities of a build tool like Maven include project management, build automation, dependency management, and documentation. Maven provides a comprehensive and consistent approach to building and managing projects, helping to automate tasks such as building, testing, and deploying software.





Q: What are the differences between Ant and Maven?


A: The differences between Ant and Maven include convention over configuration, comprehensiveness, and automation of builds and project management tasks for Maven, versus a more flexible and customizable build process for Ant.

B: The differences between Ant and Maven include simplicity, speed, and scalability of builds and project management tasks for Maven, versus a more complex and time-consuming build process for Ant.

C: The differences between Ant and Maven include efficiency, ease of use, and flexibility of builds and project management tasks for Maven, versus a less flexible and less efficient build process for Ant.


Correct Response: 1, 2

Explanation: The differences between Ant and Maven include convention over configuration, comprehensiveness, and automation of builds and project management tasks for Maven, versus a more flexible and customizable build process for Ant. Maven provides a comprehensive and consistent approach to building and managing projects, while Ant provides a more flexible and customizable approach, allowing for maximum control over the build process.





Q: What is MOJO in Maven?


A: MOJO in Maven stands for Maven Ordered Java Objects.

B: MOJO in Maven stands for Maven Object-Oriented Java.

C: MOJO in Maven stands for Maven Plugin Java Objects.


Correct Response: 3

Explanation: MOJO in Maven stands for Maven Plugin Java Objects. MOJOs are the executable components of Maven plugins, responsible for performing specific tasks during the build process.





Q: What is a Repository in Maven?


A: A repository in Maven is a storage location for artifacts, such as libraries and dependencies, used in a Maven project.

B: A repository in Maven is a version control system used for managing source code in a Maven project.

C: A repository in Maven is a programming language used for writing code in a Maven project.


Correct Response: 1

Explanation: A repository in Maven is a storage location for artifacts, such as libraries and dependencies, used in a Maven project. Maven repositories provide a centralized location for storing and retrieving project artifacts, making it easier to manage dependencies and ensure consistent builds.





Q: What are the different types of repositories in Maven?


A: The different types of repositories in Maven include local, central, remote, and snapshot repositories.

B: The different types of repositories in Maven include local, central, and remote repositories.

C: The different types of repositories in Maven include local, central, and snapshot repositories.


Correct Response: 1, 2

Explanation: The different types of repositories in Maven include local, central, remote, and snapshot repositories. Each type of repository serves a different purpose, with local and central repositories being the most commonly used.





Q: What is a local repository in Maven?


A: A local repository in Maven is a repository stored on the developer's local machine, used to store artifacts that have been downloaded from remote repositories.

B: A local repository in Maven is a repository stored on a remote server, used to store artifacts that are shared among multiple developers.

C: A local repository in Maven is a repository stored in the cloud, used to store artifacts that can be accessed from anywhere.


Correct Response: 1

Explanation: A local repository in Maven is a repository stored on the developer's local machine, used to store artifacts that have been downloaded from remote repositories. The local repository serves as a cache, reducing the need to repeatedly download artifacts from remote repositories, and improving build performance.





Q: What is a central repository in Maven?


A: A central repository in Maven is a repository stored on the developer's local machine, used to store artifacts that have been downloaded from remote repositories.

B: A central repository in Maven is a repository stored on a remote server, used to store artifacts that are shared among multiple developers.

C: A central repository in Maven is a repository stored in the cloud, used to store artifacts that can be accessed from anywhere.


Correct Response: 2

Explanation: A central repository in Maven is a repository stored on a remote server, used to store artifacts that are shared among multiple developers. The central repository serves as a central location for storing and retrieving common artifacts, making it easier to manage dependencies and ensure consistent builds.





Q: What is a Remote repository in Maven?


A: A remote repository in Maven is a repository stored on a remote server, used to store artifacts that are not available in the central repository.

B: A remote repository in Maven is a repository stored on the developer's local machine, used to store artifacts that have been downloaded from central repository.

C: A remote repository in Maven is a repository stored in the cloud, used to store artifacts that can be accessed from anywhere.


Correct Response: 1

Explanation: A remote repository in Maven is a repository stored on a remote server, used to store artifacts that are not available in the central repository. Remote repositories can be used to store custom artifacts or to access artifacts that are not available in the central repository.





Q: Why we should not store jars in CVS or any other version control system instead of Maven repository?


A: Jars should not be stored in CVS or other version control systems because these systems are not designed for storing binary files and can cause performance issues.

B: Jars should not be stored in CVS or other version control systems because these systems are not secure enough to store sensitive information.

C: Jars should not be stored in CVS or other version control systems because they are not easily accessible to other developers.


Correct Response: 1

Explanation: Jars should not be stored in CVS or other version control systems because these systems are not designed for storing binary files and can cause performance issues. Storing jars in a Maven repository allows for better management of dependencies and ensures consistent builds.





Q: Can anyone upload JARS or artifacts to Central Repository?


A: No, only authorized users can upload JARS or artifacts to the central repository.

B: Yes, anyone can upload JARS or artifacts to the central repository.

C: No, only authorized developers can upload JARS or artifacts to the central repository.


Correct Response: 1

Explanation: No, only authorized users can upload JARS or artifacts to the central repository. The central repository is a shared resource, and access is controlled to ensure that only high-quality, reliable artifacts are available for use by other developers.





Q: What is a POM?


A: POM is an acronym for Project Object Model, which is an XML file used by Maven to define the project's build and dependencies.

B: POM is an acronym for Project Order Model, which is an XML file used by Maven to define the order in which tasks should be executed in a project.

C: POM is an acronym for Project Output Model, which is an XML file used by Maven to define the output generated by a project.


Correct Response: 1

Explanation: POM is an acronym for Project Object Model, which is an XML file used by Maven to define the project's build and dependencies. The POM contains information such as the project's name, version, and dependencies, and is used by Maven to build the project.





Q: What is Super POM?


A: The Super POM is a default Maven POM that all projects inherit from, unless explicitly overridden.

B: The Super POM is a special type of POM that can only be used in certain circumstances.

C: The Super POM is a Maven plugin that provides additional functionality to the build process.


Correct Response: 1

Explanation: The Super POM is a default Maven POM that all projects inherit from, unless explicitly overridden. The Super POM contains a set of default values that Maven uses when building a project, such as the default build directory and the default set of plugins.





Q: What are the main required elements in POM file?


A: The main required elements in a POM file are the project's group ID, artifact ID, and version.

B: The main required elements in a POM file are the project's name, description, and dependencies.

C: The main required elements in a POM file are the project's build system and target platform.


Correct Response: 1

Explanation: The main required elements in a POM file are the project's group ID, artifact ID, and version. These elements uniquely identify the project and are used by Maven to manage dependencies and resolve conflicts.





Q: What are the phases in Build lifecycle in Maven?


A: The phases in the Maven build lifecycle are validate, compile, test, package, install, and deploy.

B: The phases in the Maven build lifecycle are validate, compile, test, and run.

C: The phases in the Maven build lifecycle are validate, build, test, and deploy.


Correct Response: 1

Explanation: The phases in the Maven build lifecycle are validate, compile, test, package, install, and deploy. Maven executes these phases in a specific order to build and deploy a project, with each phase building upon the output of the previous phase.





Q: What command will you use to package your Maven project?


A: The command to package a Maven project is "mvn package".

B: The command to package a Maven project is "mvn build".

C: The command to package a Maven project is "mvn compile".


Correct Response: 1

Explanation: The command to package a Maven project is "mvn package". This command executes the appropriate phases of the Maven build lifecycle to build and package the project into its final distribution format, such as a JAR or WAR file.





Q: What is the format of fully qualified artifact name of a Maven project?


A: The fully qualified artifact name of a Maven project is in the format groupId:artifactId:version.

B: The fully qualified artifact name of a Maven project is in the format name:version:type.

C: The fully qualified artifact name of a Maven project is in the format artifactId:groupId:version.


Correct Response: 1

Explanation: The fully qualified artifact name of a Maven project is in the format groupId:artifactId:version. This name uniquely identifies the project and is used by Maven to manage dependencies and resolve conflicts.





Q: What is an Archetype in Maven?


A: An archetype in Maven is a template project that can be used as a starting point for creating new projects.

B: An archetype in Maven is a plugin that provides additional functionality to the build process.

C: An archetype in Maven is a special type of POM that can only be used in certain circumstances.


Correct Response: 1

Explanation: An archetype in Maven is a template project that can be used as a starting point for creating new projects. Archetypes provide a convenient way to create projects with a common structure and set of dependencies, without having to manually configure each project.





Q: What is the command in Maven to generate an Archetype?


A: The command to generate an archetype in Maven is "mvn archetype:generate".

B: The command to generate an archetype in Maven is "mvn generate:archetype".

C: The command to generate an archetype in Maven is "mvn create:archetype".


Correct Response: 1

Explanation: The command to generate an archetype in Maven is "mvn archetype:generate". This command creates a new project from an existing archetype, using the specified options to customize the project structure and dependencies.





Q: What are the three main build lifecycles of Maven?


A: The three main build lifecycles of Maven are default, clean, and site.

B: The three main build lifecycles of Maven are default, integration-test, and deploy.

C: The three main build lifecycles of Maven are validate, compile, and test.


Correct Response: 1

Explanation: The three main build lifecycles of Maven are default, clean, and site. The default lifecycle handles the main build and deployment phases of a project, while the clean lifecycle is used to clean up build artifacts, and the site lifecycle is used to generate project documentation.





Q: What are the main uses of a Maven plugin?


A: The main uses of a Maven plugin are to provide additional functionality to the build process, such as compiling source code, generating documentation, or deploying applications.

B: The main uses of a Maven plugin are to manage project dependencies and resolve conflicts.

C: The main uses of a Maven plugin are to create and manage archetypes.


Correct Response: 1

Explanation: The main uses of a Maven plugin are to provide additional functionality to the build process, such as compiling source code, generating documentation, or deploying applications. Maven plugins are executed as part of the build lifecycle and can be used to perform a wide range of tasks, making it easier to automate the build and deployment process.





Q: How will you find the version of a plugin being used?


A: To find the version of a plugin being used, you can run the command "mvn help:describe -DgroupId=<groupId> -DartifactId=<artifactId> -Dversion=<version>".

B: To find the version of a plugin being used, you can run the command "mvn plugin:version -DgroupId=<groupId> -DartifactId=<artifactId>".

C: To find the version of a plugin being used, you can run the command "mvn plugin:describe -DgroupId=<groupId> -DartifactId=<artifactId>".


Correct Response: 1

Explanation: To find the version of a plugin being used, you can run the command "mvn help:describe -DgroupId=<groupId> -DartifactId=<artifactId> -Dversion=<version>". This command displays information about the specified plugin, including its version, goals, and other details.





Q: What are the different types of profile in Maven? Where will you define these profiles?


A: The different types of profiles in Maven are activeByDefault, inactiveByDefault, and activeByOS. Profiles are defined in the POM file or in the settings.xml file.

B: The different types of profiles in Maven are activeByDefault, inactiveByDefault, and activeByEnvironment. Profiles are defined in the POM file or in the profiles.xml file.

C: The different types of profiles in Maven are activeByDefault, inactiveByDefault, and activeByProfile. Profiles are defined in the POM file or in the profiles.xml file.


Correct Response: 1

Explanation: The different types of profiles in Maven are activeByDefault, inactiveByDefault, and activeByProfile. Profiles are defined in the POM file or in the settings.xml file. Profiles provide a way to configure a Maven build based on different conditions, such as the environment, platform, or project type.





Q: What are the different setting files in Maven? Where will you find these files?


A: The different setting files in Maven are settings.xml and toolchains.xml. These files are located in the ${user.home}/.m2 directory.

B: The different setting files in Maven are settings.xml and profiles.xml. These files are located in the ${maven.home}/conf directory.

C: The different setting files in Maven are settings.xml and mavenrc. These files are located in the ${maven.home}/bin directory.


Correct Response: 1

Explanation: The different setting files in Maven are settings.xml and toolchains.xml. These files are located in the ${user.home}/.m2 directory. The settings.xml file contains global configuration settings for Maven, such as the location of local and remote repositories, while the toolchains.xml file is used to configure tools used by Maven plugins.





Q: What are the main elements we can find in settings.xml?


A: The main elements that can be found in the settings.xml file are localRepository, activeProfiles, profiles, and mirrors.

B: The main elements that can be found in the settings.xml file are localRepository, activeProfiles, plugins, and mirrors.

C: The main elements that can be found in the settings.xml file are localRepository, activeProfiles, profiles, and repositories.


Correct Response: 1

Explanation: The main elements that can be found in the settings.xml file are localRepository, activeProfiles, profiles, and mirrors. The localRepository element specifies the location of the local repository, while the activeProfiles element lists the profiles that are active by default. The profiles element is used to define profiles, and the mirrors element is used to define remote repository mirrors.





Q: How will you check the version of Maven in your system?


A: To check the version of Maven in your system, you can run the command "mvn -version".

B: To check the version of Maven in your system, you can run the command "mvn --version".

C: To check the version of Maven in your system, you can run the command "mvn version".


Correct Response: 1

Explanation: To check the version of Maven in your system, you can run the command "mvn -version". This command displays information about the installed version of Maven, as well as the Java version and other details.





Q: How will you verify if Maven is installed on Windows?


A: To verify if Maven is installed on Windows, you can run the command "mvn --version" from the command prompt.

B: To verify if Maven is installed on Windows, you can run the command "mvn -version" from the command prompt.

C: To verify if Maven is installed on Windows, you can run the command "mvn version" from the command prompt.


Correct Response: 1

Explanation: To verify if Maven is installed on Windows, you can run the command "mvn --version" from the command prompt. If Maven is installed, this command displays information about the installed version of Maven, as well as the Java version and other details.





Q: What is a Maven artifact?


A: A Maven artifact is a file that is generated by a project build and is stored in a repository for distribution and use by other projects.

B: A Maven artifact is a file that is stored in a repository for distribution and use by other projects, but it is not generated by a project build.

C: A Maven artifact is a file that is generated by a project build but is not stored in a repository for distribution and use by other projects.


Correct Response: 1

Explanation: A Maven artifact is a file that is generated by a project build and is stored in a repository for distribution and use by other projects. The artifact can be a JAR, WAR, EAR, or other type of file, depending on the nature of the project.





Q: What are the different dependency scopes in Maven?


A: The different dependency scopes in Maven are compile, provided, runtime, test, and system.

B: The different dependency scopes in Maven are compile, provided, runtime, and system.

C: The different dependency scopes in Maven are compile, provided, runtime, test, and integration.

D: The different dependency scopes in Maven are compile, provided, runtime, and development.


Correct Response: 1

Explanation: The different dependency scopes in Maven are compile, provided, runtime, test, and system. The compile scope indicates that the dependency is required for compilation and runtime, the provided scope indicates that the dependency is provided by the runtime environment, the runtime scope indicates that the dependency is required only at runtime, the test scope indicates that the dependency is required only for testing, and the system scope indicates that the dependency is provided by the system.





Q: How can we exclude a dependency in Maven?


A: We can exclude a dependency in Maven by adding an exclusion element to the dependency declaration in the POM file.

B: We can exclude a dependency in Maven by removing the dependency declaration from the POM file.

C: We can exclude a dependency in Maven by changing the scope of the dependency to provided.


Correct Response: 1

Explanation: We can exclude a dependency in Maven by adding an exclusion element to the dependency declaration in the POM file. The exclusion element specifies the groupId and artifactId of the dependency to be excluded.





Q: How Maven searches for JAR corresponding to a dependency?


A: Maven searches for the JAR corresponding to a dependency in the local repository, the central repository, and remote repositories in that order.

B: Maven searches for the JAR corresponding to a dependency in the remote repositories, the central repository, and local repository in that order.

C: Maven searches for the JAR corresponding to a dependency in the central repository and local repository only.

D: Maven searches for the JAR corresponding to a dependency in the local repository only.


Correct Response: 1

Explanation: Maven searches for the JAR corresponding to a dependency in the local repository, the central repository, and remote repositories in that order. If the JAR is not found in the local repository, Maven will check the central repository, and if it is still not found, it will check the remote repositories. If the JAR is found, Maven will download it to the local repository for future use.





Q: What is a transitive dependency in Maven?


A: A transitive dependency in Maven is a dependency that is automatically included in a project when another dependency is added to the project.

B: A transitive dependency in Maven is a dependency that must be explicitly added to a project.

C: A transitive dependency in Maven is a dependency that is automatically excluded in a project when another dependency is added to the project.


Correct Response: 1

Explanation: A transitive dependency in Maven is a dependency that is automatically included in a project when another dependency is added to the project. For example, if a project depends on library A, which in turn depends on library B, then library B is considered a transitive dependency of the project.





Q: What are Excluded dependencies in Maven?


A: Excluded dependencies in Maven are dependencies that are excluded from a project and are not included in the final build.

B: Excluded dependencies in Maven are dependencies that are required for a project and must be included in the final build.

C: Excluded dependencies in Maven are dependencies that are optional for a project and may or may not be included in the final build.


Correct Response: 1

Explanation: Excluded dependencies in Maven are dependencies that are excluded from a project and are not included in the final build. Excluded dependencies can be specified in the POM file by using the exclusion element in the dependency declaration.





Q: What are Optional dependencies in Maven?


A: Optional dependencies in Maven are dependencies that are optional for a project and may or may not be included in the final build.

B: Optional dependencies in Maven are dependencies that are required for a project and must be included in the final build.

C: Optional dependencies in Maven are dependencies that are excluded from a project and are not included in the final build.


Correct Response: 1

Explanation: Optional dependencies in Maven are dependencies that are optional for a project and may or may not be included in the final build. Optional dependencies can be specified in the POM file by using the optional element in the dependency declaration.





Q: Where will you find the class files after compiling a Maven project successfully?


A: The class files will be found in the target/classes directory of a Maven project after compiling it successfully.

B: The class files will be found in the src/main/java directory of a Maven project after compiling it successfully.

C: The class files will be found in the target directory of a Maven project after compiling it successfully.

D: The class files will be found in the src directory of a Maven project after compiling it successfully.


Correct Response: 1

Explanation: The class files will be found in the target/classes directory of a Maven project after compiling it successfully. The compiled classes are stored in this directory, and it is the default location for compiled classes in a Maven project.





Q: Where will you find the class files after compiling a Maven project successfully?


A: In the target directory.

B: In the src/main/java directory.

C: In the src/test/java directory.


Correct Response: 1

Explanation: After a Maven project is successfully compiled, the class files can be found in the target directory. This directory is generated automatically by Maven and contains the compiled output of the project.





Q: What are the default locations for source, test and build directories in Maven?


A: src/main/java for source

B: src/main/resources for source

C: src/test/java for test

D: target for build


Correct Response: 1, 3, 4

Explanation: The default locations for source, test and build directories in Maven are src/main/java for source, src/test/java for test, and target for build. The src/main/java directory contains the main source code for the project, while src/test/java contains the test code. The target directory contains the compiled output of the project.





Q: What is the result of jar:jar goal in Maven?


A: Compiles the project and creates a JAR file.

B: Runs the project and creates a JAR file.

C: Compiles the project and creates a WAR file.


Correct Response: 1

Explanation: The jar:jar goal in Maven is used to compile the project and create a JAR (Java Archive) file. A JAR file is a compressed archive file that contains the compiled output of a Java project, as well as any resources and dependencies required to run the application.





Q: How can we get the debug or error messages from the execution of Maven?


A: By using the -X option.

B: By using the -V option.

C: By using the -D option.


Correct Response: 1

Explanation: To get debug or error messages from the execution of Maven, we can use the -X option. This option enables the display of debug output, which can be useful for troubleshooting issues with Maven builds.





Q: What is the difference between a Release version and SNAPSHOT version in Maven?


A: Release version is a final version of a project, while SNAPSHOT version is a development version of a project.

B: SNAPSHOT version is a final version of a project, while Release version is a development version of a project.

C: Both Release version and SNAPSHOT version are the same.


Correct Response: 1

Explanation: In Maven, a Release version is a final version of a project that is considered stable and ready for production use, while a SNAPSHOT version is a development version of a project that is updated frequently and considered to be in a state of flux. SNAPSHOT versions are used during development to track the progress of a project.





Q: How will you run test classes in Maven?


A: By using the mvn test command.

B: By using the mvn compile command.

C: By using the mvn install command.


Correct Response: 1

Explanation: To run test classes in Maven, we can use the mvn test command. This command compiles the test classes and runs them, allowing us to verify that the code is working as expected.





Q: Sometimes Maven compiles the test classes but doesn't run them? What could be the reason for it?


A: The test classes have been marked as skipped.

B: The test classes have syntax errors.

C: The test classes are not in the correct location.


Correct Response: 1

Explanation: If Maven compiles the test classes but doesn't run them, it could be because the test classes have been marked as skipped. This can be done using the skipTests or testSkip properties in the Maven configuration, or by using the -Dmaven.test.skip=true option when running the build.





Q: How can we skip the running of tests in Maven?


A: By using the -Dmaven.test.skip=true option.

B: By using the -DskipTests option.

C: By using the -DtestSkip option.


Correct Response: 1

Explanation: To skip the running of tests in Maven, we can use the -Dmaven.test.skip=true option when running the build. This tells Maven to skip the execution of the test phase, which can be useful when we want to build the project quickly without running the tests.





Q: Can we create our own directory structure for a project in Maven?


A: Yes, we can create our own directory structure for a project in Maven.

B: No, we cannot create our own directory structure for a project in Maven.

C: It depends on the project requirements.


Correct Response: 1

Explanation: Yes, we can create our own directory structure for a project in Maven. Maven provides a standard directory structure, but it can be customized to meet the needs of a specific project.





Q: What are the differences between Gradle and Maven?


A: Gradle is more flexible and has a more modern build configuration, while Maven has a strict build configuration and is less flexible.

B: Maven is more flexible and has a more modern build configuration, while Gradle has a strict build configuration and is less flexible.

C: Both Gradle and Maven have the same build configuration.


Correct Response: 1

Explanation: Gradle and Maven are both build automation tools, but there are some differences between them. Gradle is more flexible and has a more modern build configuration, with a focus on build-by-convention and a ability to use plugins written in a variety of programming languages. Maven, on the other hand, has a strict build configuration and is less flexible, with a focus on build-by-convention and a central repository for storing libraries and dependencies.





Q: What is the difference between Inheritance and Multi-module in Maven?


A: Inheritance is used to share common configuration across multiple projects, while Multi-module is used to manage multiple projects within a single build.

B: Multi-module is used to share common configuration across multiple projects, while Inheritance is used to manage multiple projects within a single build.

C: Both Inheritance and Multi-module are the same.


Correct Response: 2

Explanation: In Maven, Inheritance is used to share common configuration across multiple projects, while Multi-module is used to manage multiple projects within a single build. Multi-module allows us to build, test, and package multiple projects as a single unit, while Inheritance allows us to define a common parent POM for multiple projects, reducing duplication and making it easier to manage the configuration of multiple projects.





Q: What is Build portability in Maven?


A: Build portability refers to the ability of a build system to run on different environments and platforms.

B: Build portability refers to the ability of a build system to only run on a specific environment and platform.

C: Build portability refers to the ability of a build system to only run on Windows platforms.


Correct Response: 1

Explanation: Build portability refers to the ability of a build system to run on different environments and platforms. Maven is designed to be highly portable, meaning that it can run on any system with a Java Virtual Machine installed. This allows Maven builds to be run on different operating systems, such as Windows, MacOS, and Linux, without any changes to the build configuration.





Q: What is the purpose of using Maven in a project?


A: To manage dependencies, build, and test a project.

B: To only manage dependencies in a project.

C: To only build and test a project.


Correct Response: 1

Explanation: The purpose of using Maven in a project is to manage dependencies, build, and test a project. Maven provides a standard build and project management tool that makes it easier to manage the build process, dependencies, and testing of a project.





Q: How does Maven handle dependencies in a project?


A: Maven downloads and manages the dependencies required for a project.

B: Maven only downloads the dependencies required for a project.

C: Maven only manages the dependencies required for a project.


Correct Response: 1

Explanation: Maven handles dependencies in a project by downloading and managing the dependencies required for a project. Maven downloads the dependencies from a central repository, such as the Maven Central repository, and stores them in a local repository. This makes it easier to manage the dependencies required for a project, and ensures that all team members are using the same versions of the dependencies.





Q: How does Maven handle version conflicts in dependencies?


A: Maven resolves version conflicts by using the latest version of a dependency.

B: Maven resolves version conflicts by using the oldest version of a dependency.

C: Maven resolves version conflicts by using the specified version of a dependency.


Correct Response: 3

Explanation: Maven handles version conflicts in dependencies by using the specified version of a dependency. If a project requires multiple dependencies with different versions of a specific library, Maven will use the version specified in the project's POM file. This ensures that the correct version of the library is used, and prevents version conflicts from occurring.





Q: Can you explain the concept of transitive dependencies in Maven?


A: Transitive dependencies are dependencies that are required by a project, but are not specified in the project's POM file.

B: Transitive dependencies are dependencies that are specified in the project's POM file.

C: Transitive dependencies are dependencies that are not required by a project.


Correct Response: 1

Explanation: In Maven, transitive dependencies are dependencies that are required by a project, but are not specified in the project's POM file. These dependencies are automatically downloaded and managed by Maven, based on the dependencies specified in the project's POM file. Transitive dependencies allow us to specify the dependencies required for a project, without having to manually manage the dependencies of those dependencies.





Q: What is a plugin in Maven and how does it work?


A: A plugin is a piece of software that extends the functionality of Maven, allowing it to perform additional tasks such as compiling code or generating documentation.

B: A plugin is a piece of software that replaces the functionality of Maven, allowing it to perform additional tasks such as compiling code or generating documentation.

C: A plugin is a piece of software that enhances the functionality of Java, allowing it to perform additional tasks such as compiling code or generating documentation.


Correct Response: 1

Explanation: A plugin in Maven is a piece of software that extends the functionality of Maven, allowing it to perform additional tasks such as compiling code, generating documentation, or performing tests. Plugins are executed during the build process and can be added to a Maven project by specifying them in the project's POM file.





Q: Can you explain the different phases in the Maven build lifecycle?


A: The Maven build lifecycle consists of several phases, including validate, compile, test, package, install, and deploy.

B: The Maven build lifecycle consists of several phases, including validate, build, test, package, install, and deploy.

C: The Maven build lifecycle consists of several phases, including validate, compile, build, test, package, install, and deploy.


Correct Response: 1

Explanation: The Maven build lifecycle consists of several phases, including validate, compile, test, package, install, and deploy. These phases represent different stages of the build process, from validating the project structure and checking for missing information, to compiling the code, running tests, packaging the build output, and deploying the build to a repository.





Q: How does Maven handle project builds and deployments?


A: Maven automates the build and deployment process, managing dependencies, compiling code, and deploying the build to a repository.

B: Maven only automates the build process, managing dependencies and compiling code.

C: Maven only automates the deployment process, deploying the build to a repository.


Correct Response: 1

Explanation: Maven handles project builds and deployments by automating the build and deployment process. Maven manages dependencies, compiles code, runs tests, and deploys the build to a repository. This makes it easier to manage the build and deployment process, and ensures that all team members are using the same versions of the dependencies and build outputs.





Q: What is the relationship between Maven and Java projects?


A: Maven is a build and project management tool for Java projects.

B: Maven is a build and project management tool for non-Java projects.

C: Maven is a build and project management tool for any type of project.


Correct Response: 1

Explanation: Maven is a build and project management tool for Java projects. Maven provides a standard build and project management tool that makes it easier to manage the build process, dependencies, and testing of a Java project. Maven is specifically designed to work with Java projects, and provides built-in support for managing Java projects and their dependencies.





Q: How does Maven help in project management and organization?


A: Maven helps in project management and organization by providing a standard build and project management tool, managing dependencies, compiling code, and deploying the build to a repository.

B: Maven helps in project management and organization by providing a standard project management tool, managing dependencies, and compiling code.

C: Maven helps in project management and organization by providing a standard build tool, managing dependencies, and deploying the build to a repository.


Correct Response: 1

Explanation: Maven helps in project management and organization by providing a standard build and project management tool. Maven manages dependencies, compiles code, runs tests, and deploys the build to a repository, making it easier to manage the build and deployment process and ensuring that all team members are using the same versions of the dependencies and build outputs.





Q: What is the role of the POM (Project Object Model) in Maven?


A: The POM is a configuration file for a Maven project, specifying the project's dependencies, build configuration, and other information.

B: The POM is a build output file for a Maven project, specifying the project's dependencies, build configuration, and other information.

C: The POM is a source code file for a Maven project, specifying the project's dependencies, build configuration, and other information.


Correct Response: 1

Explanation: The POM (Project Object Model) is a configuration file for a Maven project, specifying the project's dependencies, build configuration, and other information. The POM is used by Maven to manage the build process, dependencies, and other aspects of the project. The POM is a crucial part of a Maven project, and is used to configure the build and manage the dependencies required for the project.





Q: How does Maven handle external dependencies and libraries in a project?


A: Maven handles external dependencies and libraries in a project by downloading them from a central repository, such as the Maven Central repository, and storing them in a local repository.

B: Maven handles external dependencies and libraries in a project by only downloading them from a central repository.

C: Maven handles external dependencies and libraries in a project by only storing them in a local repository.


Correct Response: 1

Explanation: Maven handles external dependencies and libraries in a project by downloading them from a central repository, such as the Maven Central repository, and storing them in a local repository. This makes it easier to manage the dependencies required for a project, and ensures that all team members are using the same versions of the dependencies. The local repository is used to store the dependencies and libraries required for a project, and the central repository is used to store common libraries and dependencies that can be used by multiple projects.





Q: What are the different ways to specify dependencies in Maven?


A: The different ways to specify dependencies in Maven are through the project's POM file, through the command line, and through external configuration files.

B: The different ways to specify dependencies in Maven are through the project's POM file and through the command line.

C: The different ways to specify dependencies in Maven are through the project's POM file and through external configuration files.


Correct Response: 1

Explanation: The different ways to specify dependencies in Maven are through the project's POM file, through the command line, and through external configuration files. The POM file is used to specify the dependencies required for a project, and the command line and external configuration files can be used to add or modify dependencies as needed.





Q: How does Maven handle project documentation and reporting?


A: Maven handles project documentation and reporting by generating reports and documentation based on the project's code and configuration.

B: Maven handles project documentation and reporting by only generating reports based on the project's code and configuration.

C: Maven handles project documentation and reporting by only generating documentation based on the project's code and configuration.


Correct Response: 1

Explanation: Maven handles project documentation and reporting by generating reports and documentation based on the project's code and configuration. Maven provides a number of built-in plugins and reporting tools that can be used to generate project documentation, such as JavaDocs, test reports, and project reports. Maven also makes it easy to add custom reporting and documentation tools as needed, allowing teams to generate the documentation and reports that are most useful for their projects.





