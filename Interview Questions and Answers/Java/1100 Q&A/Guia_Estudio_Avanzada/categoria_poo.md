# POO - Preguntas de Entrevista Java
**Total de preguntas: 305**

## Pregunta 7
**Pregunta:** How does ClassLoader work in Java?
**Nivel:** Intermedio

1. ClassLoader loads classes from the file system when the application starts.
2. ClassLoader loads classes dynamically as they are needed by the application.
3. ClassLoader loads classes from the database when the application starts.

**Respuesta Correcta:** 2

**Explicación:** ClassLoader in Java works by loading classes dynamically as they are needed by the application. It is responsible for finding and loading class files from the file system, network, or other sources.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 9
**Pregunta:** Can we write main method as public void static instead of public static void?
**Nivel:** Básico

1. Yes, we can write the main method as public void static.
2. No, we cannot write the main method as public void static.
3. It depends on the Java version.

**Respuesta Correcta:** 2

**Explicación:** The main method must be declared as public static void, and cannot be declared as public void static. This is because the main method must be a static method so that it can be called without creating an instance of the class, and it must return void as it does not return a value.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 11
**Pregunta:** Let say, we run a java class without passing any arguments. What will be the value of String array of arguments in Main method?
**Nivel:** Básico

1. An empty array
2. A null array
3. An array with one element

**Respuesta Correcta:** 1

**Explicación:** If a Java class is run without passing any arguments, the value of the String array of arguments in the Main method will be an empty array. The length of the array will be 0, but it will not be null.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 15
**Pregunta:** Can you explain the difference between a stack and a heap in Java memory management?
**Nivel:** Intermedio

1. A stack is used for method invocations and local variables, while a heap is used for objects and instance variables.
2. A stack is used for objects and instance variables, while a heap is used for method invocations and local variables.
3. Both the stack and heap are used for the same purpose.

**Respuesta Correcta:** 1

**Explicación:** In Java, the stack is used to store method invocations and local variables, while the heap is used to store objects and instance variables. The stack is used for temporary storage and has a limited size, while the heap is used for long-term storage and can grow or shrink as needed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 23
**Pregunta:** What are the main principles of Object Oriented Programming?
**Nivel:** Básico

1. Encapsulation
2. Inheritance
3. Polymorphism
4. Abstraction

**Respuesta Correcta:** 1, 2, 3, 4

**Explicación:** The main principles of Object Oriented Programming are Encapsulation, Inheritance, Polymorphism, and Abstraction. Encapsulation refers to the idea of wrapping data and behavior within an object. Inheritance allows objects to inherit properties from a parent object. Polymorphism allows objects to take on multiple forms. Abstraction refers to the act of representing essential features without including the background details.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 24
**Pregunta:** What is the difference between Object Oriented Programming language and Object Based Programming language?
**Nivel:** Intermedio

1. Object Oriented Programming languages support inheritance and polymorphism, while Object Based Programming languages do not.
2. Object Oriented Programming languages do not support inheritance and polymorphism, while Object Based Programming languages do.
3. Both Object Oriented Programming languages and Object Based Programming languages support inheritance and polymorphism.

**Respuesta Correcta:** 1

**Explicación:** Object Oriented Programming (OOP) languages, such as Java and C++, support inheritance and polymorphism, while Object Based Programming (OBP) languages, such as JavaScript and VBScript, do not. OOP languages are designed around the concept of objects and the relationships between them, while OBP languages are focused on procedures and functions.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 26
**Pregunta:** Why do we need constructor in Java?
**Nivel:** Intermedio

1. To initialize objects and set default values for instance variables.
2. To declare methods in a class.
3. To declare variables in a class.

**Respuesta Correcta:** 1

**Explicación:** Constructors in Java are used to initialize objects and set default values for instance variables. They are called when an object is created and allow the programmer to specify the initial state of the object. Constructors have the same name as the class and do not have a return type.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 28
**Pregunta:** What is the value returned by Constructor in Java?
**Nivel:** Básico

1. Constructors do not return any value.
2. Constructors return an int value.
3. Constructors return a double value.
4. Constructors return a boolean value.

**Respuesta Correcta:** 1

**Explicación:** In Java, constructors do not return any value. They are called when an object is created and are used to initialize the object and set default values for instance variables.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 29
**Pregunta:** Can we inherit a Constructor?
**Nivel:** Básico

1. No, constructors cannot be inherited.
2. Yes, constructors can be inherited.
3. Constructors can only be inherited in some cases.

**Respuesta Correcta:** 1

**Explicación:** In Java, constructors cannot be inherited. Each class has its own constructor and the constructor of a subclass must call the constructor of its superclass explicitly.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 30
**Pregunta:** Why constructors cannot be final, static, or abstract in Java?
**Nivel:** Intermedio

1. Constructors are not meant to be overridden or modified, so they cannot be declared final. Constructors are not methods, so they cannot be declared static. Constructors are not meant to be subclassed, so they cannot be declared abstract.
2. Constructors are meant to be overridden or modified, so they must be declared final. Constructors are methods, so they must be declared static. Constructors are meant to be subclassed, so they must be declared abstract.
3. Both Constructors are meant to be overridden or modified and Constructors are not methods.

**Respuesta Correcta:** 1

**Explicación:** In Java, constructors cannot be declared final, static, or abstract. Constructors are not meant to be overridden or modified, so they cannot be declared final. Constructors are not methods, so they cannot be declared static. Constructors are not meant to be subclassed, so they cannot be declared abstract.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 31
**Pregunta:** What is inheritance in Object Oriented Programming?
**Nivel:** Básico

1. Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class.
2. Inheritance is a mechanism by which a new class cannot inherit the properties and behavior of an existing class.
3. Inheritance is a mechanism by which a new class can only inherit the properties of an existing class and not the behavior.

**Respuesta Correcta:** 1

**Explicación:** Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class. The new class is called a subclass and the existing class is called a superclass. Inheritance allows for code reuse and provides a way to create new classes that are built on existing classes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 32
**Pregunta:** What is polymorphism in Object Oriented Programming?
**Nivel:** Intermedio

1. Polymorphism is the ability of an object to take on multiple forms.
2. Polymorphism is the inability of an object to take on multiple forms.
3. Polymorphism is the ability of a class to take on multiple forms.

**Respuesta Correcta:** 1

**Explicación:** Polymorphism is the ability of an object to take on multiple forms. It allows objects of different classes to be treated as objects of a common class. Polymorphism is achieved through method overriding, where a subclass can provide a different implementation for a method that is already defined in its superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 35
**Pregunta:** Can an object in Java have multiple classes?
**Nivel:** Básico

1. No, an object in Java can only have one class.
2. Yes, an object in Java can have multiple classes.
3. An object in Java can have multiple classes, but only in some cases.

**Respuesta Correcta:** 1

**Explicación:** In Java, an object can only have one class. Each object is an instance of a class and has its own unique identity and state. An object can belong to only one class, but it can be treated as an object of a common class through inheritance or polymorphism.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 38
**Pregunta:** Can a constructor be private in Java?
**Nivel:** Básico

1. Yes, a constructor can be private in Java.
2. No, a constructor cannot be private in Java.
3. A constructor can only be private in some cases.

**Respuesta Correcta:** 1

**Explicación:** In Java, a constructor can be private. A private constructor is used to restrict the creation of objects of a class from outside the class. This is useful in cases where a class is only meant to be used as a utility class, for example. A private constructor cannot be called from outside the class, so objects can only be created within the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 39
**Pregunta:** What is a super keyword in Java and when is it used?
**Nivel:** Básico

1. The super keyword is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass.
2. The super keyword is used to refer to the subclass of an object. It is used in cases where a superclass needs to access a method or variable that is defined in its subclass.
3. The super keyword is used to refer to an object of a class. It is used in cases where an object needs to access a method or variable that is defined in its class.

**Respuesta Correcta:** 1

**Explicación:** The super keyword in Java is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass. The super keyword is also used to call the constructor of the superclass from the subclass. This allows the subclass to inherit the properties and behavior of its superclass, while also providing a way to extend or modify the behavior of the superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 40
**Pregunta:** What is the purpose of ‘this’ keyword in Java?
**Nivel:** Básico

1. The 'this' keyword is used to refer to the current object or instance of a class. It is used to access instance variables and methods of the current object.
2. The 'this' keyword is used to refer to a different object or instance of a class. It is used to access instance variables and methods of a different object.
3. The 'this' keyword is used to refer to the superclass of a class. It is used to access instance variables and methods of the superclass.

**Respuesta Correcta:** 1

**Explicación:** The 'this' keyword in Java is used to refer to the current object or instance of a class. It is used to access instance variables and methods of the current object. The 'this' keyword is useful for disambiguating instance variables from local variables with the same name, and for calling one constructor from another.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 41
**Pregunta:** Explain the concept of Inheritance?
**Nivel:** Básico

1. Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class. The new class is called a subclass and the existing class is called a superclass. Inheritance allows for code reuse and provides a way to create new classes that are built on existing classes.
2. Inheritance is a mechanism by which a new class cannot inherit the properties and behavior of an existing class.
3. Inheritance is a mechanism by which a new class can only inherit the properties of an existing class and not the behavior.

**Respuesta Correcta:** 1

**Explicación:** Inheritance is a mechanism by which a new class can inherit the properties and behavior of an existing class. The new class is called a subclass and the existing class is called a superclass. Inheritance allows for code reuse and provides a way to create new classes that are built on existing classes. The subclass can access the methods and variables defined in the superclass and can also override or extend the behavior of the superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 42
**Pregunta:** Which class in Java is superclass of every other class?
**Nivel:** Básico

1. java.lang.Object
2. java.lang.String
3. java.lang.Integer
4. java.lang.Number

**Respuesta Correcta:** 1

**Explicación:** In Java, every class is a subclass of the java.lang.Object class. The Object class is the root of the class hierarchy and provides a set of methods that are inherited by all classes. The Object class provides basic methods such as toString(), equals(), and hashCode() that are commonly used by all classes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 44
**Pregunta:** In OOPS, what is meant by composition?
**Nivel:** Básico

1. Composition is a mechanism by which one object contains another object as a part of its state. The contained object is called a component and the containing object is called a composite. Composition is used to represent a part-whole relationship between objects.
2. Composition is a mechanism by which one object does not contain another object as a part of its state.
3. Composition is a mechanism by which one object is contained by another object. The containing object is called a component and the contained object is called a composite.

**Respuesta Correcta:** 1

**Explicación:** Composition is a mechanism by which one object contains another object as a part of its state. The contained object is called a component and the containing object is called a composite. Composition is used to represent a part-whole relationship between objects. Composition is used to achieve code reuse and to model complex relationships between objects.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 45
**Pregunta:** How aggregation and composition are different concepts?
**Nivel:** Intermedio

1. Aggregation and composition are different in that aggregation represents a weak relationship between objects, while composition represents a strong relationship between objects. In aggregation, the contained object can exist independently of the containing object, while in composition, the contained object cannot exist independently of the containing object.
2. Aggregation and composition are the same concept.
3. Aggregation represents a strong relationship between objects, while composition represents a weak relationship between objects. In aggregation, the contained object cannot exist independently of the containing object, while in composition, the contained object can exist independently of the containing object.

**Respuesta Correcta:** 1

**Explicación:** Aggregation and composition are different in that aggregation represents a weak relationship between objects, while composition represents a strong relationship between objects. In aggregation, the contained object can exist independently of the containing object, while in composition, the contained object cannot exist independently of the containing object. Aggregation is used to represent a has-a relationship between objects, while composition is used to represent a part-whole relationship between objects.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 48
**Pregunta:** What is the purpose of ‘super’ keyword in Java?
**Nivel:** Básico

1. The 'super' keyword is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass. The 'super' keyword is also used to call the constructor of the superclass from the subclass.
2. The 'super' keyword is used to refer to the subclass of an object. It is used in cases where a superclass needs to access a method or variable that is defined in its subclass.
3. The 'super' keyword is used to refer to an object of a class. It is used in cases where an object needs to access a method or variable that is defined in its class.

**Respuesta Correcta:** 1

**Explicación:** The 'super' keyword in Java is used to refer to the superclass of an object. It is used in cases where a subclass needs to access a method or variable that is defined in its superclass. The 'super' keyword is also used to call the constructor of the superclass from the subclass. This allows the subclass to inherit the properties and behavior of its superclass, while also providing a way to extend or modify the behavior of the superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 49
**Pregunta:** Is it possible to use this() and super() both in same constructor?
**Nivel:** Básico

1. No, it is not possible to use both this() and super() in the same constructor. A constructor can either call another constructor using the this() keyword or call the superclass constructor using the super() keyword, but not both.
2. Yes, it is possible to use both this() and super() in the same constructor.
3. It is possible to use both this() and super() in the same constructor in some cases, but not in others.

**Respuesta Correcta:** 1

**Explicación:** No, it is not possible to use both this() and super() in the same constructor. A constructor can either call another constructor using the this() keyword or call the superclass constructor using the super() keyword, but not both. This is because the this() and super() keywords are used to call different constructors and cannot be used in the same constructor.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 51
**Pregunta:** What is the difference between inheritance and polymorphism?
**Nivel:** Intermedio

1. Inheritance and polymorphism are two distinct concepts in Object Oriented Programming. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Polymorphism is a mechanism by which an object can exhibit different behavior based on the context in which it is used. Inheritance provides a way to create a hierarchy of classes, while polymorphism provides a way to write code that can handle objects of different classes in a generic way.
2. Inheritance and polymorphism are the same concept.
3. Inheritance provides a way to handle objects of different classes in a generic way, while polymorphism provides a way to create a hierarchy of classes.

**Respuesta Correcta:** 1

**Explicación:** Inheritance and polymorphism are two distinct concepts in Object Oriented Programming. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Polymorphism is a mechanism by which an object can exhibit different behavior based on the context in which it is used. Inheritance provides a way to create a hierarchy of classes, while polymorphism provides a way to write code that can handle objects of different classes in a generic way.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 53
**Pregunta:** What is the difference between inheritance and composition in Java?
**Nivel:** Intermedio

1. Inheritance and composition are two different mechanisms for creating relationships between classes in Java. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Composition is a mechanism by which an object can be composed of other objects, allowing for code reuse and flexible design. Inheritance provides a way to create a hierarchy of classes and is useful for modeling relationships between objects, while composition provides a way to model complex relationships between objects and is useful for achieving code reuse.
2. Inheritance and composition are the same concept.
3. Composition provides a way to create a hierarchy of classes, while inheritance provides a way to model complex relationships between objects.

**Respuesta Correcta:** 1

**Explicación:** Inheritance and composition are two different mechanisms for creating relationships between classes in Java. Inheritance is a mechanism by which a subclass can inherit the properties and behavior of a superclass. Composition is a mechanism by which an object can be composed of other objects, allowing for code reuse and flexible design. Inheritance provides a way to create a hierarchy of classes and is useful for modeling relationships between objects, while composition provides a way to model complex relationships between objects and is useful for achieving code reuse.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 54
**Pregunta:** What is method overloading and method overriding in Java?
**Nivel:** Intermedio

1. Method overloading and method overriding are two different concepts in Java. Method overloading is a technique where a class can have multiple methods with the same name, but different parameters. This allows the class to provide multiple implementations of a method that can be called based on the parameters passed to the method. Method overriding is a technique where a subclass can provide its own implementation of a method that is defined in its superclass. This allows the subclass to extend or modify the behavior of the superclass.
2. Method overloading and method overriding are the same concept.
3. Method overloading provides a way to extend or modify the behavior of a class, while method overriding provides a way to have multiple methods with the same name in a class.

**Respuesta Correcta:** 1

**Explicación:** Method overloading and method overriding are two different concepts in Java. Method overloading is a technique where a class can have multiple methods with the same name, but different parameters. This allows the class to provide multiple implementations of a method that can be called based on the parameters passed to the method. Method overriding is a technique where a subclass can provide its own implementation of a method that is defined in its superclass. This allows the subclass to extend or modify the behavior of the superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 55
**Pregunta:** What is an abstract class in Java and when should it be used?
**Nivel:** Intermedio

1. An abstract class in Java is a class that cannot be instantiated and is used as a base class for other classes. An abstract class is defined using the abstract keyword and provides a partial implementation of a class that can be extended by concrete subclasses. An abstract class is useful when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class. An abstract class should be used when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class.
2. An abstract class in Java is a class that can be instantiated.
3. An abstract class in Java is a class that is used as a base class for other classes and cannot be extended.

**Respuesta Correcta:** 1

**Explicación:** An abstract class in Java is a class that cannot be instantiated and is used as a base class for other classes. An abstract class is defined using the abstract keyword and provides a partial implementation of a class that can be extended by concrete subclasses. An abstract class is useful when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class. An abstract class should be used when there is a common behavior that is shared by multiple classes and the behavior cannot be fully defined in the abstract class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 57
**Pregunta:** What is the purpose of the abstract keyword in Java?
**Nivel:** Intermedio

1. The abstract keyword in Java is used to define an abstract class or an abstract method. An abstract class is a class that cannot be instantiated and is used as a base class for other classes. An abstract method is a method that does not have an implementation and must be overridden by concrete subclasses. The abstract keyword provides a way to define classes and methods that must be extended or overridden by concrete subclasses, allowing for abstraction and the implementation of common behavior in the superclass.
2. The abstract keyword in Java is used to define a method that cannot be overridden by subclasses.
3. The abstract keyword in Java is used to define a class that can be instantiated.

**Respuesta Correcta:** 1

**Explicación:** The abstract keyword in Java is used to define an abstract class or an abstract method. An abstract class is a class that cannot be instantiated and is used as a base class for other classes. An abstract method is a method that does not have an implementation and must be overridden by concrete subclasses. The abstract keyword provides a way to define classes and methods that must be extended or overridden by concrete subclasses, allowing for abstraction and the implementation of common behavior in the superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 58
**Pregunta:** Can a subclass constructor call the constructor of its superclass in Java?
**Nivel:** Básico

1. Yes, a subclass constructor can call the constructor of its superclass in Java using the super keyword. The super keyword is used to call the constructor of the superclass and must be the first statement in the subclass constructor. Calling the superclass constructor allows the subclass to initialize the state of the superclass and extend its behavior.
2. No, a subclass constructor cannot call the constructor of its superclass in Java.
3. A subclass constructor can call the constructor of its superclass in Java in some cases, but not in others.

**Respuesta Correcta:** 1

**Explicación:** Yes, a subclass constructor can call the constructor of its superclass in Java using the super keyword. The super keyword is used to call the constructor of the superclass and must be the first statement in the subclass constructor. Calling the superclass constructor allows the subclass to initialize the state of the superclass and extend its behavior.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 59
**Pregunta:** What is the difference between a constructor and a method in Java?
**Nivel:** Intermedio

1. A constructor and a method are two different concepts in Java. A constructor is a special type of method that is used to initialize an object and is called when an object is created. A constructor has the same name as the class and does not have a return type. A method is a block of code that performs a specific task and can be called multiple times during the lifetime of an object. A method has a name and a return type.
2. A constructor and a method are the same concept.
3. A constructor is a special type of method that is used to initialize an object and is called only once during the lifetime of an object. A method is a block of code that performs a specific task and can be called multiple times during the lifetime of an object.

**Respuesta Correcta:** 1

**Explicación:** A constructor and a method are two different concepts in Java. A constructor is a special type of method that is used to initialize an object and is called when an object is created. A constructor has the same name as the class and does not have a return type. A method is a block of code that performs a specific task and can be called multiple times during the lifetime of an object. A method has a name and a return type.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 60
**Pregunta:** In Java, why do we use static variable?
**Nivel:** Intermedio

1. To share a single copy of the variable among all instances of the class.
2. To create a separate copy of the variable for each instance of the class.
3. To store global variables.

**Respuesta Correcta:** 1

**Explicación:** Static variables in Java are used to share a single copy of the variable among all instances of the class. This means that the value of the static variable can be accessed and modified by any instance of the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 62
**Pregunta:** What is the purpose of static method in Java?
**Nivel:** Básico

1. To access and modify instance variables.
2. To access and modify class variables.
3. To access class variables and methods without creating an instance of the class.

**Respuesta Correcta:** 3

**Explicación:** Static methods in Java can be accessed without creating an instance of the class. This makes them useful for operations that do not require access to instance variables or methods.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 64
**Pregunta:** In what scenario do we use a static block?
**Nivel:** Básico

1. To initialize instance variables.
2. To initialize class variables.
3. To execute some code before the main method is called.

**Respuesta Correcta:** 2

**Explicación:** Static blocks in Java are used to initialize class variables. They are executed before the main method is called and are useful for initializing variables that need to be set up before the class is used.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 66
**Pregunta:** What is the difference between static method and instance method in Java?
**Nivel:** Intermedio

1. Static methods can access both static and instance variables, while instance methods can only access instance variables.
2. Instance methods can access both static and instance variables, while static methods can only access static variables.
3. Static methods can only access static variables, while instance methods can only access instance variables.

**Respuesta Correcta:** 1

**Explicación:** Static methods can access both static and instance variables, while instance methods can only access instance variables. This means that static methods can be accessed without creating an instance of the class, while instance methods must be called on an instance of the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 67
**Pregunta:** What is the difference between a static and non-static variable in Java?
**Nivel:** Intermedio

1. Static variables are shared among all instances of a class, while non-static variables are separate for each instance.
2. Non-static variables are shared among all instances of a class, while static variables are separate for each instance.
3. Both static and non-static variables are the same.

**Respuesta Correcta:** 1

**Explicación:** Static variables in Java are shared among all instances of a class, while non-static variables are separate for each instance. This means that the value of a static variable can be accessed and modified by any instance of the class, while the value of a non-static variable is specific to a particular instance.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 68
**Pregunta:** Can a static method be overridden in Java?
**Nivel:** Intermedio

1. Yes.
2. No.
3. It depends on the implementation.

**Respuesta Correcta:** 2

**Explicación:** Static methods in Java cannot be overridden because they are associated with the class, not with a particular instance. Overriding occurs when a subclass provides a new implementation for a method defined in its superclass. Since static methods are not associated with instances, they cannot be overridden.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 69
**Pregunta:** What is the lifecycle of a static variable in Java?
**Nivel:** Básico

1. The lifecycle of a static variable begins when the class is loaded and ends when the class is unloaded.
2. The lifecycle of a static variable begins when the program is executed and ends when the program terminates.
3. The lifecycle of a static variable is determined by the programmer.

**Respuesta Correcta:** 1

**Explicación:** The lifecycle of a static variable in Java begins when the class is loaded and ends when the class is unloaded. This means that the value of a static variable persists for the lifetime of the class and is shared among all instances of the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 71
**Pregunta:** Can we access a non-static variable inside a static method in Java?
**Nivel:** Básico

1. Yes, by creating an instance of the class.
2. No, it is not possible.
3. Yes, by using the this keyword.

**Respuesta Correcta:** 1

**Explicación:** Non-static variables can be accessed inside a static method in Java by creating an instance of the class and accessing the non-static variable through the instance.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 72
**Pregunta:** Can a static method access a non-static variable in Java?
**Nivel:** Básico

1. Yes, by creating an instance of the class.
2. No, it is not possible.
3. Yes, by using the this keyword.

**Respuesta Correcta:** 1

**Explicación:** Static methods in Java can access non-static variables by creating an instance of the class and accessing the non-static variable through the instance.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 73
**Pregunta:** What is the difference between static and final keywords in Java?
**Nivel:** Intermedio

1. Static is used to define class-level variables, while final is used to define constant variables.
2. Final is used to define class-level variables, while static is used to define constant variables.
3. Both static and final are used to define constant variables.

**Respuesta Correcta:** 1

**Explicación:** The static keyword in Java is used to define class-level variables, while the final keyword is used to define constant variables. This means that the value of a final variable cannot be changed after it is initialized, while the value of a static variable can be changed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 74
**Pregunta:** Can a static class be inner class in Java?
**Nivel:** Básico

1. Yes.
2. No.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** In Java, a static class can be an inner class. An inner class is a class defined within another class, and a static inner class is a class that is declared with the static modifier.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 75
**Pregunta:** What is the other name of Method Overloading?
**Nivel:** Básico

1. Compile-time polymorphism.
2. Run-time polymorphism.
3. Dynamic polymorphism.

**Respuesta Correcta:** 1

**Explicación:** Method overloading is also known as compile-time polymorphism. This is because the method to be called is determined at compile-time based on the arguments passed to the method.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 80
**Pregunta:** How do we implement method overriding in Java?
**Nivel:** Intermedio

1. By defining a method in a subclass with the same name and parameters as a method in the superclass.
2. By defining a method in a subclass with a different name and parameters as a method in the superclass.
3. By defining a method in a subclass with the same name and different parameters as a method in the superclass.

**Respuesta Correcta:** 1

**Explicación:** Method overriding in Java is implemented by defining a method in a subclass with the same name and parameters as a method in the superclass. This allows the subclass to provide its own implementation for the method and override the behavior of the superclass method.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 81
**Pregunta:** Are we allowed to override a static method in Java?
**Nivel:** Básico

1. No.
2. Yes.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** Java does not allow overriding of static methods. Static methods are associated with the class and not with instances of the class, and therefore cannot be overridden by subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 82
**Pregunta:** Why Java does not allow overriding a static method?
**Nivel:** Intermedio

1. Because static methods are associated with the class and not with instances of the class.
2. Because static methods cannot be polymorphic.
3. Because static methods cannot be accessed from an instance of the class.

**Respuesta Correcta:** 1

**Explicación:** Java does not allow overriding of static methods because static methods are associated with the class and not with instances of the class. Overriding occurs when a subclass provides a new implementation for a method defined in its superclass. Since static methods are not associated with instances, they cannot be overridden.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 83
**Pregunta:** Is it allowed to override an overloaded method?
**Nivel:** Intermedio

1. No.
2. Yes.
3. It depends on the implementation.

**Respuesta Correcta:** 2

**Explicación:** In Java, it is allowed to override an overloaded method. Overloading occurs when multiple methods with the same name are defined, each with different parameters. Overriding occurs when a subclass provides a new implementation for a method defined in its superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 84
**Pregunta:** What is the difference between method overloading and method overriding in Java?
**Nivel:** Intermedio

1. Method overloading allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass.
2. Method overloading allows a subclass to provide a new implementation for a method defined in its superclass, while method overloading allows multiple methods with the same name but different parameters.
3. Both method overloading and method overriding are the same.

**Respuesta Correcta:** 1

**Explicación:** Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass. Overloading occurs at compile-time, while overriding occurs at runtime.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 85
**Pregunta:** Does Java allow virtual functions?
**Nivel:** Intermedio

1. No.
2. Yes.
3. It depends on the implementation.

**Respuesta Correcta:** 2

**Explicación:** Java does allow virtual functions, although it does not use the term "virtual function." In Java, virtual functions are implemented as instance methods that can be overridden by subclasses. This allows the subclass to provide its own implementation for the method and override the behavior of the superclass method.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 87
**Pregunta:** What is the main difference between method overloading and method overriding?
**Nivel:** Intermedio

1. Method overloading allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass.
2. Method overloading allows a subclass to provide a new implementation for a method defined in its superclass, while method overloading allows multiple methods with the same name but different parameters.
3. Both method overloading and method overriding are the same.

**Respuesta Correcta:** 1

**Explicación:** Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding allows a subclass to provide a new implementation for a method defined in its superclass. Overloading occurs at compile-time, while overriding occurs at runtime.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 89
**Pregunta:** Can you override a final method in Java?
**Nivel:** Básico

1. No.
2. Yes.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** Java does not allow the overriding of final methods. A method declared with the final keyword cannot be overridden by any subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 90
**Pregunta:** Can you change the access level of an overridden method in Java?
**Nivel:** Intermedio

1. No.
2. Yes.
3. It depends on the implementation.

**Respuesta Correcta:** 2

**Explicación:** In Java, it is allowed to change the access level of an overridden method. However, the access level cannot be made more restrictive than the access level of the overridden method in the superclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 91
**Pregunta:** What happens if a subclass does not provide an implementation for an abstract method inherited from its superclass?
**Nivel:** Intermedio

1. The subclass must be declared abstract.
2. The subclass must provide an implementation for the abstract method.
3. The subclass can provide an implementation for the abstract method or be declared abstract itself.

**Respuesta Correcta:** 2

**Explicación:** In Java, if a subclass does not provide an implementation for an abstract method inherited from its superclass, the subclass must provide an implementation for the abstract method or be declared abstract itself. This allows the abstract method to be defined in the superclass, but implemented in the subclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 92
**Pregunta:** Can you call the overridden method from the subclass in Java?
**Nivel:** Intermedio

1. Yes.
2. No.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** In Java, it is possible to call the overridden method from the subclass. The subclass can use the super keyword to call the overridden method from the superclass. This allows the subclass to call the superclass implementation if it needs to use it, or it can choose to provide its own implementation.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 93
**Pregunta:** What is the relationship between method overloading and inheritance in Java?
**Nivel:** Básico

1. Method overloading allows multiple methods with the same name but different parameters, while inheritance allows a subclass to inherit the properties and methods of its superclass.
2. Method overloading allows a subclass to inherit the properties and methods of its superclass, while inheritance allows multiple methods with the same name but different parameters.
3. Both method overloading and inheritance are the same.

**Respuesta Correcta:** 1

**Explicación:** Method overloading in Java allows multiple methods with the same name but different parameters, while inheritance allows a subclass to inherit the properties and methods of its superclass. They are distinct concepts and are not directly related.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 95
**Pregunta:** Is it possible to achieve Runtime Polymorphism by data members in Java?
**Nivel:** Básico

1. No.
2. Yes.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** It is not possible to achieve runtime polymorphism by data members in Java. Polymorphism is a concept that applies to methods and objects, not data members. Data members are simply variables associated with an object, and do not participate in polymorphism.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 97
**Pregunta:** What is Polymorphism in Java?
**Nivel:** Básico

1. The ability of an object to take on multiple forms.
2. The ability of a method to be called with multiple arguments.
3. The ability of a class to inherit properties and methods from multiple superclasses.

**Respuesta Correcta:** 1

**Explicación:** Polymorphism in Java is the ability of an object to take on multiple forms. This is achieved through method overloading and method overriding, which allow objects to have multiple behaviors depending on the context in which they are used.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 98
**Pregunta:** What is Compile-time Polymorphism in Java?
**Nivel:** Básico

1. Polymorphism that occurs at compile-time.
2. Polymorphism that occurs at runtime.
3. Polymorphism that occurs both at compile-time and runtime.

**Respuesta Correcta:** 1

**Explicación:** Compile-time Polymorphism, also known as static polymorphism, is a form of polymorphism in which the type of an object is determined at compile-time. This is achieved through method overloading in Java.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 99
**Pregunta:** How is polymorphism achieved in Java?
**Nivel:** Intermedio

1. By allowing an object to take on multiple forms through method overloading and method overriding.
2. By allowing a method to be called with multiple arguments.
3. By allowing a class to inherit properties and methods from multiple superclasses.

**Respuesta Correcta:** 1

**Explicación:** Polymorphism in Java is achieved by allowing an object to take on multiple forms through method overloading and method overriding. This allows objects to have multiple behaviors depending on the context in which they are used.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 100
**Pregunta:** Can you give an example of polymorphism in Java?
**Nivel:** Intermedio

1. An example of polymorphism in Java would be a class hierarchy in which a subclass provides its own implementation for a method defined in its superclass.
2. An example of polymorphism in Java would be a method that can be called with multiple arguments.
3. An example of polymorphism in Java would be a class that can inherit properties and methods from multiple superclasses.

**Respuesta Correcta:** 1

**Explicación:** An example of polymorphism in Java would be a class hierarchy in which a subclass provides its own implementation for a method defined in its superclass. This allows the subclass to override the behavior of the superclass method, providing a new implementation that is specific to the subclass. This is achieved through method overriding in Java.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 101
**Pregunta:** What is method overloading in Java and how does it relate to polymorphism?
**Nivel:** Intermedio

1. Method overloading in Java allows multiple methods with the same name but different parameters. It is a form of compile-time polymorphism that allows objects to have multiple behaviors based on the context in which they are used.
2. Method overloading in Java allows a subclass to provide a new implementation for a method defined in its superclass. It is a form of runtime polymorphism that allows objects to have multiple behaviors based on the context in which they are used.
3. Method overloading in Java allows a method to be called with multiple arguments. It is not related to polymorphism.

**Respuesta Correcta:** 1

**Explicación:** Method overloading in Java allows multiple methods with the same name but different parameters. It is a form of compile-time polymorphism that allows objects to have multiple behaviors based on the context in which they are used. Method overloading is a way to achieve polymorphism in Java by providing multiple implementations for a single method name, allowing the correct implementation to be selected based on the arguments passed to the method.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 104
**Pregunta:** What is the difference between method overloading and method overriding in Java?
**Nivel:** Intermedio

1. Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding in Java allows a subclass to provide a new implementation for a method defined in its superclass.
2. Method overloading in Java allows a subclass to provide a new implementation for a method defined in its superclass, while method overriding in Java allows multiple methods with the same name but different parameters.
3. Method overloading and method overriding are the same.

**Respuesta Correcta:** 1

**Explicación:** Method overloading in Java allows multiple methods with the same name but different parameters, while method overriding in Java allows a subclass to provide a new implementation for a method defined in its superclass. Method overloading is a form of compile-time polymorphism, while method overriding is a form of runtime polymorphism.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 113
**Pregunta:** What is Abstraction in Object Oriented programming?
**Nivel:** Intermedio

1. The process of hiding implementation details and showing only the essential features of an object.
2. The process of exposing implementation details and showing all the features of an object.
3. The process of creating objects.

**Respuesta Correcta:** 1

**Explicación:** Abstraction is a fundamental concept in object-oriented programming and is the process of hiding implementation details and showing only the essential features of an object. This allows for a clear and concise representation of the object and helps to reduce complexity.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 114
**Pregunta:** How is Abstraction different from Encapsulation?
**Nivel:** Intermedio

1. Abstraction focuses on hiding implementation details, while encapsulation focuses on hiding data.
2. Abstraction focuses on exposing implementation details, while encapsulation focuses on hiding data.
3. Both Abstraction and Encapsulation are the same.

**Respuesta Correcta:** 1

**Explicación:** Abstraction focuses on hiding implementation details and showing only the essential features of an object, while encapsulation focuses on hiding data within an object by binding data and functions together within a single unit, or object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 115
**Pregunta:** What is an abstract class in Java?
**Nivel:** Básico

1. A class that cannot be instantiated and is meant to be subclassed.
2. A class that can be instantiated and is meant to be subclassed.
3. A class that can be instantiated and is not meant to be subclassed.

**Respuesta Correcta:** 1

**Explicación:** An abstract class in Java is a class that cannot be instantiated and is meant to be subclassed. Abstract classes provide a base for subclasses to build upon and can contain both abstract and concrete methods.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 116
**Pregunta:** Is it allowed to mark a method abstract method without marking the class abstract?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 2

**Explicación:** No, it is not allowed to mark a method abstract without marking the class abstract. An abstract method must be declared within an abstract class, as it is meant to be overridden by subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 117
**Pregunta:** Is it allowed to mark a method abstract as well as final?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 2

**Explicación:** No, it is not allowed to mark a method as both abstract and final. An abstract method must be overridden by subclasses, while a final method cannot be overridden. These two concepts are mutually exclusive.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 118
**Pregunta:** Can we instantiate an abstract class in Java?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 2

**Explicación:** No, we cannot instantiate an abstract class in Java. An abstract class is meant to be subclassed and cannot be instantiated directly.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 129
**Pregunta:** Can an abstract class have a constructor in Java?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 1

**Explicación:** Yes, an abstract class in Java can have a constructor. A constructor in an abstract class is used to initialize objects of the abstract class or its subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 130
**Pregunta:** Can we extend more than one abstract class in Java?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 2

**Explicación:** No, we cannot extend more than one abstract class in Java. Java only allows for single inheritance, meaning a class can only extend one other class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 133
**Pregunta:** What is the difference between abstract method and concrete method in Java?
**Nivel:** Intermedio

1. An abstract method has no body, while a concrete method has a body.
2. A concrete method has no body, while an abstract method has a body.
3. Both abstract methods and concrete methods have a body.

**Respuesta Correcta:** 1

**Explicación:** An abstract method in Java has no body and must be overridden by a subclass, while a concrete method has a body and can be directly invoked.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 134
**Pregunta:** Can we define an abstract method with a body in Java?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 2

**Explicación:** No, we cannot define an abstract method with a body in Java. An abstract method must be declared without a body, as it is meant to be overridden by a subclass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 141
**Pregunta:** Can a class be marked final in Java?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 1

**Explicación:** Yes, a class in Java can be marked final. A final class cannot be subclassed, meaning it cannot be used as the base for other classes to extend from.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 142
**Pregunta:** How can we create a final method in Java?
**Nivel:** Intermedio

1. By using the final keyword before the method signature.
2. By using the static keyword before the method signature.
3. By using the abstract keyword before the method signature.

**Respuesta Correcta:** 1

**Explicación:** We can create a final method in Java by using the final keyword before the method signature. A final method cannot be overridden by subclasses, meaning it cannot be changed by subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 143
**Pregunta:** How can we prohibit inheritance in Java?
**Nivel:** Intermedio

1. By marking the class final.
2. By marking the method final.
3. By using the private keyword before the class signature.

**Respuesta Correcta:** 1

**Explicación:** We can prohibit inheritance in Java by marking the class final. A final class cannot be subclassed, meaning it cannot be used as the base for other classes to extend from.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 145
**Pregunta:** What is a blank final variable in Java?
**Nivel:** Básico

1. A blank final variable is a final variable that has not been assigned a value.
2. A blank final variable is a variable that has been assigned a value but is not final.
3. A blank final variable is a final variable that has been assigned a value but can be changed.

**Respuesta Correcta:** 1

**Explicación:** A blank final variable is a final variable that has not been assigned a value. It must be assigned a value before the constructor for the object that contains the variable is complete.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 146
**Pregunta:** How can we initialize a blank final variable?
**Nivel:** Intermedio

1. By assigning a value to the variable before the end of the constructor for the object that contains the variable.
2. By using a setter method.
3. By using a constructor.

**Respuesta Correcta:** 1

**Explicación:** We can initialize a blank final variable by assigning a value to the variable before the end of the constructor for the object that contains the variable. The value must be assigned before the constructor is complete in order for the final variable to have a value.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 149
**Pregunta:** Can a final method be overridden in a subclass?
**Nivel:** Intermedio

1. No
2. Yes
3. It depends

**Respuesta Correcta:** 1

**Explicación:** No, a final method cannot be overridden in a subclass. A final method is meant to be a fixed implementation that cannot be changed by subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 150
**Pregunta:** How does marking a class as final affect polymorphism in Java?
**Nivel:** Intermedio

1. Marking a class as final prevents polymorphism, as a final class cannot be used as the base class for other classes to extend from.
2. Marking a class as final does not affect polymorphism.
3. Marking a class as final promotes polymorphism, as a final class can be used as the base class for other classes to extend from.

**Respuesta Correcta:** 1

**Explicación:** Marking a class as final prevents polymorphism, as a final class cannot be used as the base class for other classes to extend from. This means that a final class cannot be used in place of its base class in polymorphic situations.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 151
**Pregunta:** What is the purpose of a final blank variable in Java?
**Nivel:** Básico

1. A final blank variable is a variable that has not been assigned a value and must be assigned a value before the end of the constructor for the object that contains the variable.
2. A final blank variable is a variable that can be assigned a value after it has been created.
3. A final blank variable is a variable that can be changed after it has been assigned a value.

**Respuesta Correcta:** 1

**Explicación:** A final blank variable is a variable that has not been assigned a value and must be assigned a value before the end of the constructor for the object that contains the variable. The purpose of a final blank variable is to ensure that the variable has a value and cannot be changed after it has been assigned.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 152
**Pregunta:** Can a final class be extended in Java?
**Nivel:** Intermedio

1. No
2. Yes
3. It depends

**Respuesta Correcta:** 1

**Explicación:** No, a final class cannot be extended in Java. A final class is meant to be a fixed implementation that cannot be changed by subclasses.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 153
**Pregunta:** What is the difference between declaring a method as final and declaring a class as final?
**Nivel:** Intermedio

1. Declaring a method as final prevents the method from being overridden in subclasses, while declaring a class as final prevents the class from being used as the base class for other classes to extend from.
2. Declaring a method as final allows the method to be overridden in subclasses, while declaring a class as final promotes polymorphism.
3. There is no difference between declaring a method as final and declaring a class as final.

**Respuesta Correcta:** 1

**Explicación:** Declaring a method as final prevents the method from being overridden in subclasses, while declaring a class as final prevents the class from being used as the base class for other classes to extend from. This means that a final method is a fixed implementation that cannot be changed by subclasses, while a final class is a fixed implementation that cannot be used as the base for other classes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 156
**Pregunta:** Which is the most important class in Java?
**Nivel:** Básico

1. The most important class in Java is the Object class.
2. The most important class in Java is the String class.
3. The most important class in Java is the System class.

**Respuesta Correcta:** 1

**Explicación:** The most important class in Java is the Object class. The Object class is the root of the class hierarchy in Java and provides basic methods for all objects, such as equals and toString.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 158
**Pregunta:** Can you import same package or class twice in your class?
**Nivel:** Básico

1. No, you cannot import the same package or class twice in your class.
2. Yes, you can import the same package or class twice in your class.
3. It depends

**Respuesta Correcta:** 1

**Explicación:** No, you cannot import the same package or class twice in your class. Importing the same package or class multiple times in a single class will result in a compile-time error.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 159
**Pregunta:** What is a static import in Java?
**Nivel:** Básico

1. A static import in Java is a way to import the members of a class, including fields and methods, as if they were part of the class that uses them.
2. A static import in Java is a way to import the members of a class, excluding fields and methods, as if they were part of the class that uses them.
3. A static import in Java is a way to import the members of a class, including fields and methods, as if they were part of the class that does not use them.

**Respuesta Correcta:** 1

**Explicación:** A static import in Java is a way to import the members of a class, including fields and methods, as if they were part of the class that uses them. This allows you to use the members of the imported class without having to qualify them with the class name.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 160
**Pregunta:** What is the difference between import static com.test.Fooclass and import com.test.Fooclass?
**Nivel:** Intermedio

1. The difference between import static com.test.Fooclass and import com.test.Fooclass is that the first imports only the static members of the Fooclass, while the second imports the entire class, including both static and non-static members.
2. The difference between import static com.test.Fooclass and import com.test.Fooclass is that the first imports the entire Fooclass, while the second imports only the static members of the Fooclass.
3. There is no difference between import static com.test.Fooclass and import com.test.Fooclass.

**Respuesta Correcta:** 1

**Explicación:** The difference between import static com.test.Fooclass and import com.test.Fooclass is that the first imports only the static members of the Fooclass, while the second imports the entire class, including both static and non-static members.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 162
**Pregunta:** Can a class belong to multiple packages in Java?
**Nivel:** Básico

1. No, a class cannot belong to multiple packages in Java.
2. Yes, a class can belong to multiple packages in Java.
3. It depends

**Respuesta Correcta:** 1

**Explicación:** No, a class cannot belong to multiple packages in Java. A class can only belong to one package, and it must be specified in the package statement at the beginning of the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 172
**Pregunta:** How do you access a class within a sub-package in Java?
**Nivel:** Intermedio

1. To access a class within a sub-package in Java, you must use the fully-qualified name of the class, including the package and all sub-package names.
2. To access a class within a sub-package in Java, you must use the name of the class without the package or sub-package names.
3. To access a class within a sub-package in Java, you must use the name of the class without the sub-package name and import the package.

**Respuesta Correcta:** 1

**Explicación:** To access a class within a sub-package in Java, you must use the fully-qualified name of the class, including the package and all sub-package names. For example, to access the com.example.subpackage.MyClass class, you would write com.example.subpackage.MyClass in your code.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 173
**Pregunta:** Can you import a class from a package in a different project in Java?
**Nivel:** Básico

1. Yes, you can import a class from a package in a different project in Java.
2. No, you cannot import a class from a package in a different project in Java.
3. It depends

**Respuesta Correcta:** 1

**Explicación:** Yes, you can import a class from a package in a different project in Java. To import a class from a different project, you must ensure that the class and the project containing the class are available on your classpath.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 177
**Pregunta:** How will you use a specific Locale in Java?
**Nivel:** Intermedio

1. To use a specific Locale in Java, you can create a Locale object with the desired language and region, and then pass the Locale object to the appropriate methods that support localization.
2. To use a specific Locale in Java, you can set the default Locale for the Java runtime environment using the Locale.setDefault method.
3. To use a specific Locale in Java, you can set the default Locale for the operating system.

**Respuesta Correcta:** 1

**Explicación:** To use a specific Locale in Java, you can create a Locale object with the desired language and region, and then pass the Locale object to the appropriate methods that support localization. For example, you can use a Locale to format dates, times, numbers, and currency values in a way that is appropriate for a specific user or group of users.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 180
**Pregunta:** How do you switch between different Locales in Java?
**Nivel:** Intermedio

1. By using the setLocale() method of the Locale class.
2. By using the switchLocale() method of the Locale class.
3. By using the changeLocale() method of the Locale class.

**Respuesta Correcta:** 1

**Explicación:** You can switch between different Locales in Java by using the setLocale() method of the Locale class. This method allows you to set the default Locale for your application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 182
**Pregunta:** How do you specify the default Locale in Java?
**Nivel:** Intermedio

1. By using the setDefault() method of the Locale class.
2. By using the switchDefault() method of the Locale class.
3. By using the changeDefault() method of the Locale class.

**Respuesta Correcta:** 1

**Explicación:** You can specify the default Locale in Java by using the setDefault() method of the Locale class. This method allows you to set the default Locale for your application, which will be used if no Locale is specified.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 185
**Pregunta:** Can you explain how to use the NumberFormat and DateFormat classes for formatting numbers and dates for a specific Locale in Java?
**Nivel:** Intermedio

1. NumberFormat numberFormat = NumberFormat.getInstance(locale); and DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale);
2. NumberFormat numberFormat = NumberFormat.getNumberInstance(locale); and DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, locale);
3. NumberFormat numberFormat = NumberFormat.getCurrencyInstance(locale); and DateFormat dateFormat = DateFormat.getTimeInstance(DateFormat.SHORT, locale);

**Respuesta Correcta:** 1, 2

**Explicación:** You can use the NumberFormat and DateFormat classes for formatting numbers and dates for a specific Locale in Java by using the getInstance() or getNumberInstance() methods for NumberFormat, and the getDateInstance(), getDateTimeInstance(), or getTimeInstance() methods for DateFormat, passing in the Locale as an argument. For example, NumberFormat numberFormat = NumberFormat.getInstance(locale) and DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale) can be used to format numbers and dates in a short format for the specified Locale.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 188
**Pregunta:** Can you explain how to create a custom resource bundle for a specific Locale in Java?
**Nivel:** Intermedio

1. By creating a properties file with the localizable resources and the Locale suffix in the file name, and loading the resources using the ResourceBundle class.
2. By creating a class with the localizable resources and the Locale suffix in the class name, and loading the resources using the ResourceBundle class.
3. By creating a database table with the localizable resources and the Locale suffix in the table name, and loading the resources using the ResourceBundle class.

**Respuesta Correcta:** 1, 2

**Explicación:** You can create a custom resource bundle for a specific Locale in Java by creating a properties file or a class with the localizable resources and the Locale suffix in the file or class name. For example, if you want to create a resource bundle for French as used in France, you could create a properties file named MessageBundle_fr_FR.properties or a class named MessageBundle_fr_FR. You can then load the resources using the ResourceBundle class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 189
**Pregunta:** What are the limitations of the ResourceBundle class in Java?
**Nivel:** Básico

1. Does not support multiple bundles for the same Locale.
2. Does not support complex data types such as images and audio.
3. Does not support hierarchical relationships between resources.
4. Does not support dynamic reloading of resources.

**Respuesta Correcta:** 1, 2, 3

**Explicación:** The ResourceBundle class in Java has several limitations, including not supporting multiple bundles for the same Locale, not supporting complex data types such as images and audio, and not supporting hierarchical relationships between resources. Additionally, it does not support dynamic reloading of resources, meaning that changes to the resources will not be reflected until the application is restarted.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 190
**Pregunta:** How does the ResourceBundle class work with the Properties file in Java?
**Nivel:** Intermedio

1. The ResourceBundle class loads the properties from the Properties file, and provides access to the localizable resources as key-value pairs.
2. The ResourceBundle class creates the Properties file, and provides access to the localizable resources as key-value pairs.
3. The ResourceBundle class stores the localizable resources as key-value pairs, and provides access to the properties in the Properties file.

**Respuesta Correcta:** 1

**Explicación:** The ResourceBundle class in Java works with the Properties file by loading the properties from the Properties file, and providing access to the localizable resources as key-value pairs. The Properties file contains the localizable resources as key-value pairs, and the ResourceBundle class provides methods for accessing these resources based on a specified Locale.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 191
**Pregunta:** Can you provide an example of how to use the ResourceBundle class in Java to load messages for different Locales?
**Nivel:** Intermedio

1. ResourceBundle bundle = ResourceBundle.getBundle("Messages", locale);
2. ResourceBundle bundle = ResourceBundle.loadBundle("Messages", locale);
3. ResourceBundle bundle = ResourceBundle.createBundle("Messages", locale);

**Respuesta Correcta:** 1

**Explicación:** You can use the ResourceBundle class in Java to load messages for different Locales by using the getBundle() method. For example, ResourceBundle bundle = ResourceBundle.getBundle("Messages", locale) can be used to load the messages for the specified Locale. The first argument to the method is the base name of the bundle, which is used to locate the properties file or class containing the localizable resources, and the second argument is the Locale for which to load the resources.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 196
**Pregunta:** What is the purpose of serialization?
**Nivel:** Básico

1. The purpose of serialization is to store or transmit an object's state over a network.
2. The purpose of serialization is to store an object's state in a database.
3. The purpose of serialization is to store an object's state in a file system.

**Respuesta Correcta:** 1, 3

**Explicación:** The purpose of serialization is to store or transmit an object's state over a network or in a file system. Serialization allows you to save an object's state to a file or transmit it over a network, and then restore it to its original state later using deserialization.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 205
**Pregunta:** What is the role of the serialVersionUID in serialization?
**Nivel:** Básico

1. The role of the serialVersionUID in serialization is to ensure compatibility between different versions of a class.
2. The role of the serialVersionUID in serialization is to ensure compatibility between different versions of a serialized object.
3. The role of the serialVersionUID in serialization is to ensure compatibility between different versions of the Java virtual machine.

**Respuesta Correcta:** 1

**Explicación:** The role of the serialVersionUID in serialization is to ensure compatibility between different versions of a class. The serialVersionUID is a unique identifier that is associated with a class, and it is used by the Java serialization mechanism to ensure that the class and its serialized data are compatible. If the class is modified in a way that is not compatible with its serialized data, the serialVersionUID can be used to detect this and prevent deserialization errors.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 212
**Pregunta:** What is Reflection in Java?
**Nivel:** Básico

1. Reflection in Java is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime.
2. Reflection in Java is a feature of the Java programming language that allows you to inspect, modify, and destroy objects at runtime.
3. Reflection in Java is a feature of the Java programming language that allows you to inspect, create, and destroy objects at runtime.

**Respuesta Correcta:** 1

**Explicación:** Reflection in Java is a feature of the Java programming language that allows you to inspect, modify, and create objects at runtime. Reflection provides a way to examine and manipulate the properties and behavior of an object, and it is used to perform tasks that are not possible with regular Java code, such as accessing private fields and methods, creating objects dynamically, and so on.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 214
**Pregunta:** How can we access private method of a class from outside the class?
**Nivel:** Intermedio

1. We can access private methods of a class from outside the class by using the Reflection API in Java.
2. We cannot access private methods of a class from outside the class.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** We can access private methods of a class from outside the class by using the Reflection API in Java. The Reflection API provides a way to access and manipulate the properties and behavior of an object, including its private fields and methods. With Reflection, you can call private methods and access private fields, even if they are not accessible from outside the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 215
**Pregunta:** How can we create an Object dynamically at Runtime in Java?
**Nivel:** Intermedio

1. We can create an object dynamically at runtime in Java by using the Reflection API.
2. We cannot create an object dynamically at runtime in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** We can create an object dynamically at runtime in Java by using the Reflection API. The Reflection API provides a way to create objects dynamically at runtime by using the Class.forName() method and the newInstance() method. With these methods, you can create objects of a class that is not known until runtime, and you can create instances of classes that are not available at compile time.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 216
**Pregunta:** Can we change the value of a final field using reflection in Java?
**Nivel:** Intermedio

1. No, we cannot change the value of a final field using reflection in Java.
2. Yes, we can change the value of a final field using reflection in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 2

**Explicación:** Yes, we can change the value of a final field using reflection in Java. Reflection provides a way to access and manipulate the properties and behavior of an object, including its final fields. With Reflection, you can change the value of a final field by using the Field.set() method. However, it is generally considered to be a bad practice, as final fields are meant to be constant and unchanging.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 217
**Pregunta:** What is the difference between Class.forName() and ClassLoader.loadClass() in Java reflection?
**Nivel:** Intermedio

1. The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() loads a class using the system class loader, while ClassLoader.loadClass() loads a class using a specified class loader.
2. The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() loads a class using a specified class loader, while ClassLoader.loadClass() loads a class using the system class loader.
3. The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() only loads a class if it has not already been loaded, while ClassLoader.loadClass() always loads a class, even if it has already been loaded.

**Respuesta Correcta:** 2

**Explicación:** The difference between Class.forName() and ClassLoader.loadClass() in Java reflection is that Class.forName() loads a class using the system class loader, while ClassLoader.loadClass() loads a class using a specified class loader. Class.forName() is a convenient method that automatically uses the system class loader to load a class, while ClassLoader.loadClass() allows you to specify a different class loader to use.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 220
**Pregunta:** Can we invoke a method with parameters using reflection in Java?
**Nivel:** Básico

1. Yes, we can invoke a method with parameters using reflection in Java.
2. No, we cannot invoke a method with parameters using reflection in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** Yes, we can invoke a method with parameters using reflection in Java. The Reflection API provides the Method class, which allows you to invoke a method on an object, including methods with parameters. You can use the Method.invoke() method to invoke a method on an object, passing in the object instance and an array of parameters.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 222
**Pregunta:** How can we determine if a given class is an inner class or not using reflection in Java?
**Nivel:** Intermedio

1. We can determine if a given class is an inner class or not using reflection in Java by checking if the class name contains a "$" symbol.
2. We cannot determine if a given class is an inner class or not using reflection in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** We can determine if a given class is an inner class or not using reflection in Java by checking if the class name contains a "$" symbol. Inner classes in Java have names that contain a "$" symbol, followed by a number that indicates the order in which the inner class was declared. For example, if you have a class named Outer and an inner class named Outer$Inner, you can use reflection to determine that Outer$Inner is an inner class by checking if its name contains a "$" symbol.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 224
**Pregunta:** Can you define a class with the same name as a class in a different package in Java?
**Nivel:** Básico

1. Yes, you can define a class with the same name as a class in a different package in Java, as long as the classes are in different packages.
2. No, you cannot define a class with the same name as a class in a different package in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** Yes, you can define a class with the same name as a class in a different package in Java, as long as the classes are in different packages. Classes in different packages have different fully-qualified names, which include the package name, so you can have classes with the same name as long as they are in different packages. For example, you can have a class named ExampleClass in the com.example.package1 package, and another class named ExampleClass in the com.example.package2 package.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 225
**Pregunta:** What happens if two packages contain classes with the same name in Java?
**Nivel:** Básico

1. If two packages contain classes with the same name in Java, you will need to use the fully-qualified name of the class, including the package name, to distinguish between the two classes.
2. If two packages contain classes with the same name in Java, the classes will overwrite each other and only one of the classes will be accessible.
3. If two packages contain classes with the same name in Java, the classes will not be accessible.

**Respuesta Correcta:** 1

**Explicación:** If two packages contain classes with the same name in Java, you will need to use the fully-qualified name of the class, including the package name, to distinguish between the two classes. Classes in different packages have different fully-qualified names, which include the package name, so you can have classes with the same name as long as they are in different packages. For example, you can have a class named ExampleClass in the com.example.package1 package, and another class named ExampleClass in the com.example.package2 package, and you can distinguish between the two classes by using their fully-qualified names.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 228
**Pregunta:** How do you access a class within a sub-package in Java?
**Nivel:** Intermedio

1. You can access a class within a sub-package in Java by using the fully-qualified name of the class, including the sub-package name.
2. You cannot access a class within a sub-package in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** You can access a class within a sub-package in Java by using the fully-qualified name of the class, including the sub-package name. For example, if you have a sub-package named com.example.subpackage and a class named ExampleClass within that sub-package, you can access the ExampleClass class by using its fully-qualified name com.example.subpackage.ExampleClass.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 229
**Pregunta:** Can you import a class from a package in a different project in Java?
**Nivel:** Básico

1. Yes, you can import a class from a package in a different project in Java by adding the required project to the classpath and using the import statement to import the class.
2. No, you cannot import a class from a package in a different project in Java.
3. It depends on the implementation.

**Respuesta Correcta:** 1

**Explicación:** Yes, you can import a class from a package in a different project in Java by adding the required project to the classpath and using the import statement to import the class. To import a class from a package in a different project, you will need to add the required project to the classpath of your current project, either by including it in your build system or by specifying it on the command line when you run your application. Once the required project is on the classpath, you can use the import statement to import the class as you would for a class in the same project.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 252
**Pregunta:** What is a Nested class?
**Nivel:** Básico

1. A class declared inside another class.
2. A class declared outside of all classes.
3. A class declared inside a method.

**Respuesta Correcta:** 1

**Explicación:** A Nested class is a class declared inside another class. It has access to all members (including private members) of the enclosing class and can be declared as static or non-static.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 253
**Pregunta:** How many types of Nested classes are in Java?
**Nivel:** Intermedio

1. 2
2. 3
3. 4
4. 5

**Respuesta Correcta:** 2

**Explicación:** There are two types of Nested classes in Java: static nested class and inner class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 255
**Pregunta:** What is the difference between a Nested class and an Inner class in Java?
**Nivel:** Intermedio

1. There is no difference, both terms refer to the same thing.
2. A Nested class is static while an Inner class is non-static.
3. An Inner class has access to the enclosing class's instance variables while a Nested class does not.

**Respuesta Correcta:** 2

**Explicación:** The main difference between a Nested class and an Inner class is that a Nested class is static while an Inner class is non-static. An Inner class has access to the enclosing class's instance variables while a Nested class does not.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 257
**Pregunta:** How can we access the non-final local variable, inside a Local Inner class?
**Nivel:** Intermedio

1. By marking the local variable as final.
2. By using the this keyword.
3. By using an instance of the local inner class.

**Respuesta Correcta:** 1

**Explicación:** In order to access a non-final local variable inside a Local Inner class, the local variable must be marked as final. This is because local variables are stored on the stack, which is not accessible from within an inner class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 261
**Pregunta:** Can a Nested class be declared private in Java?
**Nivel:** Básico

1. Yes, a Nested class can be declared private.
2. No, a Nested class cannot be declared private.
3. Only in Java 8 and later versions.

**Respuesta Correcta:** 1

**Explicación:** Yes, a Nested class can be declared private, and it can only be accessed within the enclosing class. This provides additional encapsulation and security.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 262
**Pregunta:** What are the restrictions for a Member Inner class in Java?
**Nivel:** Intermedio

1. Cannot have static methods.
2. Cannot have static variables.
3. Cannot access non-final local variables of the enclosing class.
4. Cannot have a constructor.

**Respuesta Correcta:** 1, 2, 3

**Explicación:** A Member Inner class in Java cannot have static methods, static variables, or access non-final local variables of the enclosing class. However, it can have a constructor.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 263
**Pregunta:** Can a Nested class be abstract in Java?
**Nivel:** Básico

1. Yes, a Nested class can be abstract.
2. No, a Nested class cannot be abstract.
3. Only in Java 8 and later versions.

**Respuesta Correcta:** 1

**Explicación:** Yes, a Nested class can be abstract, just like any other class. An abstract Nested class cannot be instantiated and must be subclassed in order to be used.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 265
**Pregunta:** Can a Nested class be static and non-static both at the same time in Java?
**Nivel:** Básico

1. No, a Nested class cannot be static and non-static both at the same time.
2. Yes, a Nested class can be static and non-static both at the same time.
3. Only in Java 8 and later versions.

**Respuesta Correcta:** 1

**Explicación:** No, a Nested class cannot be static and non-static both at the same time. A Nested class must be either static or non-static, but not both.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 266
**Pregunta:** How does the access of a Local Inner class change, if it is declared inside a static method?
**Nivel:** Intermedio

1. The access remains the same, it can still access non-final local variables of the enclosing class.
2. The access is limited, it cannot access non-final local variables of the enclosing class.
3. The access is increased, it can access private members of the enclosing class.

**Respuesta Correcta:** 2

**Explicación:** If a Local Inner class is declared inside a static method, its access is limited and it cannot access non-final local variables of the enclosing class. This is because local variables are stored on the stack, which is not accessible from within a static method.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 267
**Pregunta:** What is the difference between a Member Inner class and a Local Inner class in Java?
**Nivel:** Intermedio

1. A Member Inner class can access non-final local variables of the enclosing class, while a Local Inner class cannot.
2. A Member Inner class cannot access non-final local variables of the enclosing class, while a Local Inner class can.
3. There is no difference, both terms refer to the same thing.

**Respuesta Correcta:** 1

**Explicación:** The main difference between a Member Inner class and a Local Inner class is that a Member Inner class can access non-final local variables of the enclosing class, while a Local Inner class cannot. A Local Inner class is declared inside a method and can only access final local variables of the enclosing class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 268
**Pregunta:** Can a Nested class be used as a top-level class in Java?
**Nivel:** Básico

1. Yes, a Nested class can be used as a top-level class.
2. No, a Nested class cannot be used as a top-level class.
3. Only in Java 8 and later versions.

**Respuesta Correcta:** 2

**Explicación:** No, a Nested class cannot be used as a top-level class in Java. A Nested class must be declared inside another class, and cannot exist on its own.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 269
**Pregunta:** What is the meaning of Immutable in the context of String class in Java?
**Nivel:** Básico

1. The value of a String object cannot be changed once it is created.
2. The value of a String object can be changed once it is created.
3. The value of a String object can only be changed by creating a new object.

**Respuesta Correcta:** 1

**Explicación:** In the context of the String class in Java, Immutable means that the value of a String object cannot be changed once it is created.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 270
**Pregunta:** Why is a String object considered immutable in Java?
**Nivel:** Avanzado

1. To increase the security of String objects.
2. To increase the performance of String operations.
3. To make it easier to share String objects between different parts of an application.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** A String object is considered immutable in Java for all of the above reasons. Immutable Strings increase the security of String objects, improve the performance of String operations, and make it easier to share String objects between different parts of an application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 271
**Pregunta:** How many objects does the following code create?<br>String s1 = "hello";<br>String s2 = "hello";
**Nivel:** Intermedio

1. 2 objects
2. 1 object
3. 3 objects
4. 4 objects

**Respuesta Correcta:** 2

**Explicación:** The following code creates 2 objects, s1 and s2.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 273
**Pregunta:** How many objects does the following code create?<br>String s1 = new String("hello");<br>String s2 = new String("hello");
**Nivel:** Intermedio

1. 2 objects
2. 1 object
3. 3 objects
4. 4 objects

**Respuesta Correcta:** 1

**Explicación:** The following code creates 2 objects, s1 and s2.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 275
**Pregunta:** Why does Java use the String literal concept?
**Nivel:** Avanzado

1. To make it easier to create and manipulate string objects.
2. To conserve memory and improve performance.
3. To make it easier to share string objects between different parts of an application.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** Java uses the String literal concept for all of the above reasons. String literals make it easier to create and manipulate string objects, conserve memory and improve performance, and make it easier to share string objects between different parts of an application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 276
**Pregunta:** What is the basic difference between a String and StringBuffer object?
**Nivel:** Intermedio

1. A String object is immutable, while a StringBuffer object is mutable.
2. A StringBuffer object is immutable, while a String object is mutable.
3. There is no difference, both are the same.

**Respuesta Correcta:** 1

**Explicación:** The basic difference between a String and StringBuffer object is that a String object is immutable, while a StringBuffer object is mutable. This means that the contents of a String object cannot be changed, while the contents of a StringBuffer object can be changed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 277
**Pregunta:** How will you create an immutable class in Java?
**Nivel:** Intermedio

1. By declaring all variables as final and private.
2. By declaring all variables as public and non-final.
3. By declaring all variables as protected and non-final.
4. By declaring all variables as private and non-final.

**Respuesta Correcta:** 1

**Explicación:** To create an immutable class in Java, you must declare all variables as final and private. This ensures that the contents of the class cannot be changed once it is created.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 278
**Pregunta:** What is the use of the toString() method in Java?
**Nivel:** Básico

1. To return a string representation of an object.
2. To convert an object to a string.
3. To return the memory address of an object.

**Respuesta Correcta:** 1

**Explicación:** The toString() method in Java is used to return a string representation of an object. This method is commonly overridden in custom classes to provide a meaningful string representation of the object for debugging or logging purposes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 279
**Pregunta:** Arrange the three classes String, StringBuffer and StringBuilder in the order of efficiency for String processing operations?
**Nivel:** Básico

1. StringBuilder, StringBuffer, String
2. String, StringBuffer, StringBuilder
3. String, StringBuilder, StringBuffer
4. StringBuffer, String, StringBuilder

**Respuesta Correcta:** 3

**Explicación:** The order of efficiency for String processing operations is String, StringBuilder, StringBuffer. String is the most efficient for simple string operations, but is immutable. StringBuilder and StringBuffer are less efficient than String, but are mutable and can be more efficient for complex string operations.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 281
**Pregunta:** What is the difference between a String and a StringBuilder in Java?
**Nivel:** Intermedio

1. A String is immutable, while a StringBuilder is mutable.
2. A StringBuilder is immutable, while a String is mutable.
3. There is no difference, both are the same.

**Respuesta Correcta:** 1

**Explicación:** The main difference between a String and a StringBuilder in Java is that a String is immutable, while a StringBuilder is mutable. This means that the contents of a String object cannot be changed, while the contents of a StringBuilder object can be changed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 284
**Pregunta:** What is the use of the trim() method in Java for the String class?
**Nivel:** Básico

1. To remove leading and trailing whitespace from a string.
2. To add leading and trailing whitespace to a string.
3. To replace all whitespace in a string with a different character.

**Respuesta Correcta:** 1

**Explicación:** The trim() method in Java for the String class is used to remove leading and trailing whitespace from a string. For example, String s = " Hello World ".trim(); will create a new string s with the contents "Hello World".

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 292
**Pregunta:** What is the base class for Error and Exception classes in Java?
**Nivel:** Básico

1. Throwable
2. Exception
3. Error

**Respuesta Correcta:** 1

**Explicación:** The base class for Error and Exception classes in Java is Throwable. Error and Exception classes are both subclasses of Throwable and are used to represent different types of errors and exceptional conditions in a program.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 301
**Pregunta:** When we override a method in a Child class, can we throw an additional Exception that is not thrown by the Parent class method?
**Nivel:** Básico

1. Yes
2. No
3. nan

**Respuesta Correcta:** 1

**Explicación:** Yes, we can throw an additional Exception that is not thrown by the Parent class method when we override a method in a Child class. This is because the Child class method must either declare the same exceptions as the Parent class method, or a subset of them, or it can declare additional exceptions.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 320
**Pregunta:** In Java, is it possible to lock an object for exclusive use by a thread?
**Nivel:** Avanzado

1. Yes, in Java, it is possible to lock an object for exclusive use by a thread using the synchronized keyword or by using the java.util.concurrent.locks package.
2. No, in Java, it is not possible to lock an object for exclusive use by a thread.
3. It depends on the implementation of the thread.

**Respuesta Correcta:** 1

**Explicación:** Yes, in Java, it is possible to lock an object for exclusive use by a thread using the synchronized keyword or by using the java.util.concurrent.locks package. The synchronized keyword can be used to synchronize the access to a shared resource, ensuring that only one thread can access the resource at a time. The java.util.concurrent.locks package provides a more flexible and powerful mechanism for locking and synchronization in Java.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 343
**Pregunta:** How does hashCode() method work in Java?
**Nivel:** Intermedio

1. It returns a unique identifier for an object based on its contents.
2. It returns a unique identifier for an object based on its reference.
3. It returns a unique identifier for an object based on its class.

**Respuesta Correcta:** 1

**Explicación:** The hashCode() method returns a unique identifier for an object based on its contents. This allows objects to be stored and retrieved efficiently in data structures like HashMap and HashSet.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 350
**Pregunta:** What is the use of the Collections class in Java?
**Nivel:** Básico

1. It provides utility methods for working with collections.
2. It provides methods for creating collections.
3. It provides methods for sorting collections.

**Respuesta Correcta:** 1

**Explicación:** The Collections class provides utility methods for working with collections, such as sorting, searching, and shuffling. This makes it easier to perform common operations on collections.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 358
**Pregunta:** What is System class?
**Nivel:** Básico

1. The System class is a class in Java that provides access to system-level resources, such as standard input and output streams, environment variables, and the current time.
2. The System class is a class in Java that provides access to platform-level resources, such as files and directories.
3. The System class is a class in Java that provides access to application-level resources, such as classes and methods.

**Respuesta Correcta:** 1

**Explicación:** The System class is a class in Java that provides access to system-level resources, such as standard input and output streams, environment variables, and the current time. This allows you to perform common system-level operations in your Java programs.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 363
**Pregunta:** What is the difference between Singleton class and Static class?
**Nivel:** Intermedio

1. A Singleton class can only have one instance, while a Static class can have multiple instances.
2. A Static class can only have one instance, while a Singleton class can have multiple instances.
3. Both Singleton class and Static class can only have one instance.

**Respuesta Correcta:** 1

**Explicación:** A Singleton class can only have one instance, while a Static class can have multiple instances. This means that you can use the Singleton class to enforce a single instance of a class in your Java programs, while you can use the Static class to provide class-level methods and properties that are shared by all instances of the class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 365
**Pregunta:** What are the main benefits of Collections Framework in Java?
**Nivel:** Avanzado

1. The main benefits of Collections Framework in Java are improved performance, increased flexibility, and reduced code complexity.
2. The main benefits of Collections Framework in Java are reduced performance, decreased flexibility, and increased code complexity.
3. The main benefits of Collections Framework in Java are increased performance, decreased flexibility, and reduced code complexity.

**Respuesta Correcta:** 1

**Explicación:** The main benefits of Collections Framework in Java are improved performance, increased flexibility, and reduced code complexity. This means that Collections Framework provides a way to efficiently store and manipulate groups of objects, with a simplified API that reduces the amount of code you need to write.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 368
**Pregunta:** What are the Thread-safe classes in Java Collections framework?
**Nivel:** Básico

1. The thread-safe classes in Java Collections framework are Vector, Hashtable, and synchronized wrapper classes.
2. The thread-safe classes in Java Collections framework are ArrayList, HashMap, and unsynchronized wrapper classes.
3. The thread-safe classes in Java Collections framework are List, Map, and synchronized collection classes.

**Respuesta Correcta:** 1

**Explicación:** The thread-safe classes in Java Collections framework are Vector, Hashtable, and synchronized wrapper classes. This means that these classes are designed to be used in multithreaded environments, and provide synchronized access to their data to prevent data corruption or inconsistent results.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 389
**Pregunta:** What is the reason for overriding equals() method?
**Nivel:** Intermedio

1. To compare the contents of two objects.
2. To compare the memory locations of two objects.
3. To compare the hashcodes of two objects.

**Respuesta Correcta:** 1

**Explicación:** The equals() method is used to compare the contents of two objects. By default, the equals() method in Java compares the memory locations of two objects. However, it can be overridden to compare the contents of two objects, making it easier to determine if two objects are equal.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 397
**Pregunta:** Which methods do we need to override to use an object as key in a HashMap?
**Nivel:** Intermedio

1. hashCode()
2. equals()
3. toString()
4. compareTo()

**Respuesta Correcta:** 1, 2

**Explicación:** To use an object as a key in a HashMap, we need to override the hashCode() and equals() methods. The hashCode() method is used to determine the bucket location for storing the key-value pair, while the equals() method is used to compare the keys for equality.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 398
**Pregunta:** How will you reverse a List in Java?
**Nivel:** Intermedio

1. By using the reverse() method of the Collections class.
2. By using the sort() method of the Collections class.
3. By using the reverseOrder() method of the Comparator interface.

**Respuesta Correcta:** 1

**Explicación:** To reverse a List in Java, you can use the reverse() method of the Collections class. This method takes a List as an argument and returns a reversed version of the List.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 404
**Pregunta:** What is the increasing order of performance for following collection classes in Java?
**Nivel:** Avanzado

1. ArrayList, LinkedList, Vector
2. Vector, LinkedList, ArrayList
3. LinkedList, ArrayList, Vector

**Respuesta Correcta:** 1

**Explicación:** The increasing order of performance for the collection classes in Java is ArrayList, LinkedList, and Vector. ArrayList is the fastest, followed by LinkedList, and Vector is the slowest due to its synchronized nature.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 410
**Pregunta:** How is TreeMap class implemented in Java?
**Nivel:** Intermedio

1. TreeMap is implemented as a Red-Black tree.
2. TreeMap is implemented as a Binary Search Tree.
3. TreeMap is implemented as a Heap.

**Respuesta Correcta:** 1

**Explicación:** The TreeMap class in Java is implemented as a Red-Black tree. A Red-Black tree is a type of self-balancing binary search tree, where each node has a color attribute, either red or black, and the tree satisfies certain properties to ensure that the height of the tree is logarithmic in the number of nodes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 413
**Pregunta:** What is the importance of hashCode() and equals() methods?
**Nivel:** Intermedio

1. The hashCode() and equals() methods are used to determine object equality and to store objects in collections such as HashMap and HashSet.
2. The hashCode() and equals() methods are used to determine object identity and to store objects in collections such as ArrayList and LinkedList.
3. The hashCode() and equals() methods are used to determine object size and to store objects in collections such as Stack and Queue.

**Respuesta Correcta:** 1

**Explicación:** The hashCode() and equals() methods are important in Java because they are used to determine object equality and to store objects in collections such as HashMap and HashSet. The hashCode() method is used to determine the hash code of an object, which is used to index the object in a collection, while the equals() method is used to compare two objects for equality.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 414
**Pregunta:** What is the contract of hashCode() and equals() methods in Java?
**Nivel:** Intermedio

1. The hashCode() method should return the same value for two equal objects, and the equals() method should return true for two objects with the same hash code.
2. The hashCode() method should return a different value for two equal objects, and the equals() method should return false for two objects with the same hash code.
3. The hashCode() method should return a random value, and the equals() method should return true for all objects.

**Respuesta Correcta:** 1

**Explicación:** The contract of the hashCode() and equals() methods in Java is that the hashCode() method should return the same value for two equal objects, and the equals() method should return true for two objects with the same hash code. This ensures that objects that are equal are stored in the same bucket in collections such as HashMap and HashSet, and can be retrieved and compared efficiently.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 417
**Pregunta:** How will you convert a Collection to SynchronizedCollection in Java?
**Nivel:** Intermedio

1. By using the synchronizedCollection() method of the Collections class.
2. By using the synchronizedList() method of the Collections class.
3. By using the synchronizedMap() method of the Collections class.

**Respuesta Correcta:** 1

**Explicación:** You can convert a Collection to a SynchronizedCollection in Java by using the synchronizedCollection() method of the Collections class. The synchronizedCollection() method returns a thread-safe Collection backed by the specified Collection. All access to the Collection is synchronized, ensuring that multiple threads can access the Collection simultaneously without data inconsistencies or race conditions.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 418
**Pregunta:** How IdentityHashMap is different from a regular Map in Java?
**Nivel:** Intermedio

1. IdentityHashMap uses the == operator to compare keys, while a regular Map uses the equals() method to compare keys.
2. IdentityHashMap uses the equals() method to compare keys, while a regular Map uses the == operator to compare keys.
3. IdentityHashMap and a regular Map both use the == operator to compare keys.

**Respuesta Correcta:** 1

**Explicación:** IdentityHashMap is different from a regular Map in Java because it uses the == operator to compare keys, while a regular Map uses the equals() method to compare keys. This means that two keys are considered equal in an IdentityHashMap if they are the same object, while in a regular Map they are considered equal if they have the same value.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 419
**Pregunta:** What is the main use of IdentityHashMap?
**Nivel:** Intermedio

1. The main use of IdentityHashMap is to map the identity of objects, rather than their value.
2. The main use of IdentityHashMap is to map the value of objects, rather than their identity.
3. The main use of IdentityHashMap is to map both the identity and value of objects.

**Respuesta Correcta:** 1

**Explicación:** The main use of IdentityHashMap in Java is to map the identity of objects, rather than their value. This makes IdentityHashMap suitable for use cases where the == operator is used to compare keys, rather than the equals() method.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 423
**Pregunta:** How can you make a Collection class read-only in Java?
**Nivel:** Intermedio

1. By using the unmodifiableCollection() method of the Collections class.
2. By using the synchronizedCollection() method of the Collections class.
3. By using the readOnlyCollection() method of the Collections class.

**Respuesta Correcta:** 1

**Explicación:** You can make a Collection class read-only in Java by using the unmodifiableCollection() method of the Collections class. The unmodifiableCollection() method returns a Collection that cannot be modified. Attempts to modify the Collection result in an UnsupportedOperationException being thrown.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 427
**Pregunta:** How will you create an empty Map in Java?
**Nivel:** Intermedio

1. By using the emptyMap() method of the Collections class.
2. By using the newMap() method of the Collections class.
3. By using the emptyList() method of the Collections class.

**Respuesta Correcta:** 1

**Explicación:** You can create an empty Map in Java by using the emptyMap() method of the Collections class. The emptyMap() method returns an empty Map, which cannot be modified. Attempts to modify the Map result in an UnsupportedOperationException being thrown.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 429
**Pregunta:** Between an Array and ArrayList, which one is the preferred collection for storing objects?
**Nivel:** Básico

1. ArrayList is the preferred collection for storing objects, because it is dynamic and resizable, while an Array is fixed-size.
2. Array is the preferred collection for storing objects, because it is efficient and fast, while an ArrayList is slow and has overhead.
3. Both Array and ArrayList are equally preferred for storing objects, depending on the specific requirements of the application.

**Respuesta Correcta:** 1

**Explicación:** ArrayList is the preferred collection for storing objects, because it is dynamic and resizable, while an Array is fixed-size. ArrayList provides a dynamic and flexible data structure for storing objects, allowing elements to be added, removed, and modified dynamically, without the need to create a new Array. On the other hand, an Array is a fixed-size data structure that is efficient and fast, but does not provide the same level of flexibility as an ArrayList.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 435
**Pregunta:** How can we create a Map with reverse view and lookup in Java?
**Nivel:** Intermedio

1. By using the reverseOrder() method of the Collections class to create a reverse view of the Map, and then using the TreeMap constructor to create a TreeMap that is sorted in reverse order.
2. By using the reverse() method of the Collections class to create a reverse view of the Map, and then using the HashMap constructor to create a HashMap that is sorted in reverse order.
3. By using the reverse() method of the Map class to create a reverse view of the Map, and then using the LinkedHashMap constructor to create a LinkedHashMap that is sorted in reverse order.

**Respuesta Correcta:** 1

**Explicación:** You can create a Map with reverse view and lookup in Java by using the reverseOrder() method of the Collections class to create a reverse view of the Map, and then using the TreeMap constructor to create a TreeMap that is sorted in reverse order. The reverseOrder() method returns a Comparator that can be used to sort the Map in reverse order, while the TreeMap constructor creates a Map that is sorted based on the Comparator.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 436
**Pregunta:** How will you create a shallow copy of a Map?
**Nivel:** Intermedio

1. By using the clone() method of the Map class to create a shallow copy of the Map.
2. By using the copyOf() method of the Map class to create a shallow copy of the Map.
3. By using the copyOfRange() method of the Arrays class to create a shallow copy of the Map.

**Respuesta Correcta:** 1

**Explicación:** You can create a shallow copy of a Map in Java by using the clone() method of the Map class. The clone() method creates a shallow copy of the Map, which means that the new Map will refer to the same objects as the original Map, but will be a separate instance.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 438
**Pregunta:** What is a PriorityQueue in Java?
**Nivel:** Básico

1. A PriorityQueue is a collection class in Java that provides a priority-based ordering of elements, where elements are ordered according to their priority.
2. A PriorityQueue is a collection class in Java that provides a random-based ordering of elements, where elements are ordered randomly.
3. A PriorityQueue is a collection class in Java that provides a time-based ordering of elements, where elements are ordered according to the time they were added.

**Respuesta Correcta:** 1

**Explicación:** A PriorityQueue is a collection class in Java that provides a priority-based ordering of elements, where elements are ordered according to their priority. The elements in a PriorityQueue are ordered according to their natural ordering, or according to a Comparator that is provided at the time the PriorityQueue is created. The highest-priority element is always at the head of the queue, and can be retrieved using the poll() or remove() methods.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 460
**Pregunta:** What is the significance of the hashCode() method in Java Collections Framework?
**Nivel:** Básico

1. The hashCode() method is used to determine the hash value of an object, which is used to efficiently store and retrieve elements in a HashMap.
2. The hashCode() method is used to compare two objects to determine if they are equal.
3. The hashCode() method is used to convert an object to a string representation.

**Respuesta Correcta:** 1

**Explicación:** The hashCode() method is used to determine the hash value of an object, which is used to efficiently store and retrieve elements in a HashMap. The hash value of an object is used as an index in the hash table where the object is stored. When retrieving an object, the hash value is used to quickly locate the object in the hash table.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 466
**Pregunta:** What are the different types of Collection classes in Java and what are their use cases?
**Nivel:** Básico

1. ArrayList: dynamic-sized array for storing elements in a specific order
2. LinkedList: doubly linked list for fast add and remove operations
3. HashMap: hash table for fast lookup and add operations based on keys
4. TreeMap: balanced binary search tree for sorted elements based on keys

**Respuesta Correcta:** 1,2,3,4

**Explicación:** ArrayList is a dynamic-sized array for storing elements in a specific order. LinkedList is a doubly linked list for fast add and remove operations. HashMap is a hash table for fast lookup and add operations based on keys. TreeMap is a balanced binary search tree for sorted elements based on keys.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 472
**Pregunta:** What is the purpose of join() method in Thread class?
**Nivel:** Básico

1. The purpose of join() method in Thread class is to wait for a Thread to complete its execution.
2. The purpose of join() method in Thread class is to start a Thread.
3. The purpose of join() method in Thread class is to interrupt a Thread.

**Respuesta Correcta:** 1

**Explicación:** The purpose of join() method in Thread class is to wait for a Thread to complete its execution. When you call join() on a Thread, the currently executing thread will wait until the Thread on which join() is called completes its execution.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 481
**Pregunta:** What is the purpose of Synchronized block in Java?
**Nivel:** Básico

1. The purpose of a Synchronized block in Java is to lock an object or a section of code so that only one Thread can access it at a time.
2. The purpose of a Synchronized block in Java is to allow multiple Threads to access an object or a section of code simultaneously.
3. The purpose of a Synchronized block in Java is to prevent access to an object or a section of code.

**Respuesta Correcta:** 1

**Explicación:** The purpose of a Synchronized block in Java is to lock an object or a section of code so that only one Thread can access it at a time. This helps to prevent problems such as race conditions and other forms of corruption that can occur when multiple Threads access the same resources simultaneously.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 505
**Pregunta:** Can we mark a constructor as synchronized in Java?
**Nivel:** Básico

1. No
2. Yes
3. Depends on the situation

**Respuesta Correcta:** 2

**Explicación:** Yes, a constructor in Java can be marked as synchronized. This ensures that only one thread can create an instance of the class at a time, preventing data corruption and ensuring thread-safety.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 520
**Pregunta:** Which two methods of Object class can be used to implement a Producer Consumer scenario?
**Nivel:** Intermedio

1. wait() and notifyAll()
2. wait() and notify()
3. sleep() and notifyAll()
4. sleep() and notify()

**Respuesta Correcta:** 1

**Explicación:** The wait() and notify() methods of the Object class can be used to implement a Producer Consumer scenario. The wait() method is used to block a thread until a certain condition is met, and the notify() method is used to wake up a thread that is waiting. These methods are used to coordinate the behavior of multiple threads and ensure that the program runs smoothly.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 523
**Pregunta:** How can we check if a thread has a monitor lock on a given object?
**Nivel:** Intermedio

1. By using the isAlive() method of the Thread class.
2. By using the getState() method of the Thread class.
3. By using the holdsLock() method of the Thread class.

**Respuesta Correcta:** 3

**Explicación:** We can check if a thread has a monitor lock on a given object by using the holdsLock() method of the Thread class. This method returns true if the current thread holds the monitor lock on the specified object, and false otherwise.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 524
**Pregunta:** What is the use of yield() method in Thread class?
**Nivel:** Básico

1. To cause the current thread to pause execution temporarily.
2. To cause the current thread to pause execution permanently.
3. To cause the current thread to terminate.
4. To cause the current thread to yield control to other threads of the same priority.

**Respuesta Correcta:** 4

**Explicación:** The yield() method of the Thread class is used to cause the current thread to yield control to other threads of the same priority. This method can be used to improve the responsiveness and fairness of a program by allowing lower-priority threads to execute more frequently.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 526
**Pregunta:** What are the rules for creating Immutable Objects?
**Nivel:** Básico

1. All fields should be final and private.
2. The class should not have any setters.
3. The class should be final.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** To create an Immutable Object, all fields should be final and private, the class should not have any setters, and the class should be final. These rules ensure that the state of the object cannot be modified after it has been created, making it easier to reason about the behavior of the program and reducing the risk of bugs.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 527
**Pregunta:** What is the use of ThreadLocal class?
**Nivel:** Básico

1. To store values that are associated with a specific thread.
2. To store values that are shared between all threads.
3. To store values that are associated with a specific process.

**Respuesta Correcta:** 1

**Explicación:** The ThreadLocal class is used to store values that are associated with a specific thread. This allows each thread to have its own private copy of the value, improving the thread-safety and scalability of the program.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 528
**Pregunta:** What are the scenarios suitable for using ThreadLocal class?
**Nivel:** Básico

1. When you need to store values that are associated with a specific thread.
2. When you need to store values that are shared between all threads.
3. When you need to store values that are associated with a specific process.

**Respuesta Correcta:** 1

**Explicación:** The ThreadLocal class is suitable for use in scenarios where you need to store values that are associated with a specific thread. For example, you might use ThreadLocal to store a transaction ID, user ID, or other information that is specific to the current thread.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 536
**Pregunta:** Which technique is used in ReadWriteLock class for reducing Lock contention?
**Nivel:** Avanzado

1. Finer-grained locks.
2. Coarser-grained locks.
3. Lock-free algorithms.
4. Lock-based algorithms.

**Respuesta Correcta:** 1

**Explicación:** The ReadWriteLock class uses finer-grained locks to reduce lock contention. This means that instead of using a single lock to protect the entire shared memory region, multiple locks are used to protect smaller regions of memory. This can help to reduce the frequency and duration of lock contention, improving the performance and responsiveness of the program.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 540
**Pregunta:** Is it always possible to improve performance by object pooling in a multi-threading application?
**Nivel:** Avanzado

1. No, it is not always possible to improve performance by object pooling in a multi-threading application.
2. Yes, it is always possible to improve performance by object pooling in a multi-threading application.
3. It depends on the implementation of object pooling.

**Respuesta Correcta:** 1

**Explicación:** No, it is not always possible to improve performance by object pooling in a multi-threading application. Object pooling can help to reduce the overhead of creating and destroying objects, but it also requires synchronization to ensure that the objects are used correctly by multiple threads. If the synchronization overhead outweighs the benefits of object pooling, the performance may actually degrade in a multi-threading application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 541
**Pregunta:** How can techniques used for performance improvement in a single thread application may degrade the performance in a multi-threading application?
**Nivel:** Avanzado

1. By increasing the amount of synchronization required to coordinate the actions of multiple threads.
2. By reducing the amount of synchronization required to coordinate the actions of multiple threads.
3. By increasing the number of objects created and destroyed.

**Respuesta Correcta:** 1

**Explicación:** Techniques used for performance improvement in a single thread application may degrade the performance in a multi-threading application by increasing the amount of synchronization required to coordinate the actions of multiple threads. For example, object pooling can help to reduce the overhead of creating and destroying objects, but it also requires synchronization to ensure that the objects are used correctly by multiple threads. If the synchronization overhead outweighs the benefits of object pooling, the performance may actually degrade in a multi-threading application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 545
**Pregunta:** How will you create a Thread pool in Java?
**Nivel:** Intermedio

1. By using the Executors class.
2. By using the Executor interface.
3. By using the ThreadPoolExecutor class.

**Respuesta Correcta:** 1

**Explicación:** You can create a Thread pool in Java by using either the Executors class or the ThreadPoolExecutor class. The Executors class provides convenient factory methods for creating various types of ExecutorService objects, including thread pools. The ThreadPoolExecutor class provides a more flexible way to create and configure a thread pool, allowing you to specify the size of the pool, the size of the work queue, and the behavior of the pool when it is full.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 549
**Pregunta:** How will you create synchronized instance of List or Map Collection?
**Nivel:** Intermedio

1. By using the synchronizedList() or synchronizedMap() method of the Collections class.
2. By using the synchronized keyword when accessing the list or map.
3. By using the synchronizedList() or synchronizedMap() method of the Arrays class.

**Respuesta Correcta:** 1

**Explicación:** You can create a synchronized instance of a List or Map collection by using the synchronizedList() or synchronizedMap() method of the Collections class. These methods return a thread-safe version of the specified list or map, respectively. The returned collection implements all of the optional list or map operations, and is thread-safe.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 554
**Pregunta:** What is the difference between RecursiveTask and RecursiveAction class?
**Nivel:** Intermedio

1. RecursiveTask returns a value, while RecursiveAction does not.
2. RecursiveAction returns a value, while RecursiveTask does not.
3. Both classes return a value.
4. Neither class returns a value.

**Respuesta Correcta:** 1

**Explicación:** RecursiveTask returns a value, while RecursiveAction does not. This makes RecursiveTask suitable for tasks that need to return a result, while RecursiveAction is used for tasks that do not return a result.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 557
**Pregunta:** How Stack and Heap work in Java multi-threading environment?
**Nivel:** Intermedio

1. Each thread has its own Stack and Heap.
2. All threads share a single Stack and Heap.
3. Stack is shared among threads, while Heap is not.
4. Heap is shared among threads, while Stack is not.

**Respuesta Correcta:** 1

**Explicación:** In Java's multi-threading environment, each thread has its own Stack and Heap. Stack is used to store method invocations and local variables, while Heap is used to store objects and instance variables. This helps prevent data corruption and race conditions.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 561
**Pregunta:** What is a ThreadLocalRandom class in Java?
**Nivel:** Básico

1. A random number generator that is local to a thread.
2. A random number generator that is global to all threads.
3. A random number generator that is only used in parallel streams.

**Respuesta Correcta:** 1

**Explicación:** The ThreadLocalRandom class is a random number generator that is local to a thread. This means that each thread has its own instance of ThreadLocalRandom, which helps prevent race conditions and data corruption.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 562
**Pregunta:** What is the difference between a synchronized method and a synchronized block in Java?
**Nivel:** Intermedio

1. A synchronized method locks the entire object, while a synchronized block only locks the specified section of code.
2. A synchronized block locks the entire object, while a synchronized method only locks the specified section of code.
3. Both a synchronized method and a synchronized block lock the entire object.
4. Neither a synchronized method nor a synchronized block lock the entire object.

**Respuesta Correcta:** 1

**Explicación:** A synchronized method locks the entire object, while a synchronized block only locks the specified section of code. This allows for more fine-grained control over synchronization in Java.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 608
**Pregunta:** How can we get duration between two dates or time in Java?
**Nivel:** Intermedio

1. By using the Duration class in the new Date and Time API.
2. By using the legacy Date class in the old Date/Time API.
3. By using a third-party library.

**Respuesta Correcta:** 1

**Explicación:** We can get the duration between two dates or time in Java by using the Duration class in the new Date and Time API. The Duration class provides a way to represent and manipulate durations of time, and can be used to calculate the difference between two dates or times.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 618
**Pregunta:** How can you get the name of a Parameter in Java by using reflection?
**Nivel:** Intermedio

1. By using the getName() method of the Parameter class.
2. By using the getDeclaredMethods() method of the Class class.
3. By using the getFields() method of the Class class.

**Respuesta Correcta:** 1

**Explicación:** You can get the name of a Parameter in Java by using the getName() method of the Parameter class. The Parameter class is part of the Java Reflection API, and provides information about the parameters of a method or constructor.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 619
**Pregunta:** What is Optional in Java?
**Nivel:** Básico

1. Optional is a container object which may or may not contain a non-null value.
2. Optional is a container object which may contain a null value.
3. Optional is a container object which must contain a non-null value.

**Respuesta Correcta:** 1

**Explicación:** Optional is a container object which may or may not contain a non-null value. It is part of the Java 8 functional programming features, and provides a way to represent optional values without the need for null checks.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 621
**Pregunta:** Which method in Optional provides the fallback mechanism in case of a null value?
**Nivel:** Básico

1. The orElse() method provides the fallback mechanism in case of a null value.
2. The get() method provides the fallback mechanism in case of a null value.
3. The orElseGet() method provides the fallback mechanism in case of a null value.
4. The orElseThrow() method provides the fallback mechanism in case of a null value.

**Respuesta Correcta:** 1

**Explicación:** The orElse() method provides the fallback mechanism in case of a null value. The orElse() method returns the value contained in the Optional object if it is present, or returns the specified default value if it is not.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 624
**Pregunta:** How can we analyze the dependencies in Java classes and packages?
**Nivel:** Intermedio

1. By using a class diagram.
2. By using a package diagram.
3. By using a dependency diagram.

**Respuesta Correcta:** 2

**Explicación:** By using a package diagram. A package diagram is a UML diagram that shows the relationships between packages in a system. It can be used to analyze the dependencies between packages and classes, and to identify potential areas for refactoring or improvement.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 630
**Pregunta:** Can we use multiple main methods in multiple classes?
**Nivel:** Básico

1. Yes, we can use multiple main methods in multiple classes.
2. No, we cannot use multiple main methods in multiple classes.
3. It depends on the version of Java being used.

**Respuesta Correcta:** 1

**Explicación:** Yes, we can use multiple main methods in multiple classes. In Java, a class can have a main method, and multiple classes can have their own main method. When the program is executed, we can specify which main method to run by passing the class name as an argument to the java command.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 631
**Pregunta:** Does Java allow you to override a private or static method?
**Nivel:** Básico

1. No, Java does not allow you to override a private or static method.
2. Yes, Java allows you to override a private method.
3. Yes, Java allows you to override a static method.
4. Both B and C.

**Respuesta Correcta:** 1

**Explicación:** No, Java does not allow you to override a private or static method. In Java, private and static methods are not inherited by subclasses, and cannot be overridden.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 632
**Pregunta:** What happens when you put a key object in a HashMap that is already present?
**Nivel:** Básico

1. The key object will be replaced by the new value.
2. The value associated with the key object will be appended to the new value.
3. The value associated with the key object will be overwritten by the new value.

**Respuesta Correcta:** 3

**Explicación:** The value associated with the key object will be overwritten by the new value. In Java, when you put a key object in a HashMap that is already present, the new value will overwrite the old value associated with the key.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 638
**Pregunta:** How can you access a non-static variable from the static context?
**Nivel:** Intermedio

1. By creating an instance of the class and accessing the variable through the instance.
2. By using the this keyword.
3. By using the class name and the dot operator.

**Respuesta Correcta:** 1

**Explicación:** By creating an instance of the class and accessing the variable through the instance. In Java, you can access a non-static variable from a static context by creating an instance of the class and accessing the variable through the instance.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 642
**Pregunta:** What is the difference between sleep() and wait() methods in Java?
**Nivel:** Intermedio

1. The sleep() method puts a thread to sleep for a specified amount of time, while the wait() method releases the lock held by a thread and waits for another thread to complete its execution.
2. The sleep() method releases the lock held by a thread and waits for another thread to complete its execution, while the wait() method puts a thread to sleep for a specified amount of time.
3. The sleep() method is a static method of the Thread class, while the wait() method is an instance method of the Object class.
4. Both sleep() and wait() methods are equivalent and can be used interchangeably.

**Respuesta Correcta:** 1

**Explicación:** The sleep() method puts a thread to sleep for a specified amount of time, while the wait() method releases the lock held by a thread and waits for another thread to complete its execution. The sleep() method is a static method of the Thread class and is used to pause the execution of a thread for a specified amount of time. The wait() method, on the other hand, is an instance method of the Object class and is used to release the lock held by a thread and wait for another thread to complete its execution.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 643
**Pregunta:** Can you create an Immutable object that contains a mutable object?
**Nivel:** Intermedio

1. No, you cannot create an Immutable object that contains a mutable object.
2. Yes, you can create an Immutable object that contains a mutable object.
3. It depends on the implementation.

**Respuesta Correcta:** 2

**Explicación:** Yes, you can create an Immutable object that contains a mutable object. However, you need to take care that the mutable object is not accessible from outside the Immutable object. For example, you can store a mutable object as a private field in an Immutable object and provide only accessor methods for it. This way, the mutable object can be changed only from within the Immutable object, and not from outside.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 655
**Pregunta:** When creating an abstract class, is it a good idea to call abstract methods inside its constructor?
**Nivel:** Básico

1. No, it is not a good idea to call abstract methods inside its constructor as it will result in a compile-time error.
2. Yes, it is a good idea to call abstract methods inside its constructor to enforce implementation by subclasses.
3. No, it is not a good idea to call abstract methods inside its constructor as it may lead to unexpected behavior.

**Respuesta Correcta:** 1

**Explicación:** It is not a good idea to call abstract methods inside its constructor as it will result in a compile-time error. Abstract methods are meant to be overridden by subclasses and cannot be called directly.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 656
**Pregunta:** How can you do constructor chaining in Java?
**Nivel:** Intermedio

1. By calling a constructor from another constructor of the same class using the "this" keyword.
2. By calling a constructor from another constructor of the same class using the "super" keyword.
3. By calling a constructor from a method of the same class using the "this" keyword.

**Respuesta Correcta:** 1

**Explicación:** Constructor chaining can be done by calling a constructor from another constructor of the same class using the "this" keyword. This allows for reusing the code from one constructor in another constructor.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 661
**Pregunta:** What is a compile time constant in Java?
**Nivel:** Básico

1. A value that can be evaluated at compile time and is stored as a constant in the class file.
2. A value that can be changed at runtime.
3. A value that can be evaluated at runtime and is stored as a constant in the class file.

**Respuesta Correcta:** 1

**Explicación:** A compile time constant in Java is a value that can be evaluated at compile time and is stored as a constant in the class file. Compile time constants are usually defined using the final keyword and are usually assigned a value at the time of declaration.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 667
**Pregunta:** How do you decide which type of Inner Class – Static or Non-Static to use in Java?
**Nivel:** Intermedio

1. You should use a static inner class if you don't need to access the instance variables and methods of the outer class, while you should use a non-static inner class if you need to access the instance variables and methods of the outer class.
2. You should use a non-static inner class if you don't need to access the instance variables and methods of the outer class, while you should use a static inner class if you need to access the instance variables and methods of the outer class.
3. Both static inner class and non-static inner class can access the instance variables and methods of the outer class.

**Respuesta Correcta:** 1

**Explicación:** You should use a static inner class if you don't need to access the instance variables and methods of the outer class, while you should use a non-static inner class if you need to access the instance variables and methods of the outer class. A static inner class is not associated with an instance of the outer class and does not have access to its instance variables and methods. A non-static inner class, on the other hand, is associated with an instance of the outer class and has access to its instance variables and methods.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 668
**Pregunta:** What are the different types of Classloaders in Java?
**Nivel:** Básico

1. Bootstrap, Extension, System, and Application Classloaders.
2. Bootstrap, Extension, System, Application, and Custom Classloaders.
3. Bootstrap, Extension, System, Application, and Dynamic Classloaders.
4. Bootstrap, Extension, System, and Dynamic Classloaders.

**Respuesta Correcta:** 1

**Explicación:** There are four types of Classloaders in Java: Bootstrap, Extension, System, and Application Classloaders. The Bootstrap Classloader loads the Java Core classes and is the parent of the Extension Classloader. The Extension Classloader loads the extension classes, and the System Classloader is used to load the application classes. The Application Classloader is used to load custom classes that are specific to the application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 675
**Pregunta:** What is the difference between the expressions String s = "Temporary" and String s = new String("Temporary")? Which one is better and more efficient?
**Nivel:** Avanzado

1. The first expression creates a new string in the string constant pool, while the second expression creates a new string object on the heap. The first expression is more efficient and is the recommended approach.
2. The first expression creates a new string object on the heap, while the second expression creates a new string in the string constant pool. The second expression is more efficient and is the recommended approach.
3. Both expressions create a new string in the string constant pool.
4. Both expressions create a new string object on the heap.

**Respuesta Correcta:** 1

**Explicación:** The first expression creates a new string in the string constant pool, while the second expression creates a new string object on the heap. The first expression is more efficient and is the recommended approach as it reuses an existing string if one with the same value already exists in the string constant pool, which saves memory and reduces the risk of memory leaks.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 676
**Pregunta:** In Java, can two equal objects have the different hash code?
**Nivel:** Básico

1. No, two equal objects must have the same hash code.
2. Yes, two equal objects can have different hash codes.
3. It depends on the implementation of the hash code method.

**Respuesta Correcta:** 1

**Explicación:** No, two equal objects must have the same hash code. The hashCode() method is used to generate a unique identifier for an object, and if two objects are equal, they must have the same hash code. This is a requirement of the hashCode() method, which is defined in the Object class and is inherited by all objects in Java.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 678
**Pregunta:** Is it ok to use random numbers in the implementation of hashcode() method in Java?
**Nivel:** Intermedio

1. No, it is not recommended to use random numbers in the implementation of the hashCode() method, as this can lead to collisions and reduce the effectiveness of hash-based data structures.
2. Yes, it is recommended to use random numbers in the implementation of the hashCode() method, as this helps to ensure that hash codes are unique and distribute well across the range of possible values.
3. It depends on the specific use case and requirements of the application.

**Respuesta Correcta:** 1

**Explicación:** No, it is not recommended to use random numbers in the implementation of the hashCode() method, as this can lead to collisions and reduce the effectiveness of hash-based data structures. The hashCode() method should generate a unique identifier for an object that is based on the state of the object and is deterministic, meaning that it always returns the same value for a given object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 679
**Pregunta:** Between two types of dependency injections, constructor injection and setter dependency injection, which one is better?
**Nivel:** Básico

1. Constructor injection is considered to be better as it is more secure, provides better encapsulation, and makes it easier to enforce the immutability of objects.
2. Setter dependency injection is considered to be better as it is more flexible, allows for easier testing, and makes it easier to change the dependencies of an object at runtime.
3. Both constructor injection and setter dependency injection have their own advantages and disadvantages, and the choice between them depends on the specific requirements of the application.

**Respuesta Correcta:** 1

**Explicación:** Constructor injection is considered to be better as it is more secure, provides better encapsulation, and makes it easier to enforce the immutability of objects. With constructor injection, dependencies are passed as parameters to the constructor, and the object is fully initialized when it is created. This makes it easier to ensure that objects are properly initialized and that their dependencies are not modified after they are created.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 692
**Pregunta:** What is the advantage of PreparedStatement over Statement class in Java?
**Nivel:** Avanzado

1. PreparedStatement is faster than Statement.
2. PreparedStatement is more flexible than Statement.
3. PreparedStatement provides better security than Statement.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** PreparedStatement provides several advantages over the Statement class, including better performance, greater flexibility, and improved security. PreparedStatements are precompiled, allowing for faster execution, and they also support parameterized queries, which can help prevent SQL injection attacks.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 694
**Pregunta:** What happens to the Exception object after the exception handling is done?
**Nivel:** Básico

1. The Exception object is destroyed.
2. The Exception object is stored in memory for future reference.
3. The Exception object is passed to the calling method.

**Respuesta Correcta:** 1

**Explicación:** Once the exception handling is done, the Exception object is destroyed and the memory it occupied is made available for garbage collection.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 695
**Pregunta:** How do you find which client machine is sending request to your servlet in Java?
**Nivel:** Intermedio

1. By using the getRemoteAddr() method of the HttpServletRequest object.
2. By using the getLocalAddr() method of the HttpServletRequest object.
3. By using the getInetAddress() method of the HttpServletRequest object.

**Respuesta Correcta:** 1

**Explicación:** To find the client machine that is sending a request to your servlet, you can use the getRemoteAddr() method of the HttpServletRequest object. This method returns the IP address of the client machine that is sending the request.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 702
**Pregunta:** Can you instantiate this class?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 3

**Explicación:** The answer to this question depends on the specific class in question. Some classes in Java cannot be instantiated, such as abstract classes or classes with private constructors, while others can be instantiated.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 706
**Pregunta:** How do you fix your Serializable class, if it contains a member that is not serializable?
**Nivel:** Intermedio

1. By marking the member as transient.
2. By marking the member as static.
3. By marking the member as final.

**Respuesta Correcta:** 1

**Explicación:** If a class contains a member that is not serializable, you can fix the class by marking the member as transient. This tells the serialization process to skip the member when serializing the object, and to leave it out of the resulting serialized data.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 707
**Pregunta:** What is the use of run time polymorphism in Java?
**Nivel:** Básico

1. To allow objects of different classes to be treated as objects of a common class.
2. To allow objects of the same class to be treated as objects of different classes.
3. To allow objects of different classes to be treated as objects of a common interface.

**Respuesta Correcta:** 1

**Explicación:** The purpose of runtime polymorphism in Java is to allow objects of different classes to be treated as objects of a common class. This allows for dynamic method dispatch, where the method to be called is determined at runtime based on the actual type of the object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 708
**Pregunta:** What are the rules of method overloading and method overriding in Java?
**Nivel:** Intermedio

1. Overloaded methods must have the same name, while overridden methods must have different names.
2. Overloaded methods must have different names, while overridden methods must have the same name.
3. Overloaded methods must have the same name, return type, and number of arguments.
4. Overridden methods must have the same name, return type, and number of arguments.

**Respuesta Correcta:** 4

**Explicación:** In Java, overloaded methods must have the same name, but different argument lists, while overridden methods must have the same name, return type, and argument list as the method in the parent class. Overloading allows for multiple methods with the same name, but different signatures, to be defined in the same class, while overriding allows for a subclass to provide a new implementation for a method defined in its parent class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 710
**Pregunta:** Can we create an abstract class that extends another abstract class?
**Nivel:** Básico

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 1

**Explicación:** Yes, in Java, an abstract class can extend another abstract class. This allows for the creation of a hierarchy of abstract classes, where each subclass adds additional behavior and functionality to the parent class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 711
**Pregunta:** Why do you use Upcasting or Downcasting in Java ?
**Nivel:** Intermedio

1. To allow objects of different classes to be treated as objects of a common class.
2. To allow objects of the same class to be treated as objects of different classes.
3. To change the type of an object at runtime.

**Respuesta Correcta:** 3

**Explicación:** Upcasting and downcasting in Java are used to change the type of an object at runtime. Upcasting refers to casting an object to a higher type in the class hierarchy, while downcasting refers to casting an object to a lower type in the class hierarchy. These casting operations allow for the creation of more flexible and dynamic object-oriented programs.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 715
**Pregunta:** What is the difference between super and this keywords in Java?
**Nivel:** Intermedio

1. The super keyword refers to the parent class, while the this keyword refers to the current object.
2. The super keyword refers to the current object, while the this keyword refers to the parent class.
3. The super keyword refers to the parent object, while the this keyword refers to the current object.

**Respuesta Correcta:** 1

**Explicación:** In Java, the super keyword refers to the parent class, while the this keyword refers to the current object. The super keyword is used to access methods and variables of the parent class, while the this keyword is used to refer to the current object, or to call another constructor within the same class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 719
**Pregunta:** What is the difference between super and this keywords in Java?
**Nivel:** Intermedio

1. The super keyword refers to the parent class, while the this keyword refers to the current object.
2. The super keyword refers to the current object, while the this keyword refers to the parent class.
3. The super keyword refers to the parent object, while the this keyword refers to the current object.

**Respuesta Correcta:** 1

**Explicación:** In Java, the super keyword refers to the parent class, while the this keyword refers to the current object. The super keyword is used to access methods and variables of the parent class, while the this keyword is used to refer to the current object, or to call another constructor within the same class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 721
**Pregunta:** Can you override an overloaded method in Java?
**Nivel:** Intermedio

1. Yes
2. No
3. It depends

**Respuesta Correcta:** 2

**Explicación:** No, you cannot override an overloaded method in Java. Overloading and overriding are two different concepts in Java, and an overloaded method is not considered to be the same as an overridden method. An overloaded method is a method with the same name as another method, but with a different signature, while an overridden method is a method that provides a new implementation for a method defined in a parent class.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 724
**Pregunta:** How will you make an Object Immutable in Java?
**Nivel:** Intermedio

1. By making all fields of the object final and private.
2. By making all fields of the object public and mutable.
3. By making all fields of the object protected and mutable.

**Respuesta Correcta:** 1

**Explicación:** To make an object immutable in Java, you should make all fields of the object final and private. This ensures that the object cannot be modified once it has been created, and that its state cannot be changed by other parts of the program. In addition, it is a good practice to provide only getter methods for the object's fields, to prevent any unauthorized modification of the object's state.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 728
**Pregunta:** How can we share an object between multiple threads?
**Nivel:** Intermedio

1. By using synchronized methods or blocks to control access to the shared object.
2. By using volatile variables to ensure that changes to the shared object are visible to all threads.
3. By using atomic variables to ensure that updates to the shared object are performed in a thread-safe manner.
4. All of the above.

**Respuesta Correcta:** 1

**Explicación:** One way to share an object between multiple threads is by using synchronized methods or blocks to control access to the shared object. Synchronized methods or blocks allow you to specify a critical section of code that can only be executed by one thread at a time, ensuring that the shared object is accessed in a thread-safe manner. Other techniques such as volatile variables and atomic variables can also be used to ensure that changes to the shared object are visible to all threads, and that updates to the shared object are performed in a thread-safe manner.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 730
**Pregunta:** What are the implicit objects in JSP?
**Nivel:** Básico

1. request, response, session, application, out, config, pageContext, page
2. request, response, session, out, pageContext, page
3. request, response, out, page
4. request, response, session, out

**Respuesta Correcta:** 1

**Explicación:** The implicit objects in JSP are request, response, session, application, out, config, pageContext, and page. These objects are automatically available in every JSP page, and provide access to various resources and services in the web application. For example, the request object provides access to incoming request data, such as form data and headers, while the response object provides access to the response that will be sent back to the client.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 743
**Pregunta:** What are the different scopes of a JSP object?
**Nivel:** Básico

1. Page
2. Request
3. Session
4. Application

**Respuesta Correcta:** 1, 2, 3

**Explicación:** JSP objects can have different scopes such as Page, Request, Session, and Application. Page scope means that the object is only available to the current JSP page, Request scope means that the object is available to all pages processing the current request, Session scope means that the object is available to all pages in the current user session, and Application scope means that the object is available to all pages in the current web application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 744
**Pregunta:** What is pageContext in JSP?
**Nivel:** Básico

1. An implicit object that provides access to various objects in the JSP context.
2. A JSP directive that sets the context for the current page.
3. A JSP action that sets the context for the current page.

**Respuesta Correcta:** 1

**Explicación:** The pageContext is an implicit object in JSP that provides access to various objects in the JSP context, such as request, response, session, application, and more. It is used to access these objects and their properties within the JSP page.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 752
**Pregunta:** How will you pass information from one JSP to another JSP?
**Nivel:** Intermedio

1. By using request attributes.
2. By using response attributes.
3. By using session attributes.

**Respuesta Correcta:** 1, 3

**Explicación:** Information can be passed from one JSP to another JSP using request or session attributes. Request attributes are stored in the request object and can be accessed by any JSP page processing the current request. Session attributes are stored in the user's session and can be accessed by any JSP page during the life of the user's session.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 755
**Pregunta:** What is a directive in JSP?
**Nivel:** Básico

1. A JSP element that provides information to the JSP container.
2. A JSP element that provides information to the client.
3. A JSP element that provides information to the servlet container.

**Respuesta Correcta:** 1

**Explicación:** A directive in JSP is a JSP element that provides information to the JSP container. Directives are used to provide information about the JSP page, such as setting page-level attributes, importing classes, and including other resources.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 756
**Pregunta:** How will you implement Session tracking in JSP?
**Nivel:** Intermedio

1. By using cookies.
2. By using the session object.
3. By using the request object.

**Respuesta Correcta:** 2

**Explicación:** You can implement session tracking in JSP by using the session object. The session object is associated with a user's session and is created the first time the user accesses a JSP page in a web application. Information can be stored in the session object and accessed by any JSP page during the life of the user's session.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 759
**Pregunta:** How will you send XML data from a JSP?
**Nivel:** Intermedio

1. By using the response object to set the content type and write the XML data to the response.
2. By using the request object to set the content type and write the XML data to the request.
3. By using the session object to set the content type and write the XML data to the session.

**Respuesta Correcta:** 1

**Explicación:** You can send XML data from a JSP by using the response object to set the content type to "text/xml" and write the XML data to the response. This allows you to send XML data from the server to the client, where it can be processed or displayed as needed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 766
**Pregunta:** How will you use a Cookie in JSP?
**Nivel:** Intermedio

1. By using the addCookie method of the response object to create a new cookie, and the getCookies method of the request object to retrieve the cookie from the request.
2. By using the setCookie method of the response object to create a new cookie, and the getCookie method of the request object to retrieve the cookie from the request.
3. By using the addCookie method of the request object to create a new cookie, and the getCookies method of the response object to retrieve the cookie from the response.

**Respuesta Correcta:** 1

**Explicación:** You can use a cookie in JSP by using the addCookie method of the response object to create a new cookie, and the getCookies method of the request object to retrieve the cookie from the request. This allows you to store information on the client in the form of a cookie, and retrieve it later when the client makes another request to the server.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 770
**Pregunta:** How will you prevent caching of HTML output by web browser in JSP?
**Nivel:** Intermedio

1. By setting the appropriate HTTP headers in the response.
2. By setting the appropriate attributes in the page directive.
3. By setting the appropriate attributes in the jsp directive.

**Respuesta Correcta:** 1

**Explicación:** You can prevent caching of HTML output by a web browser in JSP by setting the appropriate HTTP headers in the response. This can be done by using the response object to set headers such as Cache-Control, Pragma, and Expires, to indicate that the content should not be cached.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 771
**Pregunta:** How will you redirect request to another page in browser in JSP code?
**Nivel:** Intermedio

1. By using the sendRedirect method of the response object.
2. By using the forward method of the request object.
3. By using the redirect method of the response object.

**Respuesta Correcta:** 1

**Explicación:** You can redirect a request to another page in a browser in JSP code by using the sendRedirect method of the response object. The sendRedirect method causes the browser to issue a new request for the specified URL, allowing you to redirect the user to another page.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 773
**Pregunta:** What is the use of config implicit object in JSP?
**Nivel:** Básico

1. To provide access to the ServletConfig object for the JSP page.
2. To provide access to the ServletContext object for the JSP page.
3. To provide access to the HttpServletRequest object for the JSP page.

**Respuesta Correcta:** 1

**Explicación:** The config implicit object in JSP provides access to the ServletConfig object for the JSP page. The ServletConfig object provides access to initialization parameters for the JSP page, such as parameters specified in the web.xml file. This allows you to configure your JSP pages using configuration information stored in the deployment descriptor.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 775
**Pregunta:** How can be read data from a Form in a JSP?
**Nivel:** Intermedio

1. By using the getParameter method of the request object to retrieve the form data.
2. By using the getAttribute method of the request object to retrieve the form data.
3. By using the getParameterValues method of the request object to retrieve the form data.

**Respuesta Correcta:** 1

**Explicación:** You can read data from a form in a JSP by using the getParameter method of the request object to retrieve the form data. The getParameter method allows you to retrieve the value of a form field, based on its name, from the request object. You can use this method to read form data submitted by the user and process it in your JSP code.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 778
**Pregunta:** In which scenario, Container initializes multiple JSP/Servlet objects?
**Nivel:** Avanzado

1. When multiple clients access the same JSP/Servlet simultaneously.
2. When the JSP/Servlet is configured with a load-on-startup value in the deployment descriptor.
3. When the JSP/Servlet is accessed for the first time and is not already loaded in memory.

**Respuesta Correcta:** 1

**Explicación:** The container initializes multiple JSP/Servlet objects when multiple clients access the same JSP/Servlet simultaneously. This is done to ensure that each client request is handled by a separate instance of the JSP/Servlet, allowing each request to be processed independently and concurrently.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 782
**Pregunta:** How will you access request parameters in JSP?
**Nivel:** Intermedio

1. By using the getParameter method of the request object.
2. By using the getAttribute method of the request object.
3. By using the getParameterValues method of the request object.

**Respuesta Correcta:** 1

**Explicación:** You can access request parameters in JSP by using the getParameter method of the request object. The getParameter method allows you to retrieve the value of a request parameter, based on its name, from the request object. You can use this method to access data submitted by the user in a form or as part of a URL query string.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 792
**Pregunta:** What is Observer design pattern?
**Nivel:** Avanzado

1. A design pattern that allows objects to notify other objects about changes in their state.
2. A design pattern that allows objects to change their behavior based on the state.
3. A design pattern that allows objects to store their state.

**Respuesta Correcta:** 1

**Explicación:** Observer design pattern is a design pattern that allows objects to notify other objects about changes in their state. This pattern defines a one-to-many relationship between objects, where one object is the subject and the other objects are the observers.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 795
**Pregunta:** Can you explain Decorator design pattern with an example in Java?
**Nivel:** Avanzado

1. Yes
2. No
3. nan

**Respuesta Correcta:** 1

**Explicación:** The Decorator design pattern allows behavior to be added to an individual object, either statically or dynamically, without affecting the behavior of other objects from the same class. For example, in Java, you can create a class for a basic beverage such as coffee, and then create decorator classes for adding condiments such as milk and sugar.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 802
**Pregunta:** What is Template Method design pattern in Java?
**Nivel:** Avanzado

1. A design pattern that defines the skeleton of an algorithm and allows subclasses to provide the implementation.
2. A design pattern that allows objects to store their state.
3. A design pattern that allows objects to change their behavior based on the state.

**Respuesta Correcta:** 1

**Explicación:** The Template Method design pattern is a design pattern that defines the skeleton of an algorithm and allows subclasses to provide the implementation. This pattern is useful when you want to define the steps of an algorithm and allow subclasses to provide the implementation for one or more of the steps.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 804
**Pregunta:** Can you tell some examples of Factory Method design pattern implementation in Java?
**Nivel:** Avanzado

1. java.util.Calendar#getInstance
2. java.util.ResourceBundle#getBundle
3. java.net.URL#openConnection
4. java.nio.charset.Charset#forName

**Respuesta Correcta:** 1, 2

**Explicación:** java.util.Calendar#getInstance and java.util.ResourceBundle#getBundle are examples of Factory Method design pattern implementation in Java. These methods provide a factory method to create objects, allowing the client to obtain objects without having to specify the exact class of the object that will be created.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 811
**Pregunta:** What are the main uses of Command design pattern?
**Nivel:** Avanzado

1. To encapsulate a request as an object.
2. To allow for deferred or undoable execution of operations.
3. To allow for loose coupling between the sender of a request and the receiver of a request.
4. To allow for the dynamic modification of request handling behavior.

**Respuesta Correcta:** 1, 2, 3

**Explicación:** The main uses of the Command design pattern are to encapsulate a request as an object, to allow for deferred or undoable execution of operations, and to allow for loose coupling between the sender of a request and the receiver of a request. By encapsulating a request as an object, you can dynamically modify the request handling behavior.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 817
**Pregunta:** How Decorator design pattern is different from Proxy pattern?
**Nivel:** Avanzado

1. Decorator pattern is used to add behavior to an existing class, while Proxy pattern is used to provide a surrogate or placeholder for another object to control access to it.
2. Decorator pattern is used to provide a surrogate or placeholder for another object to control access to it, while Proxy pattern is used to add behavior to an existing class.
3. Both Decorator and Proxy patterns are used to add behavior to an existing class.
4. Neither Decorator nor Proxy patterns are used to add behavior to an existing class.

**Respuesta Correcta:** 1

**Explicación:** The Decorator pattern is used to add behavior to an existing class, while the Proxy pattern is used to provide a surrogate or placeholder for another object to control access to it. The Decorator pattern allows you to add behavior to an object dynamically, while the Proxy pattern allows you to control access to an object by providing a substitute object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 818
**Pregunta:** What are the different scenarios to use Setter and Constructor based injection in Dependency Injection (DI) design pattern?
**Nivel:** Avanzado

1. Use setter-based injection when you need to add or remove dependencies dynamically, and use constructor-based injection when you have mandatory dependencies.
2. Use setter-based injection when you have mandatory dependencies, and use constructor-based injection when you need to add or remove dependencies dynamically.
3. Both setter-based and constructor-based injections have the same use cases and can be used interchangeably.
4. Neither setter-based nor constructor-based injections are used in Dependency Injection.

**Respuesta Correcta:** 1

**Explicación:** Use setter-based injection when you need to add or remove dependencies dynamically, and use constructor-based injection when you have mandatory dependencies. Setter-based injection is useful when you need to add or remove dependencies at runtime, while constructor-based injection is useful when you have mandatory dependencies that must be provided when the object is created.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 826
**Pregunta:** What is Builder design pattern?
**Nivel:** Avanzado

1. The Builder design pattern is a creational design pattern that provides a way to create complex objects step by step using a builder object. The builder object provides a flexible way to create objects, allowing the client to control the construction process and produce different representations of the same object.
2. The Builder design pattern is a behavioral design pattern that provides a way to manage communication between objects in a complex system.
3. The Builder design pattern is a structural design pattern that provides a way to compose objects into tree structures to represent part-whole hierarchies.

**Respuesta Correcta:** 1

**Explicación:** The Builder design pattern is a creational design pattern that provides a way to create complex objects step by step using a builder object. The builder object provides a flexible way to create objects, allowing the client to control the construction process and produce different representations of the same object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 830
**Pregunta:** What design pattern is suitable to add new features to an existing object?
**Nivel:** Avanzado

1. The design pattern suitable to add new features to an existing object is the Decorator design pattern.
2. The design pattern suitable to add new features to an existing object is the Factory design pattern.
3. The design pattern suitable to add new features to an existing object is the Singleton design pattern.
4. The design pattern suitable to add new features to an existing object is the Observer design pattern.

**Respuesta Correcta:** 1

**Explicación:** The design pattern suitable to add new features to an existing object is the Decorator design pattern. The Decorator design pattern provides a way to add new features to an existing object by wrapping it in a decorator object. This allows you to add new features to an object without modifying its existing behavior.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 831
**Pregunta:** Which design pattern can be used when to decouple abstraction from the implementation?
**Nivel:** Avanzado

1. The design pattern that can be used to decouple abstraction from the implementation is the Bridge design pattern.
2. The design pattern that can be used to decouple abstraction from the implementation is the Factory design pattern.
3. The design pattern that can be used to decouple abstraction from the implementation is the Singleton design pattern.
4. The design pattern that can be used to decouple abstraction from the implementation is the Observer design pattern.

**Respuesta Correcta:** 1

**Explicación:** The design pattern that can be used to decouple abstraction from the implementation is the Bridge design pattern. The Bridge design pattern provides a way to decouple an abstraction from its implementation, allowing the two to vary independently.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 833
**Pregunta:** How can we prevent users from creating more than one instance of singleton object by using clone() method?
**Nivel:** Intermedio

1. We can prevent users from creating more than one instance of singleton object by using the clone() method by throwing a CloneNotSupportedException in the clone() method of the Singleton class.
2. We can prevent users from creating more than one instance of singleton object by using the clone() method by making the clone() method private in the Singleton class.
3. We can prevent users from creating more than one instance of singleton object by using the clone() method by making the Singleton class final.

**Respuesta Correcta:** 1

**Explicación:** We can prevent users from creating more than one instance of singleton object by using the clone() method by throwing a CloneNotSupportedException in the clone() method of the Singleton class. This will prevent users from cloning the singleton object, ensuring that there is only one instance of the object in the system.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 837
**Pregunta:** What is the difference between Builder design pattern and Factory design pattern?
**Nivel:** Avanzado

1. The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to create complex objects step by step using a builder object, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created.
2. The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to manage communication between objects in a complex system, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created.
3. The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to add behavior to existing objects dynamically, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created.

**Respuesta Correcta:** 1

**Explicación:** The difference between Builder design pattern and Factory design pattern is that the Builder design pattern provides a way to create complex objects step by step using a builder object, while the Factory design pattern provides a way to create objects without specifying the exact class of object that will be created. The Builder design pattern allows you to create complex objects by constructing them step by step, while the Factory design pattern provides a way to create objects by calling a factory method and providing the necessary information for the object to be created.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 842
**Pregunta:** What is the difference between the Observer design pattern and the Publish-Subscribe pattern?
**Nivel:** Avanzado

1. The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is a one-to-many relationship between objects, where one object is the subject and the others are observers, while the Publish-Subscribe pattern is a one-to-many relationship between objects, where the objects publish messages and other objects subscribe to receive those messages.
2. The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is a one-to-one relationship between objects, while the Publish-Subscribe pattern is a one-to-many relationship between objects.
3. The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is used in software development to provide a solution to a common problem, while the Publish-Subscribe pattern is used in software development to provide a way to create objects without specifying the exact class of object that will be created.

**Respuesta Correcta:** 1

**Explicación:** The difference between the Observer design pattern and the Publish-Subscribe pattern is that the Observer design pattern is a one-to-many relationship between objects, where one object is the subject and the others are observers, while the Publish-Subscribe pattern is a one-to-many relationship between objects, where the objects publish messages and other objects subscribe to receive those messages. In the Observer pattern, the subject notifies its observers of changes to its state, while in the Publish-Subscribe pattern, objects publish messages and other objects subscribe to receive those messages.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 843
**Pregunta:** What is an example of the State design pattern in Java?
**Nivel:** Avanzado

1. An example of the State design pattern in Java is the behavior of a state machine, where the behavior changes depending on the current state of the machine. For example, a state machine that represents a traffic light, where the behavior changes depending on the current state of the light (red, yellow, green).
2. An example of the State design pattern in Java is the behavior of a shopping cart, where the behavior changes depending on the items in the cart.
3. An example of the State design pattern in Java is the behavior of a game character, where the behavior changes depending on the current state of the character (idle, walking, running, jumping, etc.).

**Respuesta Correcta:** 1, 2, 3

**Explicación:** All of the options are examples of the State design pattern in Java. The State design pattern allows you to change the behavior of an object based on its current state. In each of the examples given, the behavior changes based on the current state of the object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 845
**Pregunta:** What is the difference between the Singleton and Prototype design patterns in Java?
**Nivel:** Avanzado

1. Singleton pattern creates a single instance of an object while Prototype pattern creates multiple instances of an object.
2. Singleton pattern creates multiple instances of an object while Prototype pattern creates a single instance of an object.
3. Both Singleton and Prototype patterns create multiple instances of an object.

**Respuesta Correcta:** 1

**Explicación:** The Singleton design pattern in Java ensures that a class has only one instance, while the Prototype design pattern provides a mechanism to create multiple instances of an object by cloning the original object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 846
**Pregunta:** What is the difference between the Template Method and Factory Method design patterns in Java?
**Nivel:** Avanzado

1. Template Method defines the steps to be executed in a method, while Factory Method creates objects.
2. Factory Method defines the steps to be executed in a method, while Template Method creates objects.
3. Both Template Method and Factory Method create objects.

**Respuesta Correcta:** 1

**Explicación:** The Template Method design pattern in Java defines the steps to be executed in a method and allows subclasses to provide the implementation for one or more steps. The Factory Method design pattern in Java creates objects by defining a method for creating objects.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 847
**Pregunta:** What is the difference between the Chain of Responsibility, Command, and Mediator design patterns in Java?
**Nivel:** Avanzado

1. Chain of Responsibility passes a request sequentially along a dynamic chain of receivers, Command establishes unidirectional connections between senders and receivers of requests, and Mediator allows communication between objects through a mediator object.
2. Command passes a request sequentially along a dynamic chain of receivers, Chain of Responsibility establishes unidirectional connections between senders and receivers of requests, and Mediator allows communication between objects through a mediator object.
3. Mediator passes a request sequentially along a dynamic chain of receivers, Command establishes unidirectional connections between senders and receivers of requests, and Chain of Responsibility allows communication between objects through a mediator object.

**Respuesta Correcta:** 1

**Explicación:** The Chain of Responsibility, Command, and Mediator design patterns in Java provide different ways of connecting senders and receivers of requests. The Chain of Responsibility pattern passes a request sequentially along a dynamic chain of receivers, the Command pattern establishes unidirectional connections between senders and receivers of requests, and the Mediator pattern allows communication between objects through a mediator object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 852
**Pregunta:** What is the difference between the Memento and Prototype design patterns in Java?
**Nivel:** Avanzado

1. Memento pattern saves and restores the state of an object, while Prototype pattern creates objects by cloning the original object.
2. Prototype pattern saves and restores the state of an object, while Memento pattern creates objects by cloning the original object.
3. Both Memento and Prototype patterns save and restore the state of an object.

**Respuesta Correcta:** 1

**Explicación:** The Memento design pattern in Java saves and restores the state of an object, allowing for the undo/redo functionality. The Prototype design pattern in Java creates objects by cloning the original object, allowing for the creation of objects without specifying their concrete classes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 884
**Pregunta:** What is a Spring Bean?
**Nivel:** Básico

1. An object managed by the Spring IoC container.
2. A database management tool.
3. A web development framework.

**Respuesta Correcta:** 1

**Explicación:** A Spring Bean is an object that is managed by the Spring IoC container. The Spring IoC container is responsible for creating and managing the lifecycle of beans, allowing for the separation of the concerns of creating and managing objects from the concern of using them.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 885
**Pregunta:** What does the definition of a Spring Bean contain?
**Nivel:** Básico

1. The class of the bean.
2. The properties of the bean.
3. The dependencies of the bean.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** The definition of a Spring Bean typically contains information about the class of the bean, the properties of the bean, and the dependencies of the bean. This information is used by the Spring IoC container to create and manage the lifecycle of the bean.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 894
**Pregunta:** What are Inner beans in Spring?
**Nivel:** Básico

1. Inner beans in Spring are beans that are defined within the scope of another bean.
2. Inner beans in Spring are beans that are defined outside of the scope of the application.
3. Inner beans in Spring are beans that are defined within the scope of the application.

**Respuesta Correcta:** 1

**Explicación:** Inner beans in Spring are beans that are defined within the scope of another bean. This allows for the creation of nested objects within the Spring IoC container, making the code more flexible and configurable.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 896
**Pregunta:** What is Bean wiring in Spring?
**Nivel:** Básico

1. Bean wiring in Spring refers to the process of connecting the dependencies between beans within the Spring IoC container.
2. Bean wiring in Spring refers to the process of creating beans within the Spring IoC container.
3. Bean wiring in Spring refers to the process of destroying beans within the Spring IoC container.

**Respuesta Correcta:** 1

**Explicación:** Bean wiring in Spring refers to the process of connecting the dependencies between beans within the Spring IoC container. This allows for the separation of the concerns of creating and managing objects from the concern of using them, making the code more flexible and configurable.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 902
**Pregunta:** What is the purpose of @Configuration annotation?
**Nivel:** Básico

1. The purpose of the @Configuration annotation in Spring is to indicate that a class should be considered a source of bean definitions.
2. The purpose of the @Configuration annotation in Spring is to indicate that a class should not be considered a source of bean definitions.
3. The purpose of the @Configuration annotation in Spring is to indicate that a class is a bean.

**Respuesta Correcta:** 1

**Explicación:** The purpose of the @Configuration annotation in Spring is to indicate that a class should be considered a source of bean definitions. This allows for the configuration of the Spring IoC container using Java code, rather than XML or other configuration files.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 903
**Pregunta:** What is the difference between Full @Configuration and 'lite' @Beans mode?
**Nivel:** Intermedio

1. The difference between Full @Configuration and 'lite' @Beans mode is that Full @Configuration provides full support for defining bean definitions in a class, while 'lite' @Beans mode provides a lighter weight alternative.
2. The difference between Full @Configuration and 'lite' @Beans mode is that Full @Configuration provides limited support for defining bean definitions in a class, while 'lite' @Beans mode provides full support.
3. There is no difference between Full @Configuration and 'lite' @Beans mode.

**Respuesta Correcta:** 1

**Explicación:** The difference between Full @Configuration and 'lite' @Beans mode is that Full @Configuration provides full support for defining bean definitions in a class, while 'lite' @Beans mode provides a lighter weight alternative. 'lite' @Beans mode is typically used for simple use cases, while Full @Configuration is used for more complex configurations.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 910
**Pregunta:** How Spring framework makes JDBC coding easier for developers?
**Nivel:** Intermedio

1. Spring framework makes JDBC coding easier for developers by providing a higher level of abstraction and reducing the amount of code that needs to be written to perform common database operations.
2. Spring framework makes JDBC coding harder for developers by providing a lower level of abstraction and increasing the amount of code that needs to be written to perform common database operations.
3. Spring framework has no effect on the difficulty of JDBC coding for developers.

**Respuesta Correcta:** 1

**Explicación:** Spring framework makes JDBC coding easier for developers by providing a higher level of abstraction and reducing the amount of code that needs to be written to perform common database operations. This allows for a more streamlined and efficient approach to database programming, while also making it easier to manage the configuration of a Spring-based application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 911
**Pregunta:** What is the purpose of JdbcTemplate?
**Nivel:** Básico

1. The purpose of JdbcTemplate in Spring is to provide a higher level of abstraction for performing common database operations, making it easier for developers to write JDBC code.
2. The purpose of JdbcTemplate in Spring is to provide a lower level of abstraction for performing common database operations, making it harder for developers to write JDBC code.
3. The purpose of JdbcTemplate in Spring is to provide a different approach to performing common database operations, making it harder for developers to write JDBC code.

**Respuesta Correcta:** 1

**Explicación:** The purpose of JdbcTemplate in Spring is to provide a higher level of abstraction for performing common database operations, making it easier for developers to write JDBC code. JdbcTemplate eliminates the need for repetitive, low-level code, allowing developers to focus on the logic of their application rather than the details of database programming.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 912
**Pregunta:** What are the benefits of using Spring DAO?
**Nivel:** Básico

1. The benefits of using Spring DAO include improved abstraction, reduced code complexity, and increased efficiency in database programming.
2. The benefits of using Spring DAO include increased code complexity, reduced abstraction, and decreased efficiency in database programming.
3. The benefits of using Spring DAO are not related to abstraction, code complexity, or efficiency in database programming.

**Respuesta Correcta:** 1

**Explicación:** The benefits of using Spring DAO include improved abstraction, reduced code complexity, and increased efficiency in database programming. Spring DAO provides a higher level of abstraction for performing common database operations, allowing developers to focus on the logic of their application rather than the details of database programming.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 914
**Pregunta:** What types of Object Relational Mapping (ORM) are supported by Spring?
**Nivel:** Básico

1. Hibernate
2. JPA
3. iBATIS
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** The types of Object Relational Mapping (ORM) supported by Spring include Hibernate, JPA, and iBATIS. Spring provides a flexible and configurable approach to ORM, allowing developers to choose the best solution for their particular needs.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 917
**Pregunta:** What are the benefits provided by Spring Framework’s Transaction Management?
**Nivel:** Básico

1. Improved abstraction and reduced code complexity.
2. Increased efficiency and flexibility in managing transactions.
3. The ability to use either programmatic or declarative approaches to Transaction Management.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** The benefits provided by Spring Framework’s Transaction Management include improved abstraction and reduced code complexity, increased efficiency and flexibility in managing transactions, and the ability to use either programmatic or declarative approaches to Transaction Management. This allows for a more streamlined and efficient approach to database programming, while also making it easier to manage the configuration of a Spring-based application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 926
**Pregunta:** What is a Target object in Spring AOP?
**Nivel:** Básico

1. A Target object in Spring AOP is the object being advised by one or more Aspects.
2. A Target object in Spring AOP is not related to being advised by one or more Aspects.
3. A Target object in Spring AOP is the object advising one or more Aspects.

**Respuesta Correcta:** 1

**Explicación:** A Target object in Spring AOP is the object being advised by one or more Aspects. This allows for a more organized and efficient approach to software development, while also making it easier to manage the complexity of large-scale applications.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 927
**Pregunta:** What is a Proxy in Spring AOP?
**Nivel:** Básico

1. A Proxy in Spring AOP is an object that is created by the AOP framework to represent the Target object, allowing for Aspects to be applied.
2. A Proxy in Spring AOP is not related to the Target object or Aspects.
3. A Proxy in Spring AOP is an object that represents the AOP framework, not the Target object.

**Respuesta Correcta:** 1

**Explicación:** A Proxy in Spring AOP is an object that is created by the AOP framework to represent the Target object, allowing for Aspects to be applied. This allows for a more flexible and configurable approach to software development, making it easier to manage the complexity of large-scale applications.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 929
**Pregunta:** What is Weaving in Spring AOP?
**Nivel:** Básico

1. Weaving in Spring AOP is the process of linking Aspects to Target objects to create a Proxy, allowing for Aspects to be applied at runtime.
2. Weaving in Spring AOP is not related to linking Aspects to Target objects or creating a Proxy.
3. Weaving in Spring AOP is the process of removing Aspects from Target objects.

**Respuesta Correcta:** 1

**Explicación:** Weaving in Spring AOP is the process of linking Aspects to Target objects to create a Proxy,

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 939
**Pregunta:** What are the main features of Spring MVC?
**Nivel:** Avanzado

1. Model-View-Controller (MVC) design pattern
2. Support for RESTful web services
3. Built-in support for data validation
4. Built-in support for data binding

**Respuesta Correcta:** 1, 2, 3, 4

**Explicación:** All of the options are main features of Spring MVC. Model-View-Controller (MVC) design pattern provides a clear separation of responsibilities between the components of the application, support for RESTful web services allows for easy creation of RESTful web services, built-in support for data validation enables data validation before the request is processed, and built-in support for data binding automatically maps request data to objects, making it easier to work with complex data structures.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 946
**Pregunta:** Name some popular Spring framework annotations that you use in your project?
**Nivel:** Básico

1. @Autowired
2. @Controller
3. @Service
4. @Repository

**Respuesta Correcta:** 1, 2, 3, 4

**Explicación:** All of the options are popular Spring framework annotations. @Autowired is used for dependency injection, @Controller is used to define a controller class in Spring MVC, @Service is used to define a service class, and @Repository is used to define a data access object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 950
**Pregunta:** How will you handle exceptions in Spring MVC Framework?
**Nivel:** Intermedio

1. By using the @ExceptionHandler annotation
2. By using the @ControllerAdvice annotation
3. By using a try-catch block
4. By using the @ResponseStatus annotation

**Respuesta Correcta:** 1, 2

**Explicación:** You can handle exceptions in a Spring MVC application by using the @ExceptionHandler and @ControllerAdvice annotations. The @ExceptionHandler annotation is used to define a method for handling a specific exception, and the @ControllerAdvice annotation is used to define a class for handling exceptions globally.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 968
**Pregunta:** What is Hibernate framework?
**Nivel:** Básico

1. Hibernate is a Java-based open-source framework for persisting data in relational databases
2. Hibernate is a database management system
3. Hibernate is a web development framework
4. Hibernate is a mobile application development framework

**Respuesta Correcta:** 1

**Explicación:** Hibernate is a Java-based open-source framework for persisting data in relational databases. It provides a number of tools and features for mapping between objects and relational database tables, performing database operations, and managing transactions.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 969
**Pregunta:** What is an Object Relational Mapping (ORM)?
**Nivel:** Básico

1. Object Relational Mapping (ORM) is a technique for mapping data between an object-oriented representation of data and a relational database representation of data
2. Object Relational Mapping (ORM) is a technique for storing data in a relational database
3. Object Relational Mapping (ORM) is a technique for retrieving data from a relational database
4. Object Relational Mapping (ORM) is a technique for querying a relational database

**Respuesta Correcta:** 1

**Explicación:** Object Relational Mapping (ORM) is a technique for mapping data between an object-oriented representation of data and a relational database representation of data. ORM frameworks like Hibernate provide a way to map objects to database tables, manage database connections, and perform database operations using objects, instead of writing SQL code.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 971
**Pregunta:** What is Object Relational Impedance Mismatch?
**Nivel:** Intermedio

1. Object Relational Impedance Mismatch is the difference in the data structures and concepts used in object-oriented programming and relational databases
2. Object Relational Impedance Mismatch is the difficulty in mapping between relational databases and object-oriented programming languages
3. Object Relational Impedance Mismatch is the difference in the data structures and concepts used in relational databases and object-oriented programming
4. Object Relational Impedance Mismatch is the difficulty in mapping between object-oriented programming languages and relational databases

**Respuesta Correcta:** 1

**Explicación:** Object Relational Impedance Mismatch is the difference in the data structures and concepts used in object-oriented programming and relational databases. This mismatch can make it difficult to persist data in a relational database using an object-oriented programming language, as the data structures and concepts used in the two environments are often quite different.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 972
**Pregunta:** What are the main problems of Object Relational Impedance Mismatch?
**Nivel:** Intermedio

1. Difficulty in mapping object-oriented features to relational databases.
2. Incompatibility between the data types of the two systems.
3. Lack of inheritance and polymorphism support in relational databases.
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** Object-Relational Impedance Mismatch refers to the difficulties encountered when trying to map the object-oriented features of a program to the relational databases used to store the data. These difficulties arise from differences in the data types, lack of inheritance and polymorphism support in relational databases, and other factors.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 975
**Pregunta:** How will you map the columns of a DB table to the properties of a Java class in Hibernate?
**Nivel:** Intermedio

1. Using annotations.
2. Using XML mapping files.
3. Both annotations and XML mapping files.

**Respuesta Correcta:** 3

**Explicación:** In Hibernate, the columns of a DB table can be mapped to the properties of a Java class using either annotations or XML mapping files. Both options are available, giving developers the flexibility to choose the method that works best for their specific use case.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 978
**Pregunta:** Why do we use POJO in Hibernate?
**Nivel:** Intermedio

1. POJO stands for Plain Old Java Object and is used as a simple, plain Java object that can be easily manipulated.
2. POJO stands for Persistent Object Java Object and is used to persist data in a database.
3. POJO stands for Programmed Object Java Object and is used to manipulate data in a program.

**Respuesta Correcta:** 1

**Explicación:** POJO stands for Plain Old Java Object and is used as a simple, plain Java object that can be easily manipulated. In Hibernate, POJOs are used to represent the data that will be stored in the database, making it easier to manipulate the data and perform CRUD operations.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 979
**Pregunta:** What is Hibernate Query Language (HQL)?
**Nivel:** Básico

1. A database query language used in Hibernate.
2. A programming language used in Hibernate.
3. A data retrieval language used in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** Hibernate Query Language (HQL) is a database query language used in Hibernate to perform database operations. HQL uses an object-oriented syntax that is similar to SQL, but operates on objects rather than tables. This makes it easier to perform complex database operations in Hibernate.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 980
**Pregunta:** How will you call a stored procedure in Hibernate?
**Nivel:** Intermedio

1. By using the createSQLQuery method of the Session object.
2. By using the createQuery method of the Session object.
3. By using the createCriteria method of the Session object.

**Respuesta Correcta:** 1

**Explicación:** To call a stored procedure in Hibernate, you can use the createSQLQuery method of the Session object. This method allows you to execute native SQL statements, including calls to stored procedures.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 981
**Pregunta:** What is Criteria API in Hibernate?
**Nivel:** Básico

1. A programmatic approach to performing database operations in Hibernate.
2. A declarative approach to performing database operations in Hibernate.
3. A graphical approach to performing database operations in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** Criteria API in Hibernate is a programmatic approach to performing database operations. It allows you to create dynamic and flexible queries by building query objects programmatically, rather than using HQL or native SQL.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 982
**Pregunta:** Why do we use HibernateTemplate?
**Nivel:** Intermedio

1. To simplify the process of working with Hibernate and reduce the amount of code required.
2. To increase the complexity of working with Hibernate and increase the amount of code required.
3. To provide a graphical interface for working with Hibernate.

**Respuesta Correcta:** 1

**Explicación:** HibernateTemplate is used to simplify the process of working with Hibernate and reduce the amount of code required. It provides a convenient and efficient way to perform common database operations, such as saving and retrieving objects, by abstracting the underlying Hibernate APIs.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 983
**Pregunta:** How can you see SQL code generated by Hibernate on console?
**Nivel:** Intermedio

1. By setting the show_sql property to true in the Configuration object.
2. By setting the print_sql property to true in the Configuration object.
3. By setting the debug_sql property to true in the Configuration object.

**Respuesta Correcta:** 1

**Explicación:** To see the SQL code generated by Hibernate on the console, you need to set the show_sql property to true in the Configuration object. This will cause Hibernate to log all of the SQL statements that it generates, allowing you to see the exact SQL code that is being executed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 985
**Pregunta:** What is the difference between session.save() and session.saveOrUpdate() methods in Hibernate?
**Nivel:** Intermedio

1. session.save() method is used to save a new object, while session.saveOrUpdate() method is used to save an object or update an existing object.
2. session.save() method is used to save an object or update an existing object, while session.saveOrUpdate() method is used to save a new object.
3. Both methods are used to save a new object.
4. Both methods are used to update an existing object.

**Respuesta Correcta:** 1

**Explicación:** The session.save() method is used to save a new object, while the session.saveOrUpdate() method is used to save an object or update an existing object. If the object being saved already exists in the database, the saveOrUpdate() method will update the existing record, while the save() method will throw an exception.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 986
**Pregunta:** What are the advantages of Hibernate framework over JDBC?
**Nivel:** Avanzado

1. Object/Relational mapping
2. Reduced amount of code required
3. Improved performance
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** Hibernate offers several advantages over JDBC, including improved Object/Relational mapping, reduced amount of code required, and improved performance. Hibernate also provides a higher level of abstraction, making it easier to perform database operations, and offers better support for caching and transactions.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 988
**Pregunta:** What is the Transient state of an object in Hibernate?
**Nivel:** Básico

1. An object in the Transient state is an object that has been created, but is not associated with a session.
2. An object in the Transient state is an object that has been associated with a session, but has not yet been saved.
3. An object in the Transient state is an object that has been saved, but has not yet been updated.

**Respuesta Correcta:** 1

**Explicación:** An object in the Transient state is an object that has been created, but is not associated with a session. Once an object is associated with a session, it will be in the Persistent state and changes made to the object will be saved to the database when the transaction is committed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 989
**Pregunta:** What is the Detached state of an object in Hibernate?
**Nivel:** Básico

1. An object in the Detached state is an object that was previously associated with a session, but has been detached from it.
2. An object in the Detached state is an object that is associated with a session, but has not yet been saved.
3. An object in the Detached state is an object that has been saved, but has not yet been updated.

**Respuesta Correcta:** 1

**Explicación:** An object in the Detached state is an object that was previously associated with a session, but has been detached from it. Once an object is detached, changes made to the object will not be saved to the database unless the object is reattached to a session.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 990
**Pregunta:** What is the use of Dirty Checking in Hibernate?
**Nivel:** Básico

1. Dirty Checking is a mechanism used in Hibernate to track changes made to an object and automatically persist those changes to the database.
2. Dirty Checking is a mechanism used in Hibernate to prevent changes from being made to an object.
3. Dirty Checking is a mechanism used in Hibernate to manually persist changes to an object to the database.

**Respuesta Correcta:** 1

**Explicación:** Dirty Checking is a mechanism used in Hibernate to track changes made to an object and automatically persist those changes to the database. This makes it easier to manage data, as changes can be made to an object without having to manually persist them to the database.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 992
**Pregunta:** What are the different ORM levels in Hibernate?
**Nivel:** Básico

1. Light Object Mapping
2. Medium Object Mapping
3. Full Object Mapping

**Respuesta Correcta:** 3

**Explicación:** Hibernate supports Full Object Mapping, which means that it provides a complete mapping of an object-oriented model to a relational database. This allows you to work with objects in your code, rather than directly with the database, and provides a high level of abstraction and ease of use.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 997
**Pregunta:** What is Unit of Work design pattern?
**Nivel:** Avanzado

1. Unit of Work is a design pattern used in Hibernate to manage the persistence of objects to the database.
2. Unit of Work is a design pattern used to manage the creation and destruction of objects in an application.
3. Unit of Work is a design pattern used to manage the execution of database queries.

**Respuesta Correcta:** 1

**Explicación:** Unit of Work is a design pattern used in Hibernate to manage the persistence of objects to the database. It provides a mechanism for tracking changes made to objects, and for persisting those changes to the database in a single transaction.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 998
**Pregunta:** In Hibernate, how can an object go in Detached state?
**Nivel:** Intermedio

1. An object can go in the Detached state in Hibernate when it is closed or disconnected from the current session.
2. An object can go in the Detached state in Hibernate when it is associated with a different session.
3. An object can go in the Detached state in Hibernate when it is saved to the database.

**Respuesta Correcta:** 1

**Explicación:** An object can go in the Detached state in Hibernate when it is closed or disconnected from the current session. Once an object is detached, changes made to the object will not be saved to the database unless the object is reattached to a session.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 999
**Pregunta:** How will you order the results returned by a Criteria in Hibernate?
**Nivel:** Intermedio

1. You can order the results returned by a Criteria in Hibernate by calling the addOrder() method of the Criteria object and passing in an Order object.
2. You can order the results returned by a Criteria in Hibernate by calling the setOrder() method of the Criteria object.
3. You can order the results returned by a Criteria in Hibernate by calling the sort() method of the Criteria object.

**Respuesta Correcta:** 1

**Explicación:** You can order the results returned by a Criteria in Hibernate by calling the addOrder() method of the Criteria object and passing in an Order object. This allows you to specify the sort order for the results, such as ascending or descending order based on a specific property of the objects being queried.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1000
**Pregunta:** How does Example criterion work in Hibernate?
**Nivel:** Intermedio

1. The Example criterion in Hibernate is used to create a query based on an example object. The query will return all objects that match the properties of the example object.
2. The Example criterion in Hibernate is used to create a query based on a set of properties of an example object. The query will return all objects that match the specified properties.
3. The Example criterion in Hibernate is used to create a query based on a set of conditions. The query will return all objects that match the conditions.

**Respuesta Correcta:** 1

**Explicación:** The Example criterion in Hibernate is used to create a query based on an example object. The query will return all objects that match the properties of the example object. This provides a convenient way to query for objects with specific properties, without having to manually specify each property in the query.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1003
**Pregunta:** What are the different options to retrieve an object from database in Hibernate?
**Nivel:** Básico

1. get() method
2. load() method
3. find() method
4. All of the above.

**Respuesta Correcta:** 4

**Explicación:** There are several different options to retrieve an object from the database in Hibernate, including the get() method, the load() method, and the find() method. Each method has its own advantages and disadvantages, and the choice of method will depend on the specific needs of your application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1004
**Pregunta:** How can we auto-generate primary key in Hibernate?
**Nivel:** Intermedio

1. You can auto-generate the primary key in Hibernate by using a database-generated key, such as an auto-incrementing column.
2. You can auto-generate the primary key in Hibernate by using a Hibernate-generated key, such as a UUID.
3. You can auto-generate the primary key in Hibernate by using a custom generator class.

**Respuesta Correcta:** 1, 2

**Explicación:** You can auto-generate the primary key in Hibernate by using a database-generated key, such as an auto-incrementing column, or a Hibernate-generated key, such as a UUID. This allows you to automatically generate unique keys for each object, without having to manually set the key in code.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1005
**Pregunta:** How will you re-attach an object in Detached state in Hibernate?
**Nivel:** Intermedio

1. You can re-attach an object in Detached state in Hibernate by calling the update() method of the Session object, passing in the detached object.
2. You can re-attach an object in Detached state in Hibernate by calling the saveOrUpdate() method of the Session object, passing in the detached object.
3. You can re-attach an object in Detached state in Hibernate by calling the merge() method of the Session object, passing in the detached object.

**Respuesta Correcta:** 3

**Explicación:** You can re-attach an object in Detached state in Hibernate by calling the merge() method of the Session object, passing in the detached object. This allows you to persist changes made to the detached object back to the database.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1011
**Pregunta:** What is the difference between Immediate fetching and Lazy collection fetching?
**Nivel:** Avanzado

1. Immediate fetching retrieves the collection when the parent object is loaded, while lazy collection fetching retrieves the collection only when it is accessed.
2. Immediate fetching retrieves the collection only when it is accessed, while lazy collection fetching retrieves the collection when the parent object is loaded.
3. Immediate fetching and lazy collection fetching are the same thing.

**Respuesta Correcta:** 1

**Explicación:** Immediate fetching retrieves the collection when the parent object is loaded, while lazy collection fetching retrieves the collection only when it is accessed. This allows you to optimize performance by deferring the retrieval of collections until they are actually needed.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1017
**Pregunta:** How can we check if an Object is in Persistent, Detached or Transient state in Hibernate?
**Nivel:** Intermedio

1. You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the isConnected() method of the Session object.
2. You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the isDirty() method of the Session object.
3. You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the contains() method of the Session object, passing in the object.

**Respuesta Correcta:** 3

**Explicación:** You can check if an object is in Persistent, Detached or Transient state in Hibernate by calling the contains() method of the Session object, passing in the object. This method returns true if the object is in Persistent state, false if it is in Detached state, and throws an exception if it is in Transient state.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1019
**Pregunta:** What is ORM metadata?
**Nivel:** Básico

1. ORM metadata refers to the data about the data that is stored in a relational database.
2. ORM metadata refers to the data about the mapping between Java objects and relational database tables that is used by an Object-Relational Mapping (ORM) framework like Hibernate.
3. ORM metadata refers to the data about the relational database itself.

**Respuesta Correcta:** 2

**Explicación:** ORM metadata refers to the data about the mapping between Java objects and relational database tables that is used by an Object-Relational Mapping (ORM) framework like Hibernate. This metadata includes information about the tables, columns, relationships, and other mapping details that are used to map Java objects to relational database tables.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1020
**Pregunta:** What is the difference between load() and get() method in Hibernate?
**Nivel:** Intermedio

1. The load() method in Hibernate returns a proxy object that is not initialized until the data is actually accessed, while the get() method immediately retrieves the data from the database.
2. The load() method in Hibernate immediately retrieves the data from the database, while the get() method returns a proxy object that is not initialized until the data is actually accessed.
3. The load() and get() methods are the same thing in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** The load() method in Hibernate returns a proxy object that is not initialized until the data is actually accessed, while the get() method immediately retrieves the data from the database. This allows you to choose the appropriate method based on the specific needs of your application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1023
**Pregunta:** How can we use Named Query in Hibernate?
**Nivel:** Intermedio

1. We can use Named Query in Hibernate by defining a named query in the Hibernate mapping file, and then calling the createNamedQuery() method of the Session object, passing in the name of the query.
2. We can use Named Query in Hibernate by defining a named query in the Hibernate mapping file, and then calling the createSQLQuery() method of the Session object, passing in the name of the query.
3. We can use Named Query in Hibernate by calling the createQuery() method of the Session object, passing in the name of the query.

**Respuesta Correcta:** 1

**Explicación:** We can use Named Query in Hibernate by defining a named query in the Hibernate mapping file, and then calling the createNamedQuery() method of the Session object, passing in the name of the query. Named queries are a way to pre-define a query in Hibernate, so that you can reuse the same query in multiple places in your application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1025
**Pregunta:** What is the use of version number in Hibernate?
**Nivel:** Básico

1. The version number in Hibernate is used to enforce optimistic locking, by checking that the version number of an object has not changed since it was last retrieved from the database.
2. The version number in Hibernate is used to enforce pessimistic locking, by checking that the version number of an object has not changed since it was last retrieved from the database.
3. The version number in Hibernate is used to keep track of the number of times an object has been updated in the database.

**Respuesta Correcta:** 1

**Explicación:** The version number in Hibernate is used to enforce optimistic locking, by checking that the version number of an object has not changed since it was last retrieved from the database. If the version number has changed, it means that another transaction has updated the data in the meantime, and the current transaction must be rolled back.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1026
**Pregunta:** What is the use of session.lock() method in Hibernate?
**Nivel:** Básico

1. The session.lock() method in Hibernate is used to lock an object, preventing other transactions from accessing the same data until the current transaction is finished.
2. The session.lock() method in Hibernate is used to refresh an object, retrieving the latest data from the database.
3. The session.lock() method in Hibernate is used to persist an object, saving it to the database.

**Respuesta Correcta:** 1

**Explicación:** The session.lock() method in Hibernate is used to lock an object, preventing other transactions from accessing the same data until the current transaction is finished. This method is useful when you need to enforce pessimistic locking in your application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1027
**Pregunta:** What inheritance mapping strategies are supported by Hibernate?
**Nivel:** Intermedio

1. Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per subclass, and table per concrete class.
2. Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per superclass, and table per abstract class.
3. Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per interface, and table per implementation.

**Respuesta Correcta:** 1

**Explicación:** Hibernate supports the following inheritance mapping strategies: table per hierarchy, table per subclass, and table per concrete class. These strategies determine how the data for a class hierarchy is stored in the relational database, and each strategy has its own advantages and disadvantages.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1028
**Pregunta:** What is the difference between session.persist() and session.save() methods in Hibernate?
**Nivel:** Intermedio

1. The difference between session.persist() and session.save() methods in Hibernate is that the persist() method adds an object to the persistence context, but does not immediately save it to the database, while the save() method immediately saves the object to the database.
2. The difference between session.persist() and session.save() methods in Hibernate is that the persist() method immediately saves the object to the database, while the save() method adds an object to the persistence context, but does not immediately save it to the database.
3. The session.persist() and session.save() methods are the same thing in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** The difference between session.persist() and session.save() methods in Hibernate is that the persist() method adds an object to the persistence context, but does not immediately save it to the database, while the save() method immediately saves the object to the database. This allows you to control the timing of when an object is saved to the database, depending on the needs of your application.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1029
**Pregunta:** What is the difference between session.update() and session.merge() methods in Hibernate?
**Nivel:** Intermedio

1. The difference between session.update() and session.merge() methods in Hibernate is that the update() method updates an object that is already in the persistence context, while the merge() method updates an object that is not in the persistence context.
2. The difference between session.update() and session.merge() methods in Hibernate is that the update() method updates an object that is not in the persistence context, while the merge() method updates an object that is already in the persistence context.
3. The session.update() and session.merge() methods are the same thing in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** The difference between session.update() and session.merge() methods in Hibernate is that the update() method updates an object that is already in the persistence context, while the merge() method updates an object that is not in the persistence context. The merge() method first retrieves a copy of the object from the database, and then updates the copy with the changes from the detached object.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1031
**Pregunta:** What is the use of session.refresh() method in Hibernate?
**Nivel:** Básico

1. The session.refresh() method in Hibernate is used to refresh an object, retrieving the latest data from the database.
2. The session.refresh() method in Hibernate is used to lock an object, preventing other transactions from accessing the same data until the current transaction is finished.
3. The session.refresh() method in Hibernate is used to persist an object, saving it to the database.

**Respuesta Correcta:** 1

**Explicación:** The session.refresh() method in Hibernate is used to refresh an object, retrieving the latest data from the database. This method updates the values of the object with the latest data from the database, discarding any changes that have been made to the object since it was last retrieved from the database.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1032
**Pregunta:** What is the use of session.evict() method in Hibernate?
**Nivel:** Básico

1. The session.evict() method in Hibernate is used to remove an object from the persistence context, making it eligible for garbage collection.
2. The session.evict() method in Hibernate is used to refresh an object, retrieving the latest data from the database.
3. The session.evict() method in Hibernate is used to persist an object, saving it to the database.

**Respuesta Correcta:** 1

**Explicación:** The session.evict() method in Hibernate is used to remove an object from the persistence context, making it eligible for garbage collection. This method is useful when you need to remove an object from the persistence context, but do not want to delete it from the database.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1033
**Pregunta:** What is the difference between session.clear() and session.flush() methods in Hibernate?
**Nivel:** Intermedio

1. The difference between session.clear() and session.flush() methods in Hibernate is that the clear() method clears the persistence context, discarding all changes to objects, while the flush() method flushes all pending updates and inserts to the database.
2. The difference between session.clear() and session.flush() methods in Hibernate is that the clear() method flushes all pending updates and inserts to the database, while the flush() method clears the persistence context, discarding all changes to objects.
3. The session.clear() and session.flush() methods are the same thing in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** The difference between session.clear() and session.flush() methods in Hibernate is that the clear() method clears the persistence context, discarding all changes to objects, while the flush() method flushes all pending updates and inserts to the database. The clear() method is useful when you need to clear the persistence context, for example, to free up memory, while the flush() method is useful when you need to execute all pending database operations immediately.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1035
**Pregunta:** What is the difference between session.flush() and session.clear() methods in Hibernate?
**Nivel:** Intermedio

1. The difference between session.flush() and session.clear() methods in Hibernate is that the flush() method flushes all pending updates and inserts to the database, while the clear() method clears the persistence context, discarding all changes to objects.
2. The difference between session.flush() and session.clear() methods in Hibernate is that the flush() method clears the persistence context, discarding all changes to objects, while the clear() method flushes all pending updates and inserts to the database.
3. The session.flush() and session.clear() methods are the same thing in Hibernate.

**Respuesta Correcta:** 1

**Explicación:** The difference between session.flush() and session.clear() methods in Hibernate is that the flush() method flushes all pending updates and inserts to the database, while the clear() method clears the persistence context, discarding all changes to objects. The flush() method is useful when you need to execute all pending database operations immediately, while the clear() method is useful when you need to clear the persistence context, for example, to free up memory.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1036
**Pregunta:** What is the use of session.replicate() method in Hibernate?
**Nivel:** Básico

1. The session.replicate() method in Hibernate is used to replicate an object from one database to another, making a copy of the object in the second database.
2. The session.replicate() method in Hibernate is used to persist an object, saving it to the database.
3. The session.replicate() method in Hibernate is used to remove an object from the persistence context, making it eligible for garbage collection.

**Respuesta Correcta:** 1

**Explicación:** The session.replicate() method in Hibernate is used to replicate an object from one database to another, making a copy of the object in the second database. This method is useful when you need to replicate data between databases, for example, for backup or disaster recovery purposes.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1044
**Pregunta:** What is MOJO in Maven?
**Nivel:** Básico

1. MOJO in Maven stands for Maven Ordered Java Objects.
2. MOJO in Maven stands for Maven Object-Oriented Java.
3. MOJO in Maven stands for Maven Plugin Java Objects.

**Respuesta Correcta:** 3

**Explicación:** MOJO in Maven stands for Maven Plugin Java Objects. MOJOs are the executable components of Maven plugins, responsible for performing specific tasks during the build process.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1052
**Pregunta:** What is a POM?
**Nivel:** Básico

1. POM is an acronym for Project Object Model, which is an XML file used by Maven to define the project's build and dependencies.
2. POM is an acronym for Project Order Model, which is an XML file used by Maven to define the order in which tasks should be executed in a project.
3. POM is an acronym for Project Output Model, which is an XML file used by Maven to define the output generated by a project.

**Respuesta Correcta:** 1

**Explicación:** POM is an acronym for Project Object Model, which is an XML file used by Maven to define the project's build and dependencies. The POM contains information such as the project's name, version, and dependencies, and is used by Maven to build the project.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1075
**Pregunta:** Where will you find the class files after compiling a Maven project successfully?
**Nivel:** Básico

1. The class files will be found in the target/classes directory of a Maven project after compiling it successfully.
2. The class files will be found in the src/main/java directory of a Maven project after compiling it successfully.
3. The class files will be found in the target directory of a Maven project after compiling it successfully.
4. The class files will be found in the src directory of a Maven project after compiling it successfully.

**Respuesta Correcta:** 1

**Explicación:** The class files will be found in the target/classes directory of a Maven project after compiling it successfully. The compiled classes are stored in this directory, and it is the default location for compiled classes in a Maven project.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1076
**Pregunta:** Where will you find the class files after compiling a Maven project successfully?
**Nivel:** Básico

1. In the target directory.
2. In the src/main/java directory.
3. In the src/test/java directory.

**Respuesta Correcta:** 1

**Explicación:** After a Maven project is successfully compiled, the class files can be found in the target directory. This directory is generated automatically by Maven and contains the compiled output of the project.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1081
**Pregunta:** How will you run test classes in Maven?
**Nivel:** Intermedio

1. By using the mvn test command.
2. By using the mvn compile command.
3. By using the mvn install command.

**Respuesta Correcta:** 1

**Explicación:** To run test classes in Maven, we can use the mvn test command. This command compiles the test classes and runs them, allowing us to verify that the code is working as expected.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1082
**Pregunta:** Sometimes Maven compiles the test classes but doesn't run them? What could be the reason for it?
**Nivel:** Básico

1. The test classes have been marked as skipped.
2. The test classes have syntax errors.
3. The test classes are not in the correct location.

**Respuesta Correcta:** 1

**Explicación:** If Maven compiles the test classes but doesn't run them, it could be because the test classes have been marked as skipped. This can be done using the skipTests or testSkip properties in the Maven configuration, or by using the -Dmaven.test.skip=true option when running the build.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1086
**Pregunta:** What is the difference between Inheritance and Multi-module in Maven?
**Nivel:** Intermedio

1. Inheritance is used to share common configuration across multiple projects, while Multi-module is used to manage multiple projects within a single build.
2. Multi-module is used to share common configuration across multiple projects, while Inheritance is used to manage multiple projects within a single build.
3. Both Inheritance and Multi-module are the same.

**Respuesta Correcta:** 2

**Explicación:** In Maven, Inheritance is used to share common configuration across multiple projects, while Multi-module is used to manage multiple projects within a single build. Multi-module allows us to build, test, and package multiple projects as a single unit, while Inheritance allows us to define a common parent POM for multiple projects, reducing duplication and making it easier to manage the configuration of multiple projects.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

## Pregunta 1097
**Pregunta:** What is the role of the POM (Project Object Model) in Maven?
**Nivel:** Básico

1. The POM is a configuration file for a Maven project, specifying the project's dependencies, build configuration, and other information.
2. The POM is a build output file for a Maven project, specifying the project's dependencies, build configuration, and other information.
3. The POM is a source code file for a Maven project, specifying the project's dependencies, build configuration, and other information.

**Respuesta Correcta:** 1

**Explicación:** The POM (Project Object Model) is a configuration file for a Maven project, specifying the project's dependencies, build configuration, and other information. The POM is used by Maven to manage the build process, dependencies, and other aspects of the project. The POM is a crucial part of a Maven project, and is used to configure the build and manage the dependencies required for the project.

### Ejemplos de Código

```java
// Ejemplo de Programación Orientada a Objetos
abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    // Método abstracto
    public abstract void hacerSonido();
    
    // Método concreto
    public void comer() {
        System.out.println(nombre + " está comiendo");
    }
}

class Perro extends Animal {
    public Perro(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Guau!");
    }
}

class Gato extends Animal {
    public Gato(String nombre) {
        super(nombre);
    }
    
    @Override
    public void hacerSonido() {
        System.out.println(nombre + " dice: ¡Miau!");
    }
}

// Ejemplo de polimorfismo
public class EjemploPOO {
    public static void main(String[] args) {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        for (Animal animal : animales) {
            animal.hacerSonido(); // Polimorfismo
            animal.comer();
        }
    }
}
```

### Pruebas Unitarias

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

abstract class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract String hacerSonido();
    public String getNombre() { return nombre; }
}

class Perro extends Animal {
    public Perro(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Guau";
    }
}

class Gato extends Animal {
    public Gato(String nombre) { super(nombre); }
    
    @Override
    public String hacerSonido() {
        return "Miau";
    }
}

public class POOTest {
    
    @Test
    public void testHerencia() {
        Perro perro = new Perro("Rex");
        assertEquals("Rex", perro.getNombre());
        assertEquals("Guau", perro.hacerSonido());
    }
    
    @Test
    public void testPolimorfismo() {
        Animal[] animales = {
            new Perro("Rex"),
            new Gato("Mittens")
        };
        
        assertEquals("Guau", animales[0].hacerSonido());
        assertEquals("Miau", animales[1].hacerSonido());
    }
    
    @Test
    public void testInstanciaDe() {
        Animal perro = new Perro("Rex");
        assertTrue(perro instanceof Animal);
        assertTrue(perro instanceof Perro);
        assertFalse(perro instanceof Gato);
    }
}
```

---

